<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" lang="en"><head>
<meta http-equiv="Content-type" content="text/html; charset=UTF-8"><title>Developer Manual — Plone CMS: Open Source Content Management</title><!-- base href="http://plone.org/documentation/manual/developer-manual/" --><link rel="alternate" type="application/rss+xml" href="http://feeds.plone.org/plonenews" title="Plone News"><link rel="alternate" type="application/rss+xml" href="http://feeds.plone.org/plonereleases" title="Plone Releases"><link rel="alternate" type="application/rss+xml" href="http://feeds.plone.org/ploneevents" title="Upcoming Plone Events"><link rel="alternate" type="application/rss+xml" href="http://feeds.plone.org/ploneaddons" title="Latest Plone &amp; Add-on Releases"><link rel="alternate" type="application/rss+xml" href="http://feeds.plone.org/plonetraining" title="Upcoming Plone Training"><link rel="alternate" type="application/rss+xml" href="http://feeds.plone.org/ploneblogs" title="Plone Blogs"><link rel="alternate" type="application/rss+xml" href="http://feeds.plone.org/plone-security" title="Plone Security Advisories"><!--[if IE]><style type="text/css" media="all">@import url(/ie.css);</style><![endif]--><!--[if lte IE 6]><script src="/ie6warn.js" type="text/javascript"></script><![endif]--><script src="developer-manual_archivos/ga.js" type="text/javascript"></script><script type="text/javascript" src="developer-manual_archivos/jquery-cachekey7059.js"></script><script type="text/javascript" src="developer-manual_archivos/popupforms-cachekey4563.js"></script><script type="text/javascript" src="developer-manual_archivos/resourcecioppino.js"></script><style type="text/css">@import url(http://plone.org/portal_css/Sunburst%20Theme/print-cachekey3245.css);</style><style type="text/css">@import url(http://plone.org/portal_css/Sunburst%20Theme/newplone-cachekey7635.css);</style><style type="text/css" media="screen">@import url(http://plone.org/portal_css/Sunburst%20Theme/resourceplone.app.jquerytools.overlays-cachekey5924.css);</style><style type="text/css" media="screen">@import url(http://plone.org/portal_css/Sunburst%20Theme/resourceProducts.PloneSoftwareCenter.stylesheetspsc-cachekey4912.css);</style><style type="text/css" media="all">@import url(http://plone.org/portal_css/Sunburst%20Theme/psc-cachekey1695.css);</style><style type="text/css">@import url(http://plone.org/portal_css/Sunburst%20Theme/resourcecioppino.twothumbs.stylesheetstwothumbs-cachekey0775.css);</style><link rel="kinetic-stylesheet" type="text/css" href="http://plone.org/portal_kss/Sunburst%20Theme/resourcetinymce.ksstinymce-cachekey4684.kss"><link rel="kinetic-stylesheet" type="text/css" href="http://plone.org/portal_kss/Sunburst%20Theme/at-cachekey2728.kss"></head><body class="template-referencemanual-all-pages portaltype-helpcenterreferencemanual section-documentation"><div id="outer-wrapper"><div id="inner-wrapper"><div id="nav"><a id="portal-logo" title="Home" accesskey="1" href="http://plone.org/">
    <img src="developer-manual_archivos/logo.png" alt="" title="" height="56" width="215"></a><form id="search" name="searchform" action="http://plone.org/search"><input value="Search this site…" id="search-site" name="SearchableText" title="Search this site…" accesskey="4" class="inputLabel inputLabelActive" size="15" type="text"></form><div id="nav-bar"><div id="user"><a id="login-link" href="http://plone.org/login">Log in</a><a id="user-id" href="http://plone.org/@@personal-preferences"><span id="username"></span></a><div id="login-popup"><span class="loginText">Login to Plone.org</span><form id="login-slide-form" action="https://plone.org/login_form" method="post"><div class="form"><input id="came-from-input" value="" name="came_from" type="hidden"><input name="form.submitted" value="1" type="hidden"><label for="__ac_name">username</label><input id="__ac_name" name="__ac_name" size="15" type="text"><label for="__ac_password">password</label><input id="__ac_password" value="" name="__ac_password" size="15" type="password"><br><a href="http://plone.org/mail_password_form?userid=">Forgot password?</a></div><input value="Let me in!" name="submit" class="context" type="submit"></form><span class="createText"><a href="http://plone.org/@@register">Click here</a> to create an account</span></div></div><ul id="main-nav" class="navigation"><li id="portaltab-index_html" class="plain"><a href="http://plone.org/" title="">Home</a></li><li id="portaltab-products" class="plain"><a href="http://plone.org/products" title="Plone releases and available add-on products for Plone. Make sure you have Plone installed before downloading the add-ons — and make sure you are using add-ons that have been certified for use with your particular version.">Download &amp; Extend</a></li><li id="portaltab-documentation" class="selected"><a href="http://plone.org/documentation" title="The primary source for Plone documentation.">Documentation</a></li><li id="portaltab-contribute" class="plain"><a href="http://plone.org/contribute" title="Contains all developer-related material.">Get Involved</a></li><li id="portaltab-foundation" class="plain"><a href="http://plone.org/foundation" title="The Plone Foundation exists to further the development, marketing, and legal affairs of Plone and the Plone community.">Plone Foundation</a></li><li id="portaltab-support" class="plain"><a href="http://plone.org/support" title="Support and contact details for the Plone project.">Support</a></li><li id="portaltab-providers" class="plain"><a href="http://plone.org/providers" title="">Providers</a></li></ul></div><ul id="sub-nav" class="navigation"><li>
            <a href="http://plone.org/documentation/manual" class="selected" title="Manuals are larger works of documentation describing particular technologies or concepts in a detailed, structured manner.">Manuals</a>
        </li>
        <li>
            <a href="http://plone.org/documentation/kb" title="Community-contributed tutorials and how-tos.">Knowledge Base</a>
        </li>
        <li>
            <a href="http://plone.org/documentation/faq" title="Frequently Asked Questions.">FAQs</a>
        </li>
        <li>
            <a href="http://plone.org/documentation/error" title="Error reference section.">Error Reference</a>
        </li>
        <li>
            <a href="http://plone.org/documentation/link" title="Links section.">Links</a>
        </li>
        <li>
            <a href="http://plone.org/documentation/glossary" title="Glossary of terms for Plone.">Glossary</a>
        </li>
    </ul></div><div id="edit-bar"><div id="action-menu"></div><div id="edit-menu"></div></div><div id="content-wrapper"><div class="grid-row"><div class="grid-cell position-leftmost width-two-thirds"><div id="viewlet-above-content"></div><div id="content">
            <div>

                <h1>
                    Developer Manual
                </h1>

                <p class="discreet visualNoPrint">
                    <a href="http://plone.org/documentation/manual/developer-manual">« Return to page index</a>
                </p>

                <p class="documentDescription">Plone Developer Manual is a comprehensive guide to Plone programming.</p>

                
    
        <div class="referenceManualCollation depth-1">

            <h1>
                1.
                Managing projects with Buildout
            </h1>

            <p class="documentDescription">Learn about eggs, setuptools and dependency management, and how to use Buildout to set up a development environment.</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-2">

            <h1>
                1.1.
                Introduction
            </h1>

            <p class="documentDescription">Or: "What's wrong with a plain old Zope instance"?</p>
    
            <div>
                
                    <div><p>This tutorial shows how to install Plone 3 into a <em>buildout</em>,
and how to use that buildout when working on a software project that
extends Plone. A buildout is a self-contained environment where you can
manage the dependencies (including Zope and Plone and any third-party
products or libraries you need) and custom code for your project. Even
if you are not planning on writing any custom code, the buildout
approach is an easy way to install Plone in a robust, well-tested
manner.&nbsp; As of Plone 3.2, all of the installers are now buildout
based.</p>

<p>Prior to Plone 3.0, most developers and users who did not use a GUI
installer, would set up a Zope instance, drop in a few products into
the <em>Products </em>folder, and be done with it. Unfortunately, this approach has a few problems:</p>

<ul><li>Plain old Zope instances are not very well equipped to deal with packages distributed as python <em>eggs</em> or using setuptools <em>namespace packages</em>. Many new packages in Plone 3 are made in this way, and more and more third party modules will be as well.</li><li>Without
access to the metadata that is held in eggs, developers may find it too
time-consuming or confusing to factor their work into multiple packages
that are more re-usable, preferring monolithic products that are
impossible to re-use outside Zope.<br></li><li>Without any further tools, it is cumbersome to repeat a setup across different environments.</li></ul><p>As eggs become more important, developers should look to employ more appropriate tools for managing their code. <strong>zc.buildout</strong>,
hereafter referred to only as "buildout" is one such tool. This
tutorial shows how to use buildout for day-to-day development as well
as deployment.</p>

<h3>More buildout documentation and background</h3>

<p>Buildout was created by Jim Fulton of Zope Corporation, and is documented in depth at: <a class="external-link" href="http://buildout.org/">http://buildout.org/</a></p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                1.2.
                Packages, products and eggs
            </h1>

            <p class="documentDescription">Looking at the core concepts in more detail</p>
    
            <div>
                
                    <div><h2>Terminology<br></h2>

<p>Before we begin, you should familiarize yourself with these terms:</p>

<ul><li><a title="Software home" class="internal-link" href="http://plone.org/documentation/manual/glossary/software-home">Software home </a><br></li><li><a title="Zope instance" class="internal-link" href="http://plone.org/documentation/manual/glossary/zope-instance">Zope instance</a> </li><li><a title="Python path" class="internal-link" href="http://plone.org/documentation/manual/glossary/python-path">Python path</a></li><li><a title="Python package" class="internal-link" href="http://plone.org/documentation/manual/glossary/python-package">Python package</a></li><li><a title="Zope product" class="internal-link" href="http://plone.org/documentation/manual/glossary/zope-product">Zope product</a></li><li><a title="Python egg" class="internal-link" href="http://plone.org/documentation/manual/glossary/python-egg">Python egg</a> </li><li><a title="Python Package Index" class="internal-link" href="http://plone.org/documentation/manual/glossary/python-package-index">The Python Package Index</a><br></li><li><a title="easy_install" class="internal-link" href="http://plone.org/documentation/manual/glossary/easy_install">easy_install</a></li><li><a title="Namespace package" class="internal-link" href="http://plone.org/documentation/manual/glossary/namespace-package">Namespace package</a> </li></ul><h2>The magic Products namespace&nbsp;</h2>

<p>When Zope finds a "product", it will create an entry in <em>Control_Panel/Product</em>s in the root of the ZMI, and run the <em>initialize()</em> method, found in the product's root <em>__init__.py</em>
file, each time Zope starts up. Not every package used in a Plone
context needs to be a product, but "productness" is required for:</p>

<ul><li>GenericSetup profiles</li><li>Skin directories being installed as layers in the <em>portal_skins</em> tool (but <em>not</em> for Zope 3-style browser views)</li></ul><p>The easiest way to create a product is to use Paster/ZopeSkel to create an egg-ready package in the <em>Products.*</em> namespace using the <em>basic_namespace</em> template:</p>

<pre>$ paster create -t basic_namespace Products.myproduct
Selected and implied templates:
  ZopeSkel#basic_namespace  A project with a namespace package

Variables:
  egg:      Products.myproduct
  package:  productsmyproduct
  project:  Products.myproduct
Enter namespace_package (Namespace package (like plone)) ['plone']: Products
Enter package (The package contained namespace package (like example)) ['example']: myproduct
... accept defaults to end
</pre>

<p>If you're using buildout, create your package in the <em>src </em>directory, and add references to it in the develop and instance/eggs sections of buildout.cfg:</p>

<pre>develop =
&nbsp;&nbsp;&nbsp; src/Products.myproduct
...
[instance]
...
eggs =
&nbsp;&nbsp;&nbsp; ${buildout:eggs}
&nbsp;&nbsp;&nbsp; ${plone:eggs}
&nbsp;&nbsp;&nbsp; Products.myproduct
</pre>

<p>Run bin/buildout and you'll be set up to develop your egg-ready product in the <em>src </em>directory. Turn it into a distribution egg when complete.</p>

<p>It is possible to use packages (including egg-distributed ones) outside the <em>Products </em>namespace/directory
as Zope 2 products. Many developers prefer this approach, feeling it
unnatural to keep everything in a single, "flat" namespace.</p>

<p>Extra steps are required for this. Prior to Zope 2.10.4, this is also required for products in the <em>Products </em>namespace</p>

<p>We must add a line like the following to the package's <em>configure.zcml</em>:</p>

<pre>&lt;configure 
    xmlns="http://namespaces.zope.org/zope"
    xmlns:five="http://namespaces.zope.org/five"&gt;

  &lt;five:registerPackage package="." initialize=".initialize" /&gt;

&lt;/configure&gt;
</pre>

<h3></h3>

<p>

Secondly, it is important to realize that packages outside the <em>Products </em>namespace are not automatically detected when Zope starts up. If they contain <em>configure.zcml </em>files (as most packages will do), this must be explicitly included from somewhere. This may be:</p>

<ul><li>Another package's configure.zcml file.</li><li>Zope's site.zcml, the root of all ZCML files, which is found in the <em>etc </em>directory in the instance home.</li><li>A ZCML <em>slug</em>, a one-liner created in the zope instance's <em>etc/package-includes </em>directory, with a name like <em>my.package-configure.zcml</em>.</li></ul><p>In all cases, the syntax is the same:</p>

<pre>&lt;include package="my.package" file="configure.zcml" /&gt;
</pre>

<p>If you have <em>meta.zcml</em> or <em>overrides.zcml</em> files, you can add <em>&lt;include /&gt;</em> directives for these as well. If you are using slugs, it must be named accordingly, e.g. <em>my.package-meta.zcml</em> or <em>my.package-overrides.zcml</em>. A slug can not contain more than one line.</p>

<p>Later in this tutorial, we will show how buildout can manage slugs for us automatically.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                1.3.
                Prerequisites
            </h1>

            <p class="documentDescription">A few things you need before we can get started</p>
    
            <div>
                
                    <div><p>Before we can create a buildout to manage Zope and Plone, there are a few prerequisites to take care of.</p>

<p class="callout">As of Plone 3.2, all of the Plone installers are buildout based.&nbsp; You can get the latest <a class="external-link" href="http://plone.org/products/plone">installer</a>
and run it to have a working buildout without having to follow these
steps. However, these steps are still valid if you want to create the
buildout manually with ZopeSkel.</p>

<p>First, you will need an appropriate Python interpreter, if you do not have one already:</p>

<ul><li>Install <a href="http://www.python.org/download/releases/">Python 2.4 </a>for your platform, and add it to your system <em>PATH</em>. It is easiest if Python 2.4 is what you get when you type <em>python -V</em>
on a command line. Make sure you're using Python 2.4 and not 2.5, since
Plone 3.x doesn't support Python 2.5 or later. You might need to type <em>python2.4</em> instead of just <em>python</em> when running some of the following commands.<br></li><li>If
you installed Python using an operating system package (e.g. an RPM),
make sure you get the development package (e.g. python-devel) as well.
This includes Python header files that we will use later to compile
Zope. If you installed from source, or used the Python Windows
installer, you should already have these.<br></li><li>Install <a href="http://www.pythonware.com/products/pil/">PIL</a>, the Python Imaging Library into this Python interpreter.</li><li>Install <a class="external-link" href="http://peak.telecommunity.com/DevCenter/setuptools">setuptools</a>. If you're using Linux and your distributioni doesn't provide a package for setuptools, download <a href="http://peak.telecommunity.com/dist/ez_setup.py">ez_setup.py</a> and run it with:

<pre>$ python ez_setup.py
</pre>

<p>

This will download and install setuptools and the <em>easy_install </em>script. Watch the console output to understand where <em>easy_install</em> is installed. If this is not in your system <em>PATH</em>, you should add this directory to the path as well.</p>

</li></ul><p>Finally, use <em>easy_install </em>to get <em>ZopeSkel</em>, a collection of skeleton templates for Zope and Plone development:</p>

<pre>$ easy_install -U ZopeSkel
</pre>

<p>This will get <em>Paste Script</em> and various other dependencies.</p>

<p class="discreet">Linux note: If you're installing setuptools and
ZopeSkel system-wide, you will probably need to
become superuser or use sudo, if you're not using virtualenv or
similar. But please note that bin/buildout (introduced later) should
never be run as root. If you really can't avoid running this script as
root, don't forget to change the owner of created files (chown -R) so
the unprivileged user that runs the zope instance will be able to read
those files.</p>

<p> If you added the Python console scripts directory (where <em>easy_install</em> was placed) to your system path, you should now be able to run the <em>paster </em>command. You can test it with:</p>

<pre>$ paster create --list-templates
Available templates:
  basic_namespace:          A project with a namespace package
  basic_package:            A basic setuptools-enabled package
  basic_zope:               A Zope project
  nested_namespace:         A project with two nested namespaces.
  plone:                    A Plone project
  plone2.5_theme:           A Theme for Plone 2.5
  plone2_theme:             A Theme for Plone 2.1 &amp; Plone 2.5
  plone3_buildout:          A buildout for Plone 3 projects
  plone3_theme:             A Theme for Plone 3.0
  plone_app:                A Plone App project
</pre>

<p>Your output may differ slightly, but make sure you have the <em>plone3_buildout</em> and <em>plone </em>templates at least.</p>

<h2>Additional installation steps for Windows</h2>

<p>If you are using Windows, there are a few more things you need to do.</p>

<p>First, get and install the <a href="http://downloads.sourceforge.net/pywin32/pywin32-210.win32-py2.4.exe?modtime=1159009237&amp;big_mirror=0">Python Win32 extensions</a> for Python 2.4.</p>

<p>If you intend to compile Zope yourself, rather than using a binary
installer, or if you ever need to compile an egg with C extensions, you
will need the <a href="http://downloads.sourceforge.net/mingw/MinGW-5.1.3.exe?modtime=1168794334&amp;big_mirror=1">mingw32 compiler</a>. Make sure you choose the "base" and "make" modules at a minimum when the installer asks. By default, this installs into <em>C:\MingW32</em>. Inside the installation directory, there will be a bin directory, e.g. <em>C:\MingW32\bin</em>. Add this to your system <em>PATH</em>.</p>

<p>Finally, you need to configure Python's <em>distutils </em>package to use the mingw32 compiler. Create a file called <em>distutils.cfg</em> in the directory <em>C:\Python24\Lib\distutils</em> (presuming Python was installed in <em>C:\Python24</em>, as is the default). Edit this with Notepad, and add the following:</p>

<pre>[build]
compiler=mingw32
</pre></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                1.4.
                Creating a buildout for your project
            </h1>

            <p class="documentDescription">How to create a new buildout for a project, adding Plone and other third party products as dependencies</p>
    
            <div>
                
                    <div><p>We
are now ready to create a new buildout. The "buildout" is a directory
containing all the parts that make up a project, including a Zope
instance, the Plone sources, custom configuration options, and your our
project's source code.</p>

<p class="callout">As of Plone 3.2, all of the Plone installers are buildout based.&nbsp; You can get the latest <a class="external-link" href="http://plone.org/documentation/products/plone">installer</a>
and run it to have a working buildout without having to follow these
steps. However, these steps are still valid if you want to create the
buildout manually with ZopeSkel.</p>

<p>Create one like this:</p>

<pre>$ paster create -t plone3_buildout myproject
</pre>

<p>This will ask a series of questions. If you want to use an existing
installation of Zope rather than have buildout download and compile one
for you, specify an absolute path as the <em>zope2_install</em>.
Similarly, if you do not want buildout to download the core Plone
products, you can point it to an existing directory containing all the
products (it will still download Plone 3's eggs, but as we will see
later, it is possible to share an eggs directory among multiple
buildouts). You will need to enter a Zope administrator username and
password, and you may want to turn debug mode and verbose security <em>on </em>during development.</p>

<p>Now, enter the newly created myproject directory, and run the
buildout bootstrap script.&nbsp; NOTE: Python 2.4 is currently required
to Plone 3.x:</p>

<pre>$ cd myproject
$ python2.4 bootstrap.py
</pre>

<p>This will create a number of directories and scripts and dowload the
latest version of the zc.buildout egg. This step should be needed only
once.</p>

<p>To get started straight away, run:</p>

<pre>$ ./bin/buildout</pre>

<p>This reads the generated buildout.cfg file and executes its various
"parts", setting up Zope, creating a Zope instance, downloading and
installing Plone. We will explain this file in more detail shortly.</p>

<p>You will need to run <em>./bin/buildout</em> again each time you change <em>buildout.cfg</em>.
If you do not want buildout to go online and look for updated versions
of eggs or download other archives, you can run it in non-updating,
offline mode, with;</p>

<pre>$ ./bin/buildout -No
</pre>

<p>To start Zope in foreground and debug mode, run:</p>

<pre>$ ./bin/instance fg
</pre>

<p>The <em>instance </em>script is analogous to <em>zopectl </em>as found in a standard Zope instance. You can use <em>./bin/instance start</em> to run Zope in daemon mode. It can also be used to run tests:</p>

<pre>$ ./bin/instance test -s plone.portlets
</pre>

<p>Running:</p>

<pre>bin/instance console
</pre>

<p>is equivalent to <em>bin/instance fg</em>, but does not implicitly turn on debug mode but respects the <em>debug-mode</em> setting in <em>buildout.cfg</em>. This can be useful to run Zope in non-development mode with daemon-control programs like supervisord.</p>

<p>Once your buildout installation is up and running, you will still
need to install a Plone site.&nbsp; Log in to the Zope Management
Interface (ZMI) and from "select type to add..." choose Plone
Site.&nbsp; Fill in the required details and submit.&nbsp; Now you have
a Plone site at the ID that you specified.</p>

<h2>Directories in the buildout</h2>

<p>Before we dive into buildout.cfg, let us take a quick look at the directories that buildout has created for us:</p>

<dl><dt>bin/</dt><dd>Contains various executables, including the <em>buildout </em>command, and the <em>instance </em>Zope control script.</dd><dt>eggs/ </dt><dd>Contains eggs that buildout has downloaded. These will be explicitly activated by the control scripts in the <em>bin/</em> directory.</dd><dt>downloads/ </dt><dd>Contains non-egg downloads, such as the Zope source code archive. </dd><dt>var/ </dt><dd>Contains the log files (in <em>var/log/</em>) and the file storage ZODB data (in <em>var/filestorage/Data.fs</em>). Buildout will never overwrite these.<br>If you want to import a .zexp file, place it in the <em>var/instance/imports</em> folder. <br><p class="discreet">Previously one had to put that file into <em>parts/instance/import</em>, but this folder gets wiped and regenerated when running <em>bin/buildout</em>, so the import location was changed.</p>

</dd><dt>src/ </dt><dd>Initially empty. You can place your own development eggs here and reference them in <em>buildout.cfg</em>. More on that later.<br></dd><dt>products/ </dt><dd>This is analogous to a Zope instance's <em>Products/</em>
directory (note the difference in capitalisation). If you are
developing any old-style Zope 2 products, place them here. We will see
how buildout can automatically download and manage archives of
products, but if you want to extract a product dependency manually, or
check one out from Subversion, this is the place to do so.<br></dd><dt>parts/</dt><dd>Contains
code and data managed by buildout. In our case, it will include the
local Zope installation, a buildout-managed Zope instance, and Plone's
source code. In general, you should not modify anything in this
directory, as buildout may overwrite your changes.</dd></dl><p class="callout">You
can check in a buildout directory to a source code repository to share
it among developers. In this case, you should ignore the directories
bin/, eggs/, downloads/, var/, and parts/. Each developer can run <em>bootstrap.py</em>
to get these back, and will normally need local copies anyway. All your
configuration should be in the buildout.cfg file, and all custom code
in src/ or products/.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                1.5.
                Understanding buildout.cfg
            </h1>

            <p class="documentDescription">How to manage the main buildout configuration file</p>
    
            <div>
                
                    <div><p><strong>Important note:<em> </em></strong>This document applies to Plone 3.2

onwards. In Plone versions prior to 3.2 the vanilla buildout.cfg file

was significatively different because Plone wasn't fully eggified.</p>

<p><em>buildout.cfg</em> is the most important file in your new buildout environment. Here is how it looks:</p>

<pre>[buildout]
parts =
    zope2
    productdistros
    instance
    zopepy

# Change the number here, and in find-links below, to change the version of
# Plone being used
extends = http://dist.plone.org/release/3.3.5/versions.cfg
versions = versions

# Add additional egg download sources here. dist.plone.org contains archives
# of Plone packages.
find-links =
    http://dist.plone.org/release/3.3.5
    http://dist.plone.org/thirdparty

# Add additional eggs here
eggs =
    
# Reference any eggs you are developing here, one per line
# e.g.: develop = src/my.package
develop =

[zope2]
recipe = plone.recipe.zope2install
url = ${versions:zope2-url}

# Use this section to download additional old-style products.
# List any number of URLs for product tarballs under URLs (separate
# with whitespace, or break over several lines, with subsequent lines
# indented). If any archives contain several products inside a top-level
# directory, list the archive file name (i.e. the last part of the URL, 
# normally with a .tar.gz suffix or similar) under 'nested-packages'.
# If any archives extract to a product directory with a version suffix, list
# the archive name under 'version-suffix-packages'.
[productdistros]
recipe = plone.recipe.distros
urls =
nested-packages =
version-suffix-packages = 

[instance]
recipe = plone.recipe.zope2instance
zope2-location = ${zope2:location}
user = admin:admin
http-address = 8080
# comment the following two options in production sites
debug-mode = on
verbose-security = on

# If you want Zope to know about any additional eggs, list them here.
# This should include any development eggs you listed in develop-eggs above,
# e.g. eggs = Plone my.package
eggs =
    Plone
    ${buildout:eggs}

# If you want to register ZCML slugs for any packages, list them here.
# e.g. zcml = my.package my.other.package
zcml = 

products =
    ${buildout:directory}/products
    ${productdistros:location}

[zopepy]
recipe = zc.recipe.egg
eggs = ${instance:eggs}
interpreter = zopepy
extra-paths = ${zope2:location}/lib/python
scripts = zopepy
</pre>

<p>Let us walk through this file step-by-step:</p>

<h3>The main [buildout] section<br></h3>

<p>The <em>[buildout]</em> section is the starting point for the file. It

lists a number of "parts", which are configured in separate sections

later in the file. Each <em>part </em>has an associated <em>recipe</em>,

which is the name of an egg that knows how to perform a particular

task, e.g. build Zope or create a Zope instance. A recipe typically

takes a few configuration options.</p>

<p>Our global settings are as follows:</p>

<pre>[buildout]
parts =
    zope2
    productdistros
    instance
    zopepy

find-links =
    http://dist.plone.org/release/3.3.5
    http://dist.plone.org/thirdparty

eggs =
    
develop =</pre>

<p>This specifies that the parts <em>zope2</em>, <em>productdistros</em>, <em>instance </em>and <em>zopepy </em>will

be run, in that order. Then, we tell buildout that it can search one of

a number of URLs when it is looking for eggs to download. In addition,

it will always search the Cheese Shop.</p>

<p>Note that configuration entries are commonly split into multiple

lines.&nbsp; For this to work, all lines after the first must begin with <strong>at least 4 spaces</strong>.</p>

<p>Next, we can list any eggs that buildout should download and install

for us. This may include version specifications. For example, if you

want sqlalchemy 0.3,&nbsp; but not 0.4, you could list;</p>

<pre>eggs = 
    sqlalchemy&gt;=0.3,&lt;0.4dev
</pre>

<p>Please note that you will need the Python Imaging Library (PIL) for
Plone to work. This example assumes that you have this library already
installed and available from your Python interpreter, but otherwise you
can install a slightly modified (to workaround some common problems)
version from the "thirdparty" Plone repository in your buildout adding
its name to the eggs list:</p>

<pre>eggs =
    PILwoTk
</pre>



<p>And the full path to the package in the find-links, e.g.:</p>

<pre>find-links = http://dist.plone.org/thirdparty/PILwoTk-1.1.6.4.tar.gz
</pre>



<p>Finally, we can list development eggs, by specifying a directory where the egg is extracted in source format. For example:</p>

<pre>eggs =
    my.package

develop = 
    src/my.package
</pre>

<p>This presumes that there is an egg called <em>my.package</em> in the <em>src/ </em>directory.

We will learn how to create such eggs a little later in this tutorial.

Notice how we must also list my.package as an actual egg dependency:

development eggs are not automatically added to the "working set" of

eggs that are installed for Zope.</p>

<h3>The <em>extends</em> and <em>versions</em> lines</h3>

<p>This part was introduced with Plone 3.2. It references a remote file

where the version of each needed package is specified. Check that

remote file to see yourself how these dependencies are specified.</p>

<pre># Change the number here, and in find-links below, to change the version of
# Plone being used
extends = http://dist.plone.org/release/3.3.5/versions.cfg
versions = versions</pre>

<p>If you want to use a local file instead of a remote one to be able

to work offline, download it to your buildout directory and reference

it like this:</p>

<pre>extends = versions.cfg</pre>

<h3>The [zope2] section</h3>

<p>This part builds Zope 2, using <a href="http://cheeseshop.python.org/pypi/plone.recipe.zope2install">plone.recipe.zope2install</a>. If you specified an existing Zope installation, you will not have this part. Otherwise, it looks like this:</p>

<pre>[zope2]
recipe = plone.recipe.zope2install
url = ${versions:zope2-url}</pre>

<p>Here, we reference the download location for Zope as present in the

versions file. This ensures that we always get the recommended version

of Zope. You could specify a download URL manually instead, if you

wanted to use a different version of Zope.</p>

<p>When the recipe is run, Zope 2 is installed in <em>parts/zope2</em>. The Zope software home becomes <em>parts/zope2/lib/python</em>.</p>

<h3>The [productdistros] section</h3>

<p>This uses the <a href="http://cheeseshop.python.org/pypi/plone.recipe.distros">plone.recipe.distros </a>recipe,

which is able to download distributions (archives) of Zope 2 style

products and make them available to Zope. It is empty to begin with:</p>

<pre>[productdistros]
recipe = plone.recipe.distros
urls =
nested-packages =
version-suffix-packages =</pre>

<p>However, you can list any number of downloads. The recipe is also

able to deal with archives that contain a single top-level directory

that contains a bundle of actual product directories (<em>nested-packages</em>),

or packages that have a version number in the directory name and thus

need to be renamed to get the actual product directory (<em>version-suffix-packages</em>).</p>

<p>Consider the following distributions:</p>

<pre># A typical distribution 
ExampleProduct-1.0.tgz
 |
 |- ExampleProduct
     |
     |- __init__.py
     |- (product code)

# A version suffix distribution
AnotherExampleProduct-2.0.tgz
 |
 |- AnotherExampleProduct-2.0
     |
     |- __init__.py
     |- (product code)

# A nested package distribution
ExampleProductBundle-1.0.tgz
 |
 |- ExampleProductBundle
     |
     |- ProductOne
     |   |- __init__.py
     |   |- (product code)
     | 
     |- ProductTwo
         |- __init__.py
         |- (product code)
</pre>

<p>Here is what the part would look like if we try to install the three distributions above:</p>

<pre>[productdistros]
recipe = plone.recipe.distros
urls =
    http://example.com/dist/ExampleProduct-1.0.tgz
    http://example.com/dist/AnotherExampleProduct-2.0.tgz
    http://example.com/dist/ExampleProductBundle-1.0.tgz
nested-packages = ExampleProductBundle-1.0.tgz
version-suffix-packages = AnotherExampleProduct-2.0.tgz</pre>

<p>You can specify multiple downloads on separate lines. When the

recipe is run, the product directories for downloaded products are

found in <em>parts/productdistros</em>.</p>

<h3>The [instance] section</h3>

<p>The instance section pulls it all together: It configures a Zope instance using the <a href="http://cheeseshop.python.org/pypi/plone.recipe.zope2instance">plone.recipe.zope2instance </a>script. Here is how it looks:</p>

<pre>[instance]
recipe = plone.recipe.zope2instance
zope2-location = ${zope2:location}
user = admin:admin
http-address = 8080
# comment the following two options in production sites
debug-mode = on
verbose-security = on

eggs =
    Plone
    ${buildout:eggs}

zcml = 

products =
    ${buildout:directory}/products
    ${productdistros:location}
</pre>

<p>Here, we reference the Zope 2 installation from the <em>[zope2]</em>

part - if you specified a location yourself when creating the buildout,

you would see that one here. Then, we specify the initial admin user

and password used only when creating the initial database, and the port

that Zope will be bound to. We also turn on debug mode and verbose

security. They are useful for development, but remember to turn them

off in production sites since they can compromise the security of your

site. These options are used to generate an appropriate <em>zope.conf</em> file for this instance. See the <a href="http://cheeseshop.python.org/pypi/plone.recipe.zope2instance">recipe page in the Cheese Shop</a> for more details on the options available.</p>

<p>Next, we specify which eggs that will be made available to Zope. This references the "global" eggs from the <em>[buildout]</em>

section, as well as Plone itself. You could add additional eggs here,

though it is generally easier to specify these at the top of the file,

so that they get included in the <em>${buildout:eggs}</em> working set.</p>

<p>Zope 3 <em>configure.zcml</em> files are not automatically loaded for eggs or packages that lack <em>z3c.autoinclude</em> support and are not in the <em>Products </em>namespace. To load ZCML files for a regular package, we can make buildout create a ZCML slug by listing the package under the <em>zcml </em>option:</p>

<pre>zcml =
    my.package
    my.package-overrides
</pre>

<p>This assumes that <em>my.package </em>was previously referenced in the buildout. This would load both the main <em>configure.zcml </em>and the <em>overrides.zcml</em> file from this package.&nbsp; Over time, the need for these entries should diminish, as <em>z3c.autoinclude</em> support becomes widespread.</p>

<p>Finally, we list the various directories that contain Zope 2 style products - akin to the <em>Products/</em> directory in a traditional instance. Notice how the <em>products/</em> directory in the main buildout directory comes first, followed by the products downloaded with the <em>[productdistros]</em> part.</p>

<p>When the recipe is run, the Zope instance home will be <em>parts/instance</em>, and a control script is created in <em>./bin/instance</em>.</p>

<h3>The [zopepy] section</h3>

<p>This final section creates a Python interpreter that has all the

eggs and packages (but not Zope 2 style products) that Zope would have

during startup. This can be useful for testing purposes.</p>

<pre>[zopepy]
recipe = zc.recipe.egg
eggs = ${instance:eggs}
interpreter = zopepy
extra-paths = ${zope2:location}/lib/python
scripts = zopepy
</pre>

<p>Here, we copy the eggs from the <em>[instance]</em> section, and include in the pythonpath the Zope instance home.</p>

<p>When the recipe is run, the script will be created in <em>./bin/zopepy</em>.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                1.6.
                Creating a buildout defaults file
            </h1>

            <p class="documentDescription">This makes it possible to share configuration across multiple buildouts, and save some time and disk space.</p>
    
            <div>
                
                    <div><p>To set "global" options affecting all buildouts, create a directory <em>.buildout</em> (note leading dot) in your home directory, and add a file there called <em>default.cfg</em>. Any option set here will be applied to the corresponding section in any <em>buildout.cf</em>g that you run, unless it is overridden by a more specific option in the <em>buildout.cfg</em> file itself.</p>

<p>The most common options are:</p>

<dl><dt>executable </dt><dd>Specify a python interpreter other than the
system default. This is useful if you have Python 2.5 installed, say,
but you want your buildouts to use another installation of Python 2.4. </dd><dt>eggs-directory </dt><dd>Specify
a directory where eggs will be downloaded. This allows multiple
buildouts to share the same eggs, saving disk space and download time.
Note that only those eggs explicitly required by a particular buildout
will be activated. The eggs directory may contain many more eggs (or
many different versions of the same package) than what is used at any
one time. </dd><dt>download-cache </dt><dd>Specify a shared directory
for downloaded archives. Again, this can save disk space and download
time. NOTE: before zc.buildout 1.0, this was called download-directory </dd><dt>extends-cache </dt><dd>Specify
a shared directory for extended buildout configurations that are
downloaded from a URL. As of Plone 3.2 this is how Plone pins the <a class="external-link" href="http://dist.plone.org/release/3.2/versions.cfg">versions</a> of its eggs. This option was added in <a class="external-link" href="http://pypi.python.org/pypi/zc.buildout/1.4.1#specifying-extends-cache-and-offline-mode">zc.buildout 1.4.1</a>, prior to that the offline mode in combination with a extends URL would not work.<br></dd></dl><p>Here is an example <em>~/.buildout/default.cfg</em> setting all three:</p>

<pre>[buildout]
executable = /opt/python24/bin/python
eggs-directory = /home/username/.buildout/eggs
download-cache = /home/username/.buildout/downloads
extends-cache = /home/username/.buildout/extends
</pre>

<p>This assumes Python 2.4 is installed in <em>/opt/python2.4</em>. For the last two options to work, you would need to create the directories <em>eggs </em>and <em>downloads </em>inside the <em>~/.buildout</em> directory.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                1.7.
                Installing a third party product
            </h1>

            <p class="documentDescription">How to install a new package using these tools</p>
    
            <div>
                
                    <div><p>How to install a new third-party products will depend on whether it is packaged as an egg, or a traditional Zope 2 product.</p>

<h2>Installing eggs<br></h2>

<p>So long as an egg has a release in the <a class="external-link" href="http://pypi.python.org/pypi">PyPi</a>
or elsewhere, buildout can download and install it, including any
explicitly specified dependencies. Simply list the egg, and optionally
a version (otherwise, you get the latest available), in the <em>eggs </em>option.</p>

<pre>[buildout]
...
eggs = 
    elementtree
    borg.project&gt;=1.0b1,&lt;2.0dev</pre>

<p>If you want buildout to search an index other than PyPi's, you can add a URL to <em>find-links</em> that contains download links for the eggs. In fact, we have already seen an example of this: <em>elementtree </em>is found at <em>http://effbot.org/downloads</em>, not in PyPi directly. Thus, we have:</p>

<pre>[buildout]
...

find-links =
    http://dist.plone.org
    http://download.zope.org/ppix/
    http://download.zope.org/distribution/
    http://effbot.org/downloads

eggs =
    elementtree</pre>

<p>We have also listed some of the download locations for Zope and Plone eggs.</p>

<p>Again - re-run buildout for the changes to take effect:</p>

<pre>$ ./bin/buildout</pre>

<h3>Development eggs</h3>

<p>If there is not a release for your egg, or you want to track an egg in Subversion, check it out to the <em>src/</em> directory. Make sure you get the full egg, including the top-level <em>setup.py</em> file. For example, to get the <em>plone.portlets</em> trunk development, egg do:</p>

<pre>$ cd src
$ svn co https://svn.plone.org/svn/plone/plone.portlets/trunk plone.portlets</pre>

<p>Then, add the following to <em>buildout.cfg</em>:</p>

<pre>[buildout]
...
eggs =
    ...
    plone.portlets

develop =
    src/plone.portlets</pre>

<p>Note that:</p>

<ul><li>The <em>develop </em>option contains a relative path to where the source egg is installed. Buildout will expect to find a suitable <em>setup.py</em> in this directory.<br></li><li>Development eggs always take precedence over regular eggs.</li><li>You still need to list the egg name&nbsp; in the <em>eggs</em> option for it to be installed.</li><li>If you are overriding an egg that ships with Plone, you may need to list it in the eggs section of the <em>[plone]</em> part instead:</li></ul><pre>[buildout]
...
develop =
    src/plone.portlets

...

[plone]
recipe = plone.recipe.plone
eggs = 
    plone.portlets</pre>

<p>This is because <em>plone.recipe.plone</em> is very expilcit about which versions of its various eggs to use, to ensure Plone keeps running as it was released.</p>

<p class="callout">Buildout recipes (such as <em>plone.recipe.plone</em>) are distributed as eggs. You can use a development egg of a recipe by listing it under the <em>develop</em> option. There is no need to explicitly list it under the <em>eggs </em>option, since it is referenced by the <em>recipe </em>option of the relevant part.</p>

<h2>Installing a traditional Zope 2 product</h2>

<p>The easiest way to try out a traditional Zope 2 product is to extract it into the <em>products</em>/ folder inside the buildout. If you see documentation referring to the <em>Products/</em> folder in a Zope instance, this is the same thing.</p>

<p>However, this approach makes it harder to redistribute your project

and share it with other developers. It is often more predictable to let

buildout download and install the package for you. You can do this with

the <em>[productdistros]</em> section of <em>buildout.cfg</em>. For example, here is how you might install a product named <em>ExampleProduct</em> and a set of products named <em>ExampleProductBundle</em>:</p>

<pre>[productdistros]
recipe = plone.recipe.distros
urls =
    http://example.com/dist/ExampleProduct-1.0.tgz
    http://example.com/dist/ExampleProductBundle-1.0.tgz
nested-packages =
    ExampleProductBundle-1.0.tgz
version-suffix-packages =</pre>

<p>Note that our fictional <em>ExampleProductBundle</em> is distributed as a single directory containing a number of products in sub-directories, so we list it under <em>nested-packages</em>.</p>

<p>As always, if you change <em>buildout.cfg</em>, you must re-run buildout:</p>

<pre>$ ./bin/buildout</pre>

<h2>Managing ZCML files</h2>

<p>It is important to realize that Zope will not load <em>configure.zcml</em> files automatically for packages that are not in the <em>Products.*</em> namespace and lack support for <em>z3c.autoinclude</em> (see next page for more on using <em>z3c.autoinclude</em>). Instead, you must explicitly reference the package. Buildout can create such a reference (known as a ZCML <strong>slug</strong>) with the <em>zcml </em>option under the <em>[instance]</em> part. Here is how to ensure that <em>borg.project</em> is available to Zope:</p>

<pre>[buildout]
...
eggs =
    elementtree
    borg.project

...

[instance]
...
zcml = 
    borg.project</pre>

<p>Should you need to load an <em>overrides.zcml</em> or a <em>meta.zcml</em>, you can use a syntax like:</p>

<pre>zcml =
    some.package
    some.package-overrides
    some.package-meta</pre>

<h2>Policy products</h2>

<p>Many developers prefer to create a single "policy product" (also
known as a "deployment product") that orchestrates various
dependencies. If you have such a product, you may want to include
various dependencies directly from the policy product's <em>configure.zcml</em> file, with lines such as:</p>

<pre>&lt;configure xmlns="http://namespace.zope.org/zope"&gt;

    &lt;include package="borg.project" /&gt;

&lt;/configure&gt;</pre>

<p>In this case, you may still need one slug (using the <em>zcml </em>option as above) for the policy product.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                1.8.
                Creating a new package
            </h1>

            <p class="documentDescription">Adding a new custom package is not much different from installing a third-party one.</p>
    
            <div>
                
                    <div><h2>Creating a traditional Zope 2 product</h2>

<p>To create a traditional Zope 2 product, put it in the top-level <em>products/</em>

directory and re-start Zope. Nothing more should be required. As

explained previously, products placed here will be found automatically

at start-up, and their <em>configure.zcml</em> files will be executed automatically.</p>

<h2>Creating an egg</h2>

<p>Of course, if you are using products, you cannot benefit from the additional features of eggs, including automatic dependency <br>management, distribution via the Cheese Shop and nested namespaces.</p>

<p>The easiest way to create a new egg is to use the <em>paster </em>command,

which we already used to create the buildout. To create a new basic

package, with a top-level namespace (e.g. your company name) and a

specific name, go to the <em>src/</em> directory and run:</p>

<pre>$ cd src
$ paster create -t plone myorg.mypackage
</pre>

<p>You will be asked a series of questions. Make sure that the

namespace package and package name correspond to the name of the egg.

In this case, the namespace package is <em>myorg </em>and the package name is <em>mypackage</em>. In general, answer <em>False </em>to the question on whether your package if "zip safe". Enter other metadata as requested.</p>

<p>You will now have:</p>

<ul><li>A <em>setup.py</em> which contains the metadata you entered</li><li>A package in <em>myorg.mypackage/myorg/mypackage</em>. Your source code goes here.</li><li>A skeleton <em>configure.zcml</em>, tests.py and a few other useful starting points.</li><li>Some generic documentation in <em>myorg.mypackage/docs</em>.</li></ul><p>Of course, you must also add this package to the buildout. In <em>buildout.cfg</em>, you might have:</p>

<pre>[buildout]
...
eggs =
    ...
    myorg.mypackage

develop =
    src/myorg.mypackage
</pre>

<p>Unless you plan to include this package from another one (or use

automatic ZCML loading, explained below), you probably also need a ZCML

slug:</p>

<pre>[instance]
...
zcml =
    myorg.mypackage
</pre>

<p>Do not forget to re-run buildout after making the change:</p>

<pre>$ ./bin/buildout
</pre>

<h3>Automate ZCML loading for your package<br></h3>

<p>If you're not including your package from another one, you can still avoid having to include a ZCML slug in <em>buildout.cfg</em> for it. This is particulary useful to avoid unneccessary repetition of package names in <em>buildout.cfg</em>,

which begginer integrators might easily overlook. From Plone 3.3 on,

you can make your packages signal that their ZCML should be included by

adding:</p>

<pre class="literal-block">setup(...<br>entry_points="""<br>...<br>[z3c.autoinclude.plugin]<br>target = plone<br>...)<br>"""<br></pre>

<p>to their <em>setup.py</em> file. For further information, see the <a class="external-link" href="http://peak.telecommunity.com/DevCenter/setuptools#dynamic-discovery-of-services-and-plugins">setuptools documentation about dynamic discovery of services and plugins</a>.<a class="toc-backref" name="dynamic-discovery-of-services-and-plugins" href="http://peak.telecommunity.com/DevCenter/setuptools#id19" id="dynamic-discovery-of-services-and-plugins"><br></a></p>

<h3>Specifying dependencies</h3>

<p>If your new package has explicit dependencies, you can list them in <em>setup.py</em>. That way, buildout will be able to download and install these as well. Dependencies are listed in the <em>install_requires</em> argument to the <em>setup()</em> method, By default, <em>setuptools </em>is listed here, since we need this to support namespace packages. To add <em>sqlalchemy </em>0.3 (but not 0.4), and the <em>MySQL-Python</em> driver, you could amend this to read:</p>

<pre>install_requires=[
          'setuptools',
          'sqlalchemy&gt;=0.3,&lt;0.4dev',
          'MySQL-Python',
      ],
</pre>

<h3>Uploading your egg to the Cheese Shop</h3>

<p>If you want to share your packge with the rest of the Python

community and make it easy to install using tools like buildout and <em>easy_install</em>, you can upload the package to the Cheese Shop.</p>

<p>Before doing so, you should:</p>

<ul><li>Commit your latest changes and tag the release in Subversion, if applicable.<br></li><li>Remove (temporarily) the <em>setup.cfg</em> file: this makes your package a development release.<br></li><li>Make sure the version number in <em>setup.py</em> is correct. This

should use common conventions such as "1.0b2" for the second beta of

version 1.0, or "2.1.3rc1" for the first release candidate of version

2.1.3.</li><li>If you are using Mac OS X, run <span class="visualHighlight">export&nbsp;COPY_EXTENDED_ATTRIBUTES_DISABLE=true</span>

on the shell first - otherwise, the egg will contain Mac OS X resource

forks which cause problems if your egg is used on Windows.</li></ul><p>When you are ready, run the following command from your package's directory (e.g. <em>src/myorg.mypackage</em>):</p>

<pre>$ python setup.py egg_info -RDb <strong><span class="code-string">""</span></strong> sdist register upload</pre>

<p>This will ask you to create a Cheese Shop account if you do not have

one already. You can run this command as often as you'd like to release

a new version (probably with a new version number).</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                1.9.
                A deployment configuration
            </h1>

            <p class="documentDescription">How to use buildout for deployment configuration</p>
    
            <div>
                
                    <div><p>Finally, let's take a look at a more advanced configuration, better suited for deployment. Save this file as <em>deployment.cfg</em>, at the root of the buildout next to the main <em>buildout.cfg</em> file:</p>

<pre>[buildout]
extends =
    buildout.cfg

parts +=
    debug-instance
   &nbsp;zeoserver
    varnish-build
    varnish-instance

[zeoserver]
recipe = plone.recipe.zope2zeoserver
zope2-location = ${instance:zope2-location}
zeo-address = ${instance:zeo-address}

[instance]
recipe = plone.recipe.zope2instance
zope2-location = ${zope2:location}
zeo-client = true
zeo-address = 8100
zodb-cache-size = 5000
zeo-client-cache-size = 300MB
debug-mode = off
verbose-security = off
eggs += Products.CacheSetup

[debug-instance]
recipe = collective.recipe.zope2cluster
instance-clone = instance
http-address = 8081
debug-mode = on
verbose-security = on

[varnish-build]
recipe = zc.recipe.cmmi
url = http://downloads.sourceforge.net/varnish/varnish-2.0.2.tar.gz

[varnish-instance]
recipe = plone.recipe.varnish
daemon = ${buildout:parts-directory}/varnish-build/sbin/varnishd
bind = 127.0.0.1:8082
backends = 127.0.0.1:8080
cache-size = 1G
</pre>

<p>Here, we are:</p>

<ul><li>Referencing the main <em>buildout.cfg</em> file, extending and overriding it with configuration more appropriate for deployment.<br></li><li>Setting up a ZEO server with two client instances, instance<em> </em>and <em>debug-instance</em> (see <a href="http://cheeseshop.python.org/pypi/plone.recipe.zope2zeoserver">plone.recipe.zope2zeoserver </a>and <a href="http://cheeseshop.python.org/pypi/plone.recipe.zope2instance">plone.recipe.zope2instance</a> for more details)</li><li>Compiling the Varnish cache server (see <a href="http://cheeseshop.python.org/pypi/plone.recipe.varnish">plone.recipe.varnish</a> for more details).</li></ul><p>By
combining buildout configuration files like this, you can create
tailor-made configurations for different deployment scenarios. To learn
more about the advanced features of buildout, see <a href="http://cheeseshop.python.org/pypi/zc.buildout">its documentation</a>.</p>

<p>To build this environment, you must explicitly specify a configuration file:</p>

<pre>$ ./bin/buildout -c deployment.cfg
</pre>

<p>To start Zope and Plone, you will need to start the ZEO server, the instance and the Varnish server:</p>

<pre>$ ./bin/zeoserver start
$ ./bin/instance start
$ ./bin/varnish-instance
</pre>

<p>If you need to bring up an instance for debugging then you can start up the <em>debug-instance</em> in foreground mode.</p>

<pre>$ ./bin/debug-instance fg
</pre>

<p>The recipes will also create scripts to back up the ZODB filestorage (in <em>./bin/repozo</em>) and to pack the database (in .<em>/bin/zeopack</em>).</p>

<h2>Further options<br></h2>

<p>zc.buildout is a very flexible system. It is relatively easy to
create new recipes, and you can combine existing recipes in powerful
ways. Search the <a href="http://cheeseshop.python.org/pypi?%3Aaction=search&amp;term=buildout&amp;submit=search">Cheese Shop for "buildout"</a> to find more recipes, or take a look at the <a href="http://dev.plone.org/collective/browser/buildout">source code for some of Plone's own recipe</a>s to understand how recipes are created.</p>

<p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                1.10.
                Useful buildout recipes
            </h1>

            <p class="documentDescription">A list of the most common and useful buildout recipes used when working with Plone.</p>
    
            <div>
                
                    <div><p>The list is more or less sorted by topic. Check all available recipes <a class="external-link" href="http://pypi.python.org/pypi?:action=browse&amp;show=all&amp;c=512">at PyPI</a>.</p>

<ul><li><a class="external-link" href="http://pypi.python.org/pypi/zc.recipe.egg/">zc.recipe.egg</a> - Installs eggs into a buildout eggs

directory.  It also generates scripts in a buildout bin directory with

egg paths baked into them.</li><li><a href="http://pypi.python.org/pypi/infrae.subversion/1.4.5">infrae.subversion</a> - This zc.buildout recipe will check out a <em>number</em> of URLs into its

parts directory.  It won't remove its parts directory if there are any

changes in the checkout, so it's safe to work with that checkout for

development.</li><li><a class="external-link" href="http://pypi.python.org/pypi/plone.recipe.zope2install/">plone.recipe.zope2install</a> - Installs Zope 2, i.e. its Python libraries and scripts, but doesn't create any instance.<br></li><li><a class="external-link" href="http://pypi.python.org/pypi/plone.recipe.zope2instance/">plone.recipe.zope2instance</a> - Creates and configures a Zope 2 instance in parts. It also

installs a control script, which is like zopectl, in the bin/ directory.</li><li><a class="external-link" href="http://pypi.python.org/pypi/plone.recipe.zope2zeoserver/">plone.recipe.zope2zeoserver</a> - This recipe creates and configures a Zope 2 ZEO server in parts. It also

installs a control script, which is like zeoctl, in the bin/ directory.</li><li><a class="external-link" href="http://pypi.python.org/pypi/plone.recipe.distros/">plone.recipe.distros</a> -&nbsp; Installs distributions, i.e. Zope products not packaged as eggs.</li><li><a class="external-link" href="http://pypi.python.org/pypi/plone.recipe.apache/">plone.recipe.apache</a> - Builds and configures the Apache web server.</li><li><a href="http://pypi.python.org/pypi/gocept.nginx/0.9.4">gocept.nginx</a> - zc.buildout recipe for configuring an nginx server</li><li><a class="external-link" href="http://pypi.python.org/pypi/plone.recipe.varnish/">plone.recipe.varnish</a> - Installs the Varnish reverse-cache proxy. It works for non-Zope sites as well.</li><li><a class="external-link" href="http://pypi.python.org/pypi/plone.recipe.squid">plone.recipe.squid</a> - Installs the Squid proxy. It works for non-Zope sites as well.</li><li><a class="external-link" href="http://pypi.python.org/pypi/collective.recipe.omelette/">collective.recipe.omelette</a>
- Creates a unified directory structure of all namespace packages,
symlinking to the actual contents, in order to ease navigation.</li><li><a class="external-link" href="http://pypi.python.org/pypi/collective.recipe.i18noverrides/">collective.recipe.i18noverrides</a> - Creates an i18n directory within one or

more Zope 2 instances in your buildout.  It copies some .po files to

those directories.  The translations in those .po files will override

any other translations.</li><li><a class="external-link" href="http://pypi.python.org/pypi/zc.recipe.cmmi/">zc.recipe.cmmi</a> - The Configure-Make-Make-Install recipe automates installation of

configure-based source distribution into buildouts.</li><li><a class="external-link" href="http://pypi.python.org/pypi/plone.recipe.command/">plone.recipe.command</a> - Execute arbitrary commands in buildout through os.system.<br></li></ul></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                1.11.
                Installing products from Subversion
            </h1>

            <p class="documentDescription">Sometimes
Plone products are not eggified, but available only in Subversion
version control repository. This how to tells how such product can be
automatically installed in buildout installations. </p>
    
            <div>
                
                    <div id="parent-fieldname-text" class="kssattr-atfieldname-text kssattr-templateId-widgets/rich kssattr-macro-rich-field-view">

<p>A few buildout recipes provide direct version control checkout functionality:</p>

<ul><li><a href="http://pypi.python.org/pypi/plone.recipe.bundlecheckout">plone.recipe.bundlecheckout</a> - recipe provides Subversion (and CVS) downloads. Always does checkout - not suitable if you change files.</li><li>

<p><a class="external-link" href="http://pypi.python.org/pypi/mr.developer">mr.developer</a> -&nbsp; a <span class="pre">zc.buildout</span> extension which makes it easier to work with

buildouts containing lots of packages of which you only want to develop some.</p>

</li><li><a href="http://pypi.python.org/pypi/infrae.subversion">infrae.subversion</a> - can do SVN update<br></li></ul><p>In this example we use the later.</p>

<h2>Step by step</h2>

<p>Add

the <em>infrae.buildout</em> recipe to your <em>buildout.cfg</em>. Adding a recipe means adding

a new line to [<em>buildout] parts=...myrecipename</em> at the beginning of the

file and then later a corresponding <em>[mypartname] recipe = xxx.yyy</em> section.</p>

<pre>[buildout]

parts =

    plone
    zope2
    productdistros
<strong>    svnproducts</strong>
    instance
    zopepy
    zopeskel</pre>

<p>List all the URLs of the products you want in <em>suvnproducts</em> section. In the example below we checkout TickingMachine product.</p>

<pre># Get TickingMachine directly from SVN since it's not eggified    

[svnproducts]
recipe = infrae.subversion

urls =
    http://tickingmachine.googlecode.com/svn/trunk TickingMachine
</pre>

<p>In the case you're installing an old product (not eggified) you will also need to register it in the <em>[products]</em> section so that they get added to your Python path:</p>

<pre>products =
    ${buildout:directory}/products
    ${productdistros:location}
    ${plone:products}
    ${svnproducts:location</pre>

<p>After rerunning buildout, TickingMachine will be found under parts/development-products folder.</p>

<h2>Further information</h2>

<ul><li><a href="http://danielnouri.org/blog/devel/zope/infrae-subversion.html">infrae.subversion: a recipe against disaster</a></li><li>Note
that pointing to trunk is only a good practice for active development.
Anyone else that needs to use this technique should point to a tag or
branch URL.</li></ul><h2>Certification errors and passwords</h2>

<p>Self-signed

certificates are often used with Subversion repositories. Since <em>infrae.subversion</em> is made for automatization, it cannot accept security

decisions for the user. So if you are receiving certification

validation errors and password prompts,

please access the Subversion repository first manually using svn

command. Accept the choice and the svn client will remember this in

your user account home folder. It is recommended not to use your commit

account for this, since storing passwords is insecure.</p>

<p>Here's an example about how to access a SVN repository using the <em>svn ls</em> command and accepting the security decisions for the svn client to remember them permanently:</p>

<pre> svn ls   https://svn.plone.org/svn/collective/collective.easytemplate/trunk 
Error validating server certificate for 'https://svn.plone.org:443':
 - The certificate is not issued by a trusted authority. Use the
   fingerprint to validate the certificate manually!
Certificate information:
 - Hostname: *.plone.org
 - Valid: from Mon, 14 Jan 2008 08:35:24 GMT until Wed, 13 Jan 2010 08:35:24 GMT
 - Issuer: Plone Foundation, Houston, Texas, US
 - Fingerprint: 39:6e:42:08:44:65:aa:7b:cb:55:85:9a:0c:0c:13:95:16:aa:38:48

(R)eject, accept (t)emporarily or accept (p)ermanently? p

</pre>

</div>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-1">

            <h1>
                2.
                Content-types with Archetypes
            </h1>

            <p class="documentDescription">How to create new content-types in Plone using the Archetypes framework. </p>
    
            

            
                
    
        <div class="referenceManualCollation depth-2">

            <h1>
                2.1.
                Introduction
            </h1>

            <p class="documentDescription"></p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.1.1.
                What is Archetypes?
            </h1>

            <p class="documentDescription">Brief presentation of Archetypes.</p>
    
            <div>
                
                    <div><p>Archetypes is a framework for developing new content types for a

Plone project. Most content management projects involve introducing new

types of content, which in the non-trivial case requires an informed

understanding of how Zope and the CMF work. Archetypes provides a simple,

extensible framework that can ease both the development and maintenance

costs of CMF content types while reducing the learning curve for the

simpler cases.</p><p>Compared to building content types using the stock CMF (through subclassing), Archetypes gives you the following advantages:</p>

<ol class="arabic"><li>automatically generates forms and views;<br></li><li>provides a library of stock field types, form widgets, and field validators;</li><li>allows defining custom fields, widgets, and validators;<br></li><li>automates transformations of rich content;</li><li>a
built-in reference engine that gives the ability to link two objects
together with a relation; such a "link" from a given object to another
one is a Python object called a <i>reference</i>.</li></ol><p>Since
Plone 2.1, Archetypes has become the de-facto way of developing new
content types, and a majority of third party products that are released
these days use Archetypes.<br></p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.1.2.
                Archetypes schemas
            </h1>

            <p class="documentDescription">Introducing Archetypes-based schemas and fields.</p>
    
            <div>
                
                    <div><p>Archetypes
provides a robust framework for storing data attributes on content
objects.&nbsp; This framework consist of a number of <strong>Fields</strong> stored in a container called a <strong>Schema</strong>. Fields are simply specialized Python classes that allow you to store and retrieve data associated with an Archetypes object.</p>

<p>Fields provide a few functionalities. First, there are specialized
field types for strings, lists of strings, integers, floating-point
numbers, etc., that allow special handling of fields based on the type
of data stored.</p>

<h3>Some definitions</h3>

<p>Before we go diving in, let's define some often-used terms:</p>

<ul><li>Field: An Archetypes Field. This refers to an instance of a Field class defined in a Schema.</li><li>Schema: The "container" that Archetypes uses to store fields.</li><li>Schemata: A named grouping of fields. One Schema can have many schematas.</li><li>AT: Abbreviation for Archetypes.<br></li></ul><h3>Fields, Classes, and Objects</h3>

<p>Archetypes Fields are Python objects contained within the Schema. A
Field is defined once for an Archetypes content class. This single
Field instance is used for every instance of that class.&nbsp;
Therefore, the relationship between Field instances and content classes
is described as such: "A field instance belongs to exactly one class."
A class, however, can have many <em>different</em> Field instances. Furthermore, every instance of an AT class uses the <em>same</em> set of Fields.&nbsp; AT objects themselves do not contain unique Fields.</p>

<p>When Zope starts up,

during product initialization, Archetypes reads the schema of the

registered classes and "automagically" generates methods to read (the <em>accessor</em>) and change (the <em>mutator</em>) each of the fields defined.</p>

<h3>Stock schemas</h3>

<p>Archetypes includes three stock schemas:</p>

<ul><li>BaseSchema: defines a normal content type,</li><li>BaseFolderSchema: defines a folderish content type (object can contain

other objects),</li><li>BaseBTreeFolderSchema: for folders which need to handle

hundreds or thousands of objects (even up to millions).</li></ul><p>All three include two

fields, <code>id</code> and <code>title</code>, as well as the

standard Dublin Core metadata fields.</p>

<h3><strong>Modifying the fields of an existing schema<br></strong></h3>

<p>Modifying an existing schema field is possible using the syntax <code>schema['&lt;field_name&gt;'].attribute = value</code>. For example, to change the label of the <em>description</em> field widget (already available in <em>BaseSchema</em>), you can write (<em>in your defined schema definition that reuses BaseSchema</em>):</p>

<pre>schema['description'].widget.label = u'Summary'</pre>

<p>The fields in the schema are ordered, and normally first fields come

first in "add" and "edit" forms. To rearrange a field within the schema

use the <code>moveField</code> method:</p>

<ul><li>Place it before a specific field: <code>schema.moveField('&lt;field_to_move&gt;', before='&lt;field_to_place_it_before&gt;')</code>

</li><li>Place it after a specific field: 

<code>

schema.moveField('&lt;field_to_move&gt;', after='&lt;field_to_place_it_after&gt;')</code></li><li>Place it at the top of the schema: 

<code>

schema.moveField('&lt;field_to_move&gt;', pos='top')</code></li><li>Place it at the bottom: 

<code>

schema.moveField('&lt;field_to_move&gt;', pos='bottom')</code></li><li>Place it in a specific position: 

<code>

schema.moveField('&lt;field_to_move&gt;', pos=0)</code></li></ul><p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.1.3.
                What is ATContentTypes?
            </h1>

            <p class="documentDescription">ATContentTypes is the Plone core product that provides the default content types (since Plone 2.1).</p>
    
            <div>
                
                    <div><p>One
of the major changes introduced in Plone 2.1 was that the core content
types (Page, Image, etc) were changed from being based on stock CMF
types, to using Archetypes. The new core types are housed in the
ATContentTypes product.</p>

<p>ATContentTypes introduces a number of base classes and tools that
provide common "Plone-ish" behaviour. This includes things like support
for the "display" menu and the "more..." menu and restrictions for the
"add item" menu.</p>

<p>You can use ATContentTypes' base classes and tools in your own products. The <a href="http://plone.org/documentation/tutorial/richdocument">RichDocument tutorial</a> covers the core techniques, and is probably a good place to go when you have finished this reference.</p></div>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                2.2.
                A Simple AT Product
            </h1>

            <p class="documentDescription">A semi-realistic example Archetypes-based content type product.</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.2.1.
                Introduction
            </h1>

            <p class="documentDescription">Introducing a sample AT Product and the contents of the tutorial.</p>
    
            <div>
                
                    <div><p>In
this part of the manual, we discuss a sample AT Product to explain
CMF/Archetypes practices. We will be building a product called <strong>example.archetype</strong>,
which will implement a content type (InstantMessage) that members with
specific rights can use to add messages readable by other members.
However, as you may have guessed, this is more a learning example than
a usable product for a real website application.</p>

<p>What is a Product ? A product - a Zope product to be precise - is a
third party add-on that can be integrated to provide additional
functionality. It is a code package written using the Python language
and conventions.</p>

<p>In order to understand this section you will need to have some prior
knowledge of working on the file system and programming protocols
common to Python and Zope.</p>

<p>The <strong>example.archetype</strong> product features the following CMF and Archetypes capabilities:</p>

<ul><li>basic fields and widgets;<br></li></ul><ul><li>defining and using a vocabulary for a field with a selection widget;<br></li></ul><ul><li>defining specific "Add" permissions for the contents.<br></li></ul><p>The code of the product can be downloaded here: <a href="http://plone.org/documentation/products/example.archetype/">http://plone.org/products/example.archetype/</a></p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.2.2.
                Product package layout
            </h1>

            <p class="documentDescription">Conventions and techniques for organizing the package for an AT product.</p>
    
            <div>
                
                    <div><p>Following Zope, Plone and AT's conventions, the content of our example product pakage will look like this:</p>

<pre>- __init__.py
- configure.zcml
- config.py
- interfaces.py
- content
    - __init__.py
    - message.py
- profiles
    - default
- browser
    - __init__.py
    - configure.zcml
    - instantmessage.pt
- tests
    - __init__.py
    - base.py
    - test_setup.py</pre>

<p>What is the purpose of these files and directories?</p>

<ul><li>__init__.py: The usual "Python package" initialization module;</li>

<li>configure.zcml: Using Zope's new Configuration Markup Language
(ZCML), this file configures the services or behaviour the Zope server
needs to load at startup;<br></li>

<li>config.py: Provides configuration variables for the product;</li><li>interfaces.py: Where you define interfaces describing what the packages' classes will do;</li>



<li>content: Contains the modules providing the implementation of the content types.

In this case, it contains the message.py file where the

'InstantMessage' class should be defined;<br></li>

<li>profiles/default:
Contains a set of XML files that are needed to provide the settings
that will be used by Plone's Quick-Installer tool when installing the
product within Plone; this is what we call an <em>Extension Profile</em>, an artifact of Zope CMF's GenericSetup technology. <em>Note that this replaces the old way of doing based on the Extensions/Install</em>. More precisely, since Plone 3.0, you do not need that old-style technique;<br></li><li>browser:
The sub-package where the developer can add specific presentation code
such as browser views and templates; the contained configure.zcml is
used to provide these components registration.<br></li><li>tests: Contains the unit tests code for the product.<br></li></ul><p>If you have ZopeSkel installed, you can use the following command to create a similar structure:</p>

<pre>paster create -t archetype example.archetype</pre>

<p>Now we will go through the files one by one and add what we need to

produce our application.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.2.3.
                The interfaces module
            </h1>

            <p class="documentDescription">The module where you define interfaces describing what your content class(es) will do.</p>
    
            <div>
                
                    <div><h3>Why do you need interfaces?</h3>

<p>Interfaces are useful to describe what a class will do. They are a
kind of contract between a class and the components that class interact
with. Starting a content management functionality package with writing
interfaces is recommended practice as it helps document your code. In
addition to that, Zope Component Architecture (ZCA) allows us to use
interfaces as components for adapting a class (which is useful as new
user requirements appear) and thus specializing its behaviour.</p>

<h3>The interface for the Instant Message class</h3>

<p>This is done by convention in the <code>interfaces.py</code> file, that you need to add at the root of the package.</p>

<p>First, we need an import from Zope's <code>zope.interface</code> module, which is included into Zope 2's distribution since version 2.8:</p>

<pre>    from zope.interface import Interface
</pre>

<p>Following ZCA naming conventions (interface names start with an <em>I</em>), we define the <code>IInstantMessage</code> interface we need for the <code>InstantMessage</code> class that we will define later:</p>

<pre>    class IInstantMessage(Interface):
        """
        Interface for the InstantMessage class.
        """</pre>

<p>That's it!</p>

<p>We could add attribute definitions to it using the <code>zope.interface.Attribute</code>
class, but this is not mandatory. When an interface is defined as
above, without any function nor attribute, we call it a "marker
interface" meaning that it will be used simply to "mark" the instances
of the class that implements it.</p>

<p>More information about interfaces in the context of Archetypes can be found in the <a class="external-link" href="http://plone.org/documentation/manual/tutorial/borg/interfaces">b-org tutorial - Interfaces section</a>. For a detailed presentation of interfaces and their usage patterns, read the <a class="external-link" href="http://docs.zope.org/zope3/Code/zope/interface/README.txt">doctests document available from Zope's documentation site</a>.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.2.4.
                The configuration module
            </h1>

            <p class="documentDescription">The configuration details for your content type, in config.py.</p>
    
            <div>
                
                    <div><p>First, we have to import a class from Archetypes:</p>

<pre>from Products.Archetypes.atapi import DisplayList
</pre>

<p>Displaylist is a data container we use when displaying

pulldowns/radiobuttons/checkmarks with different choices. Let's say we wanted

priorities on our instant messages, and we wanted those to be <code>High</code>, <code>Normal</code>

and <code>Low</code>. We will specify these later in the file.</p>

<p>The next two lines set the project (Product in Zope) name, and point to the

skin directory. <code>PROJECTNAME</code> should reference the name of the package: <code>example.archetype</code>.</p>

<pre>PROJECTNAME = "<code>example.archetype</code>"
</pre>

<p>Now, we need to specify our 'Priority'

pulldown. It should look like this, using the DisplayList utility class that Archetypes has provided for exactly that purpose:</p>

<pre>MESSAGE_PRIORITIES = DisplayList((
    ('high', 'High Priority'),
    ('normal', 'Normal Priority'),
    ('low', 'Low Priority'),
    ))
</pre>

<p class="discreet"><strong>Python notes:</strong></p>

<ul><li>

<p class="discreet">The reason for double parantheses is that DisplayList is a class that

you pass a <em>tuple of tuples</em> to.</p>

</li></ul><p>&nbsp;We also need to define the "Add" permission(s) for the content type(s):</p>

<pre>ADD_CONTENT_PERMISSIONS = {
&nbsp;&nbsp;&nbsp; 'InstantMessage': '<strong>example.archetype: Add InstantMessage</strong>',
 }
</pre>

<p>We recommend using the standard way of naming permissions:

'&lt;ProductName&gt;: &lt;Permission&gt;'. This will group the related

permissions

together within the ZMI (Security tab), and allow the Administrator to

recognize which permissions belong to which Product.</p>

Note that, unless you have an advanced case which needs custom

security settings, you don't need to define your own permissions for

the "edit" and "view" of the content. In this simple case you will just

reuse, in the modules where needed, the generic permissions defined in

CMFCore.permissions: "View", "Modify portal content"...</div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.2.5.
                The startup module
            </h1>

            <p class="documentDescription">The initialization module (__init__.py) provides the script that is run when Zope is started.</p>
    
            <div>
                
                    <div><p>Before
starting the usual Zope product initialization code, we need to define
a Message Factory for when this product is internationalized.</p>

<pre>from zope.i18nmessageid import MessageFactory

exampleMessageFactory = MessageFactory('example.archetype')</pre>

<p>The defined <code>MessageFactory</code> object will be imported with the special name "_" in most modules, and strings like <span class="visualHighlight">_(u"message")</span> will then be extracted by i18n tools for translation.</p>

<p>Now, we import some useful stuff from the Archetypes API:<code>process_types</code> is useful to get the product's <em>content types</em>,

associated <em>constructors,</em> and <em>Factory Type Information</em> (FTI) data structures, while <code>listTypes</code> can be used to list the types available in the product.</p>

<p>We also need to import the <code>utils</code> module from <code>CMFCore</code> to be able to use its <code>ContentInit</code> class later.</p>

<pre>from Products.Archetypes.atapi import process_types
from Products.Archetypes.atapi import listTypes

from Products.CMFCore import utils
</pre>

<p class="discreet"><strong>Python notes:</strong></p>

<ul><li>

<p class="discreet">Factory Type Information (FTI): Part of a CMF
portal's configuration, the FTI for a content type is the data
structure that holds the information needed to expose a content type
within the portal. From the integrator's perspective, the FTI is the
object (Factory-based Type Information object) within the portal_types
component that tells CMF and Plone how to create a content from the
type and how to display it.</p>

</li><li>

<p class="discreet">How exactly does 'listTypes' work: See those
registerType() calls in your content type modules? Notice how we also
import those modules (but do nothing with the import) in the 'content'
package's __init__.py. The registerType() call tells AT about the type
so that listTypes() can find it later.</p>

</li></ul>

One of the important import steps : we import everything that is defined in the content sub-package,

i.e. all its modules:

<pre>from content import message
</pre>
Now, we import the configuration module, in order to have access to the
variables it contains, such as the "Add" permission setting:
<pre>import config
</pre>

<p>Now for the real action. You define a function that is required by Zope and CMF internals to initialize our content type(s):</p>

<pre>def initialize(context):
</pre>

<p>The first part of the code of this function generates the <em>content types</em>, the <em>constructors</em> and the <em>Factory-based Type Informations</em> (or FTIs) required to

make your types work with the CMF:</p>

<pre>    content_types, constructors, ftis = process_types(
        listTypes(config.PROJECTNAME),
        config.PROJECTNAME)
</pre>

<p>The second part instantiates an object of the class ContentInit (from CMFCore),

and registers your types in the CMF:</p>

<pre>    utils.ContentInit(
            "%s Content" % config.PROJECTNAME,
            content_types      = content_types,
            permission         = config.ADD_CONTENT_PERMISSIONS['InstantMessage'],
            extra_constructors = constructors,
            fti                = ftis,
            ).initialize(context)<strong>

</strong></pre>

<p><strong>Handling several content types</strong></p>

<p>There is a better way to write the code that initializes the content

type class with its "Add" permission and constructor, so that it still

works if you define several content types.

This is useful if you plan to later augment your product with

additional types.</p>

<p>Here is the improved code:</p>

<pre>def initialize(context):

    content_types, constructors, ftis = process_types(
             listTypes(config.PROJECTNAME), 
             config.PROJECTNAME)


    <em># We want to register each type with its own permission,

</em>    <em># this will afford us greater control during system

</em>    <em># configuration/deployment (credit : Ben Saller)



</em>    allTypes = zip(content_types, constructors)
    for atype, constructor in allTypes:
        kind = "%s: %s" % (config.PROJECTNAME, atype.portal_type)
        utils.ContentInit(kind,            
                          content_types      = (atype,),
                          permission         = config.ADD_CONTENT_PERMISSIONS[atype.portal_type],
                          extra_constructors = (constructor,),            
                          fti                = ftis,
                          ).initialize(context)</pre>

<p class="discreet"><strong>Python notes:</strong></p>

<ul><li>

<p class="discreet">We can use the

"ADD_CONTENT_PERMISSIONS[atype.portal_type]" construct because

ADD_CONTENT_PERMISSIONS references a dictionary in which the keys are

the potential content types names.</p>

</li><li>

<p class="discreet">The zip() function is a Python built-in that pairs

up elements of two lists. In this case, "allTypes" will be a list of

tuples containing a content type from "content_types" and the

corresponding constructor from "constructors".</p>

</li><li>

<p class="discreet">If you have several content types, you should not
forget to import each content module, as is done for the message
example discussed here !</p>

</li></ul><p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.2.6.
                The content package and its modules
            </h1>

            <p class="documentDescription">Now we are ready for the core of the product, i.e. the content class definition module (content/message.py).</p>
    
            <div>
                
                    <div><p>Since it provides a Python (sub)package, the 'content' directory contains 2 modules:</p>

<ul><li>the usual __init__ module that initializes the package,</li><li>the message module (message.py) where we will define the 'InstantMessage' class.</li></ul><h3>The message module</h3>

<p><strong>First imports we need</strong></p>

<p>We start the message module by adding the general Zope-related imports we need, such as the <code>implements</code> function from the <code>zope.interface</code> module:</p>

<pre>from zope.interface import implements</pre>

<p>We need to use a few classes and/or functions provided by

the core of our codebase, i.e. CMF/Archetypes. It is possible to have access to all the classes and helper functions

made

publicly available by Archetypes, by importing its faÃ§ade or API module (<code>Products.Archetypes.atapi</code>) this way:</p>

<pre>from Products.Archetypes import atapi 
</pre>

<p><strong>i18n support</strong></p>

<p>It is always a good idea to have an i18n-enabled application. To
start using Zope's i18n support, let's import the MessageFactory object
created in the product's startup module:</p>

<pre><strong>from example.archetype import exampleMessageFactory as _</strong></pre>

<p>The MessageFactory referenced with the <code>_</code> symbol can now
be used to provide i18nized labels, descriptions, and all the
miscellaneous text snippets that are injected in the UI, also known as
"messages". For a content type implementation, this is useful for UI
widgets; for example to define the label of the content title field
widget, we could define <code>label = _(u'Title')</code>. (See later for how we make use of this tool/practice.)</p>

<p><strong>ATContentTypes-based schema definition</strong></p>

<p>You can base your implementation directly on these stock Archetypes
schemas. But you can add better support for Plone's UI and content
management policies (such as the parameters that allow showing/hiding
contents in the navigation menu), by basing the implementation on
ATContentTypes' base schema, <code>ATContentTypeSchema</code>. To be compatible with that schema, you will also need to inherit from ATContentTypes' ATCTContent base class.</p>

<p>Let's add the import of modules we need for that:</p>

<pre><strong>from Products.ATContentTypes.content import base

</strong><strong><strong>from Products.ATContentTypes.content import schemata</strong></strong></pre>
Then, we import things internal to our product package, such as our
defined interface(s) and the configuration module (for access to things
such as <code>PROJECTNAME</code> and <code>MESSAGE_PRIORITIES</code>):

<pre>from example.archetype.interfaces import IInstantMessage

from example.archetype import config
</pre>

<p>Now, we have everything we need to start building the schema, and
then the class that will use it. We start out by copying
ATContentTypes' <code>ATContentTypeSchema</code>, and we extend it by adding our specific fields and/or overriden field properties.</p>

<pre>schema = schemata.ATContentTypeSchema.copy() + atapi.Schema((

  atapi.StringField('priority',
              vocabulary = config.MESSAGE_PRIORITIES,
              default = 'normal',
              widget = atapi.SelectionWidget(label = _(u'Priority')),
             ),

  atapi.TextField('body',
            searchable = 1,
            required = 1,
            allowable_content_types = ('text/plain',
                                       'text/structured',
                                       'text/html',),
            default_output_type = 'text/x-html-safe',
            widget = atapi.RichWidget(label = _(u'Message body')),
           ),

))</pre>

<p class="discreet"><strong>Notes:</strong></p>

<ul><li>

<p class="discreet">To instantiate an Archetypes schema object, you pass a tuple of field objects to the 'Schema' class.</p>

</li></ul><p>We define the body of the InstantMessage object using a RichWidget, so the user can use formatting with a WYSIWYG editor.</p>

<p>The full list of out-of-the-box available Fields and Widgets can be found <a class="external-link" name="fields-and-widgets" href="http://plone.org/documentation/manual/developer-manual/archetypes/fields" id="fields-and-widgets">in the Fields section at the end of the manual</a>. You can find more 3rd party fields and widgets <a class="external-link" href="http://plone.org/documentation/search?path=%2Fplone.org%2Fproducts&amp;portal_type=PSCProject&amp;SearchableText=widget&amp;Search=Search">here</a>.</p>

<p><strong>Content-type class definition</strong></p>

<p>The last step is to create the class for the InstantMessage content.

It inherits from ATContentTypes' ATCTContent, which itself is based on AT's BaseContent, which automatically gives its 'id' and

'title' attributes, and the entire Dublin Core metadata set (Title, Description,

Creator, CreationDate, etc):</p>

<pre>class InstantMessage(base.ATCTContent):
    """An Archetype for an InstantMessage application"""

    implements(IInstantMessage)

    schema = schema
</pre>

<p>The first information we add for the class definition is saying that it implements the <code>IInstantMessage</code> interface that we have previously defined (in <code>interfaces.py</code>) and imported.</p>

<pre>    implements(IInstantMessage)</pre>

<p>The next thing is assigning the reference of the Archetypes schema, using the <code>schema</code> class attribute.</p>

<pre>    schema = schema</pre>

<p>The content class definition is done. Now, we are ready to activate the content type in Archetypes'

internal types registry. This is done using the helper function called <code>registerType</code>.</p>

<pre>atapi.registerType(InstantMessage, config.PROJECTNAME)</pre>

<p>Congratulations! You have just created your first Archetype for Plone! It

allows you to handle the content of an instant message with Zope-based

persistent objects which:</p>

<ul><li>can be added within your Plone site,</li><li>published by the Zope Publisher, which means you can visit them via their URLs, etc...</li><li>searched since they are automatically indexed,</li><li>etc...</li></ul><p>But wait! You have some

final packaging work to do to ease installation of the product within

your Plone site.</p>

<p class="discreet"><strong>Notes:</strong></p>

<ul><li>

<p class="discreet">At the content class level, you could also provide the 'actions' attribute

useful for defining the settings of the type's actions (for the

portal_actions tool). In Plone 3, this is no more needed, since this is

part of the FTI's configuration details, and should be provided using

GenericSetup, in the types-related XML files (i.e.

'profiles/default/types/InstantMessage.xml'). <em>Same for

the aliases.</em></p>

</li></ul><h3>The __init__ module</h3>

<p>The trick here is to simply import the message module so that all

the code of that module gets interpreted as soon as the Python

interpreter initializes the package.</p>

<pre>import message</pre>

<p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.2.7.
                Adding a custom view for the content
            </h1>

            <p class="documentDescription">Providing the custom presentation template for the InsantMessage, using Zope's browser layer mechanism.</p>
    
            <div>
                
                    <div><h3>The browser layer concept<br></h3>

<p>A browser layer is a concept introduced by Zope Component
Architecture (Zope 3), and which can be used in Plone. It is useful for
registering views and resources (images, CSS, JS) for the site, in a
way that they can override default elements (which are implicitly
registered for the default browser layer) or be overriden when needed,
even through the ZMI. <em>A browser layer is similar in purpose to a CMF skin layer, but is implemented differently</em>.</p>

<p>To add a browser layer to your product, you need 3 steps:</p>

<ul><li>Define the marker interface for the browser layer (for example, <code>example.archetype.interfaces.IInstantMessageSpecific</code>.)

</li><li>Add an XML file in your extension profile named <code>browserlayer.xml</code> providing the browser layer settings to the site. <em>(This step is covered later as part of the various product setup details.)</em><br></li><li>Register (using ZCML) your browser views, templates and resources.</li></ul>

For more about browser layer techniques, check <a title="Customization for developers" class="internal-link" href="http://plone.org/documentation/manual/tutorial/customization-for-developers">this tutorial</a>.

<h3>Defining the browser layer interface<br></h3>

<p>Add a marker interface for the browser layer (in <code>interfaces.py</code>):</p>

<pre><p>from plone.theme.interfaces import IDefaultPloneLayer



class IInstantMessageSpecific(IDefaultPloneLayer):

&nbsp;&nbsp;&nbsp; """Marker interface that defines a Zope 3 skin layer for this product.

&nbsp;&nbsp;&nbsp; """</p>
</pre>

<h3>Adding and registering the browser template<br></h3>

<p>To provide a custom view template for your content type, you need a page template called

<code>instantmessage.pt</code> in the <code>browser/</code> directory, and a ZCML declaration in the <code>configure.zcml</code> to associate the template to the <code>IInstantMessageSpecific</code> Zope 3 skin layer.</p>

<pre><p>&lt;configure xmlns="http://namespaces.zope.org/zope"

&nbsp;&nbsp;&nbsp; xmlns:browser="http://namespaces.zope.org/browser"

&nbsp;&nbsp;&nbsp; i18n_domain="example.archetype" &gt;

&nbsp;&nbsp;&nbsp; &lt;browser:page

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for="example.archetype.interfaces.IInstantMessage"

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; layer="example.archetype.interfaces.IInstantMessageSpecific"

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name="instantmessage_view"

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; template="instantmessage.pt"

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; permission="zope2.View"

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&gt;

&lt;/configure&gt;</p>
</pre>

<p>Here is the example template code:</p>

<pre>&lt;html metal:use-macro="here/main_template/macros/master"
      i18n:domain="plone" &gt;
&lt;body&gt;

&lt;div metal:fill-slot="main"
     tal:define="priority here/getPriority;
                 priority_color python:(priority == 'high' and 'red') or (priority == 'low' and 'green') or ''" &gt;

        &lt;h1 tal:content="context/Title"
            tal:attributes="style string:color:$priority_color" &gt;
          Title
        &lt;/h1&gt;

        &lt;p tal:content="structure here/getBody" /&gt;          

        &lt;div class="documentByLine"&gt;
          Message by &lt;span tal:content="context/Creator" /&gt; 
          with &lt;strong tal:content="priority" /&gt; priority.
          -
          &lt;span tal:replace="python:here.toLocalizedTime(context.CreationDate(),long_format=1)" /&gt;
        &lt;/div&gt;
    
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</pre>

<p class="discreet"><strong>Python notes:</strong></p>

<ul><li>

<p class="discreet">The new methods we use on the content object

(getPriority, getBody, etc), called the "accessors", are generated by

Archetypes as part of its internal mechanisms, based on the field

definition in the content schema; so if the field is called

'priority', there is a generated method called 'getPriority'

responsible to return the stored value on the object. Note that the

code of the method is not available somewhere for modification ;

"generated" here means it is available in the server's memory, within

Archetypes engine's registries, when the Zope server has started.</p>

</li></ul><p>After the product installation step, which we still have
to discuss (see later), Plone should be able to find this template and
use it as the content object's default view when you invoke the
content's URL.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.2.8.
                Installing the product
            </h1>

            <p class="documentDescription">Ensuring the product elements (types, browser layers, resources) are correctly installed.</p>
    
            <div>
                
                    <div><p>In this part, we will provide the code to be executed when the

integrator "adds", i.e. installs, the InstantMessage product to the

Plone site. This aspect of the product code is called the "Extension

Profile" (or "Setup Profile") and is managed under the hood by a

machinery called GenericSetup.</p>

For more about GenericSetup, its possibilities, and how a developer uses it, read the <a class="external-link" href="http://plone.org/documentation/tutorial/genericsetup">GenericSetup tutorial</a>.

<h3>The setup profile files (profiles/default)</h3>

<p>The setup profile is composed of a set of GenericSetup XML files containing setup declarations.</p>

<p><strong>Type declaration and definition</strong></p>

<p>First, we provide the files needed for adding the types to CMF's types registry (portal_types): <code>types.xml</code> and <code>types/InstantMessage.xml</code>.</p>

<p>In <code>types.xml</code>, within the <code>&lt;object name="portal_types" ... /&gt;</code> element, add the setup code for the type(s) you want to install:</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;object name="portal_types" meta_type="Plone Types Tool"&gt;
 &lt;property
    name="title"&gt;Controls the available content types in your portal&lt;/property&gt;
 &lt;object name="InstantMessage"
    meta_type="Factory-based Type Information with dynamic views"/&gt;
&lt;/object&gt;&nbsp;</pre>

<p>The <em>name</em> property of the <code>&lt;object&gt;</code> node constitutes the called <em>portal type</em> name of the content-type, a CMF concept which supports two things:</p>

<ol><li> Dynamic typing: objects can change their content

        type during their lifetime. To do this use

        <code>_setPortalTypeName(&lt;type&gt;</code><code>)</code>.</li><li> You can have arbitrarily many different content types

        using the same base class (and having therefore the same

        <code>meta_type</code>) but differing in their Factory Type Information (FTI) settings. <br></li></ol><p>The <em>portal type</em> name was formerly set in a content-type class attribute called <em>portal_type</em>, which is no longer necessary.</p>

<p>The name of the file inside the <code>profiles/default/types</code> folder must match the portal type name, with spaces converted to underscores whenever necessary. So, in<code> types/InstantMessage.xml</code>, add the code for the InstantMessage FTI object:</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;object name="InstantMessage"
   meta_type="Factory-based Type Information with dynamic views"
   i18n:domain="example.archetype" xmlns:i18n="http://xml.zope.org/namespaces/i18n"&gt;
  &lt;property name="title" i18n:translate=""&gt;Example AT - InstantMessage&lt;/property&gt;
  &lt;property name="description"
    i18n:translate=""&gt;An example type (InstantMessage) discussed in the AT Developer Manual.&lt;/property&gt;
</pre>

<p>In these first lines we give the content-type a title and a description.</p>

<p>The <em>title</em> property indicates the user-friendly name of the content-type. This is what's supposed to be used in the user

        interface, and can be accessed using the <code>&lt;fti&gt;.title_or_id()</code> or the <code>Type()</code> methods, which

        both return the content-type title if it exists or the content-type id 

otherwise. Like portal type, this property was formerly set in a the content-type class attribute called <code>archetype_name</code>, which is no longer neccessary.</p>

<pre>  &lt;property name="content_meta_type"&gt;InstantMessage&lt;/property&gt;
  &lt;property name="content_icon"&gt;document_icon.gif&lt;/property&gt;
  &lt;property name="product"&gt;example.archetype&lt;/property&gt;
  &lt;property name="factory"&gt;addInstantMessage&lt;/property&gt;
</pre>

<p>The <code>meta_type</code> property of the object is a Zope concept to organize object classification or containment.

        For historical reasons, it is used in

        CMF in some places because first versions of

        CMF didn't have today's <code>portal_type</code>. Also note that Archetypes uses the content-type class name as the meta_type value, unless given explicitly.</p>

<p>The <code>content_icon</code> property specifies the icon image file
which will be shown in the Plone UI for this content-type. This icon
image file must be accessible from the context of the content-type, and
therefore should be placed into a CMF skin layer (the CMF way) or in a
browser resource directory (the Zope 3 way).</p>

<p>The <code>factory</code> property indicates the factory function which

will be used to create and initialize new content objects of this type.

This factory is automatically generated by the Archetypes framework,

when the product is initialized (via the code in the startup module), and is always named <code>add&lt;content-meta-type&gt;</code>. The factory is also associated with a certain product by means of the <code>product</code> property.</p>

<pre>  &lt;property name="immediate_view"&gt;atct_edit&lt;/property&gt;
  &lt;property name="global_allow"&gt;True&lt;/property&gt;
  &lt;property name="filter_content_types"&gt;False&lt;/property&gt;
  &lt;property name="allow_discussion"&gt;False&lt;/property&gt;
</pre>

<p>The <code>global_allow</code> property determines if the content-type will be available to be added from anywhere in the site.</p>

<p>The <code>filter_content_types</code> property, paired with allowed_content_types, controls what content-types will be addable inside the current one.</p>

<p>With <code>allow_discussion</code>, we specify whether or not comments will be allowed by default on this content-type.</p>

<pre>  &lt;property name="default_view"&gt;@@instantmessage_view&lt;/property&gt;
  &lt;property name="view_methods"&gt;
    &lt;element value="@@instantmessage_view" /&gt;
  &lt;/property&gt;
  &lt;alias from="(Default)" to="@@instantmessage_view" /&gt;
  &lt;alias from="edit" to="atct_edit" /&gt;
  &lt;alias from="sharing" to="@@sharing" /&gt;
  &lt;alias from="view" to="@@instantmessage_view" /&gt;
</pre>

<p>Here we define CMF views (templates) and aliases that map content-type methods to views.</p>

<pre>  &lt;action title="View" action_id="view" category="object" condition_expr=""
    url_expr="string:${object_url}/" visible="True"&gt;
    &lt;permission value="View" /&gt;
  &lt;/action&gt;
  &lt;action title="Edit" action_id="edit" category="object" condition_expr=""
    url_expr="string:${object_url}/edit" visible="True"&gt;
    &lt;permission value="Modify portal content" /&gt;
  &lt;/action&gt;
&lt;/object&gt;
</pre>

<p>The <code>&lt;action&gt;</code> elements register type-specific actions for the content-type. The <code>object</code> category makes the render as tabs in the Plone UI.</p>

<ul><li>The <code>url_expr</code> is a <a class="external-link" href="http://plone.org/documentation/tutorial/zpt/advanced-usage">TALES expression</a>

that defines the URL from where the action will be triggered and should

match one of the method aliases defined above. Hence, the <code>edit</code> action points to <code>string:${object_url}/edit</code>, which means that if you are at <code>/path/to/object</code> and click <code>edit</code>, you will go to <code>/path/to/object/edit</code>. <code>/edit</code> then gets recognized as a method alias, which points to the page template <code>atct_edit</code>, causing Zope to render <code>/path/to/object/atct_edit</code>.<br></li><li>The

&lt;permission /&gt; element specifies a guard permission for this

action. If the user's role doesn't have this permission, the action

won't be available and the corresponding action tab won't be shown.<br></li><li>In addition to the former criteria, the <code>condition_expr</code> is a TALES expression which will be evaluated to decide if the action is available or not.</li><li>The <code>visible</code>

attribute indicates wheter the action tab will be visible or hidden. If

it's set to False, the tab won't appear even when the action is

available, but the exposed page will still be accesible from the

associated URL.</li></ul><span class="discreet"><strong>Notes:</strong></span>

<ul><li class="discreet">Defining new content-type actions this way, i.e. using GenericSetup, supersedes the old <code>updateActions</code> function from <code>ATContentTypes.content.base</code>.</li><li class="discreet">Don't worry. You don't have to type all this XML each time

you create a new content-type; since most of it is boilerplate (XML is

very verbose) you can copy &amp; paste an already working example (like

<a class="external-link" href="http://dev.plone.org/plone/browser/CMFPlone/tags/3.1.4/profiles/default/types">the CMFPlone ones</a>) and modify only the changing bits.</li></ul><p><strong>Type factory</strong></p>

<p>We also need the file useful for setting the type against Plone's factory tool (portal_factory): <code>factorytool.xml</code>.

This is needed so that when a user adds a content object and then

clicks Cancel in the edit form, a stale object won't be lying around.)</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;object name="portal_factory" meta_type="Plone Factory Tool"&gt;
 &lt;factorytypes&gt;
  &lt;type portal_type="InstantMessage"/&gt;
 &lt;/factorytypes&gt;
&lt;/object&gt;
</pre>

<p><strong>Roles - Permissions mapping<br></strong></p>

<p>For our content type(s) to be usable, we need to assign the required
"Add" permission to the Plone site's default roles: Contributor, Owner,
and Manager. This is done using the <code>rolemap.xml</code> file as follows:</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;rolemap&gt;
    &lt;permissions&gt;
        &lt;permission name="example.archetype: Add InstantMessage" acquire="True"&gt;
          &lt;role name="Manager"/&gt;
          &lt;role name="Owner"/&gt;
          &lt;role name="Contributor"/&gt;
        &lt;/permission&gt;
    &lt;/permissions&gt;
&lt;/rolemap&gt;
</pre>

<p><strong>Browser skin layer</strong></p>

<p>In order to install our browser skin layer, we also add a <code>browserlayer.xml</code> file with the following code:</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;layers&gt;  
  &lt;layer name="example.archetype"
         interface="example.archetype.interfaces.IInstantMessageSpecific" /&gt;
&lt;/layers&gt;
</pre>

<h3>Registering our setup profile</h3>

<p>This last step ensures everything can work. We update the package's <code>configure.zcml</code> file with the code snippet that will load the extension profile:</p>

<pre>&lt;configure
    xmlns="http://namespaces.zope.org/zope"
    xmlns:five="http://namespaces.zope.org/five"
    <strong>xmlns:genericsetup="http://namespaces.zope.org/genericsetup"</strong>
    i18n_domain="example.archetype" &gt;

   &lt;five:registerPackage package="." initialize=".initialize" /&gt;

   &lt;include package=".browser" /&gt;

<strong>   &lt;genericsetup:registerProfile

      name="default"

      title="Example Archetype content - InstantMessage"

      directory="profiles/default"

      description="Extension profile for Example AT - InstantMessage"

      provides="Products.GenericSetup.interfaces.EXTENSION"

      /&gt;</strong>

&lt;/configure&gt;
</pre>

<h3>Restarting Zope<br></h3>

<p>Now that you have a first version of your product ready to be
tested, and installed via your buildout, you need to (re)start Zope.</p>

<h3>Quick-installing the product<br></h3>

<p>Back in the Plone configuration (or Plone control panel), when you

visit the "Add/Remove Products" interface or the <em>portal_quickinstaller</em>

tool through the ZMI (at the root of the site), you can see the product

show up under the category of "installable products".</p>

<p>Select and click the button to install the product. If everything

goes fine, the product should be installed, and you're ready to start

using it!</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.2.9.
                Basic integration tests
            </h1>

            <p class="documentDescription">No product is complete without tests.</p>
    
            <div>
                
                    <div><p>To build high-quality software, you <em>must</em>
provide automatic tests - often known as "unit" tests (though tests for
Archetypes products tend to be "integration" tests, strictly speaking).</p>

<p>The <a href="http://plone.org/documentation/tutorial/testing">tutorial on testing and test-driven development</a>
is essential reading if you want to write high-quality software (and
you don't know the techniques it advocates already). Please refer to it
for details.</p>

<p>The example.archetype product contains basic tests that prove that
the product is properly installed, that it registers its types, and
that an InstantMessage object can actually be instantiated. If it
contained more functionality, there would have been more tests, but
even simple integration tests like this can be surprisingly useful - if
you accidentally broke the content type with some change, you'd notice
that it failed to install or instantiate.</p>

<p>The tests are in the "tests" directory. The file "base.py" contains
some base classes that are used for tests, to ensure the site is
properly set up:</p>

<pre>import unittest

from zope.testing import doctestunit
from zope.component import testing
from Testing import ZopeTestCase as ztc

from Products.Five import zcml
from Products.Five import fiveconfigure
from Products.PloneTestCase import PloneTestCase as ptc
from Products.PloneTestCase.layer import PloneSite
from Products.PloneTestCase.layer import onsetup

@onsetup
def setup_product():
    """Set up the package and its dependencies.
    
    The @onsetup decorator causes the execution of this body to be deferred
    until the setup of the Plone site testing layer. We could have created our
    own layer, but this is the easiest way for Plone integration tests.
    """
    
    fiveconfigure.debug_mode = True
    import example.archetype
    zcml.load_config('configure.zcml', example.archetype)
    fiveconfigure.debug_mode = False
        
    ztc.installPackage('example.archetype')
    

setup_product()
ptc.setupPloneSite(products=['example.archetype'])


class InstantMessageTestCase(ptc.PloneTestCase):
    """Base class for integration tests.

    This may provide specific set-up and tear-down operations, or provide
    convenience methods.
    """
</pre>

<p>The actual tests are in "test_setup.py":</p>

<pre>from base import InstantMessageTestCase
from example.archetype.interfaces import IInstantMessage

class TestProductInstall(InstantMessageTestCase):

    def afterSetUp(self):
        self.types = ('InstantMessage',)

    def testTypesInstalled(self):
        for t in self.types:
            self.failUnless(t in self.portal.portal_types.objectIds(),
                            '%s content type not installed' % t)

    def testPortalFactoryEnabled(self):
        for t in self.types:
            self.failUnless(t in self.portal.portal_factory.getFactoryTypes().keys(),
                            '%s content type not installed' % t)

class TestInstantiation(InstantMessageTestCase):

    def afterSetUp(self):
        # Adding an InstantMessage anywhere - can only be done by a Manager or Portal Owner
        self.setRoles(['Manager'])
        self.portal.invokeFactory('InstantMessage', 'im1')

    def testCreateInstantMessage(self):
        self.failUnless('im1' in self.portal.objectIds())

    def testInstantMessageInterface(self):
        im = self.portal.im1
        self.failUnless(IInstantMessage.providedBy(im))

def test_suite():
    from unittest import TestSuite, makeSuite
    suite = TestSuite()
    suite.addTest(makeSuite(TestProductInstall))
    suite.addTest(makeSuite(TestInstantiation))
    return suite
</pre>

<p>To run these tests within your buildout environment:</p>

<pre>./bin/instance test -s example.archetype</pre>

<p>You may see output like:</p>

<pre> Ran 4 tests with 0 failures and 0 errors in 0.119 seconds.
</pre>

<p>If there was an error with one or more of the tests, you'd be told here!</p>

<p>Please refer to the <a href="http://plone.org/documentation/tutorial/testing">testing tutorial</a> for more about writing tests - and writing <em>good</em> tests - and how to run them.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.2.10.
                Troubleshooting
            </h1>

            <p class="documentDescription">When
creating new content types, many factors can silently fail due to human
errors in the complex content type setup chain and security
limitations. The effect is that you don't see your content type in Add
drop down menu. Here are some tips for debugging.</p>
    
            <div>
                
                    <p>1.
Is your product broken due to Python import time errors? Check the
*Zope Management Interface (ZMI from now on) â Control Panel â
Products*. Turn on Zope debugging mode to trace import errors. To see
error messages directly in the console with buildout, use *bin/instance
fg*.
<br><br>2. Have you rerun the quick installer (GenericSetup) after
creating/modifying the content type? If not, (re)install the product
from the *Plone Control Panel â Add-on Products* or from the *ZMI â
portal_quickinstaller*.
<br><br>3. Do you have a correct Add permission for the product? Check
the call of the ``ContentInit()`` method inside the *__init__.py* file.
See `The startup module
&lt;http://plone.org/documentation/manual/archetypes-developer-manual/a-semi-realistic-example/the-startup-module&gt;`_.
<br><br>4. Does it show up in the portal factory? Check *ZMI â portal_factory* and *factorytool.xml*. 
<br><br>5. Is it correctly registered as a portal type and implictly
addable? Check *ZMI â portal_types*. Check
*default/profiles/type/yourtype.xml*.
<br><br>6. Does it have a correct product name defined? Check *ZMI â portal_types*.
<br><br>7. Does it have a proper factory method? Check *ZMI â types_tool*. Check Zope logs for ``_queryFactory`` and import errors.
<br><br>8. Does it register itself with Archetypes? Check *ZMI â
archetypes_tool*. Make sure that you have ``ContentInit`` properly run
in your *__init__.py*. Make sure that all modules having Archetypes
content types defined and ``registerType()`` calls are imported in
*__init__py*.</p>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                2.3.
                Fields
            </h1>

            <p class="documentDescription">Fields for Archetypes</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.3.1.
                Fields Reference
            </h1>

            <p class="documentDescription">Attributes of standard Archetypes fields.</p>
    
            <div>
                
                    <div>







<table class="listing" align="center"><tbody><tr><th colspan="3">

<h2>Topics</h2>

</th></tr><tr><td>

<p><a title="Common Field Attributes" href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/fields-reference#common-field-attributes">Common Field Attributes</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/fields-reference#boolean_field">BooleanField</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/fields-reference#computed_field">ComputedField</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/fields-reference#cmf_object_field">CMFObjectField</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/fields-reference#datetime_field">DateTimeField</a></p>

</td><td>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/fields-reference#file_field">FileField</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/fields-reference#fixedpoint_field">FixedPointField</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/fields-reference#float_field">FloatField</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/fields-reference#image_field">ImageField</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/fields-reference#integer_field">IntegerField</a></p>

</td><td>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/fields-reference#lines_field">LinesField</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/fields-reference#reference_field">ReferenceField</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/fields-reference#string_field">StringField</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/fields-reference#text_field">TextField</a></p>

<p>&nbsp;</p>

</td></tr></tbody></table><p>&nbsp;</p>

<ul></ul><h2 id="common_attributes"><a name="common-field-attributes" id="common-field-attributes"></a>Common Field Attributes</h2>

<p>These attributes are common to nearly all fields. Field-specific attributes follow,

and are listed by field. Particular fields have different defaults, types, and some 

other specialized attributes.</p>

















































































































































































































<table class="listing"><thead><tr><th>Name</th><th>Description</th><th>Possible Values</th><th>Default</th></tr></thead><tbody><tr><td>accessor</td><td>The name of a class method that will return the value of the field. Use this to

change how the field is retrieved. If you don't provide a custom method 

name here, a default accessor, named getYourFieldName, is going to be created 

that just returns the value of the Field.<br></td><td>A class method name; for example, <em>specialGetMethod</em></td><td>None</td></tr><tr><td>default <br></td><td>The default value for the field. <br></td><td>Type should be appropriate to the field.<br></td><td>None</td></tr><tr><td>default_method <br></td><td>The name of a class method returning a value for the field.</td><td>A class method name; for example, <em>getSpecialDescription</em>. <br></td><td>None</td></tr><tr><td>edit_accessor</td><td>The name of a class method that returns the raw value of a field.</td><td>Any method name (for example, <em>rawGetMethod</em>). <br></td><td>None</td></tr><tr><td>enforceVocabulary</td><td>Determines whether or not values outside the vocabulary will be accepted.

If True, Archetypes will validate input for the field against the vocabulary.

Only values already in the vocabulary will be accepted.<br></td><td><em>True</em> or <em>False</em>. <br></td><td>False</td></tr><tr><td>index<br>(Plone &lt; 3 only)<br></td><td>If you want this field to be placed in its own catalog index, then specify the type of index here as a string. If you append <em>:schema</em>
onto the end of the schema, then this will also be added as a metadata
column. (The actual index will be on the field accessor, typically
"getFieldName".)<br>Ignored in Plone 3+; use GenericSetup profile for similar functionality.<br></td><td>The name of any index, such as <em>KeywordIndex</em> or <em>KeywordIndex:schema</em>.<br></td><td>None</td></tr><tr><td>index_method</td><td>May be used to specify the method called when indexing a field.

Use '_at_accessor' to use the default accessor, '_at_edit_accessor' to use the

edit accessor, or the name of a method returning the value to be indexed.</td><td><em>_at_accessor</em>, <em>_at_edit_accessor, getIndexAccessor</em> and <em>getIndexAccessorName</em><br></td><td>_at_accessor</td></tr><tr><td>languageIndependent<br></td><td>Flag for Fields that are independent of the language, such as dates.

True

tells LinguaPlone that no translation is necessary for this field.</td><td><em>True</em> or <em>False</em></td><td>False</td></tr><tr><td>isMetadata <br></td><td>Marks metadata fields. This is currently only needed as a convenience for 

the filterFields method of Schema. 

Fields marked as metadata are not displayed in the uncustomized base view.</td><td><em>True</em> or <em>False</em></td><td>False</td></tr><tr><td>mode<br></td><td>The read/write mode of field, as a string; the default is to be read and write.

Accessors will not be created without the read mode, and Mutators will not be created without the write mode.<br></td><td>For read only: <em>r</em>, for write only: <em>w</em>, for read and write: <em>rw</em>. <br></td><td>rw</td></tr><tr><td>multiValued <br></td><td>Set this to True if the field can have multiple values.

This is the case for fields like multiple-selection lists that allow the 

selection of multiple values.</td><td><em>True</em> or <em>False</em>. <br></td><td>False</td></tr><tr><td>mutator <br></td><td>The string name of a class method that changes the value of the Field.

If you don't provide a special method name here, a default mutator is generated

with the name 'setYourFieldName' to simply store the value.</td><td>A class method name; for example, <em>specialSetMethod</em>.  <br></td><td>None</td></tr><tr><td>name</td><td>A unique name for this field.

Usually specified as the first item in the field definition.

<br></td><td>Any string. Strongly recommended: lowercase, no punctuation or spaces,

conforming to standard Python identifier rules.

For example, <em>description</em>, <em>user_name</em>, or <em>coffee_bag_6</em>. <br></td><td>No default.</td></tr><tr><td>primary</td><td>If True, this will be the field that used for 

File Transfer Protocol (FTP) and WebDAV requests. 

There can be only field that does this; if multiple are defined, 

the first one in the schema will be used.

You normally set this for the main body attribute. 

Only used for TextField and FileField field types.</td><td><em>True</em> or <em>False</em></td><td>False</td></tr><tr><td>read_permission<br></td><td>The permission required for the current user to allowed to view or access

the field. Only

useful if the read mode is activated. This read permission is

checked when rendering the widget in read mode.</td><td>A permission identifier imported from Products.CMFCore.permissions</td><td>View</td></tr><tr><td>required <br></td><td>Specifies that some value for this field required.</td><td><em>True</em> or <em>False</em>.</td><td>False</td></tr><tr><td>schemata<br></td><td>Use named schematas to organize fields into grouped views.</td><td>A short string that labels the group.<br></td><td>default</td></tr><tr><td>searchable <br></td><td>Specifies whether or not the field value will be indexed as part of the SearchableText

for the content object. <em>SearchableText</em> is what is checked by the portal's main search.</td><td><em>True</em> or <em>False</em>.</td><td>False</td></tr><tr><td>storage<br></td><td>The storage mechanism for the field. The default is <em>Attribute Storage</em>, 

which stores the field as an attribute of the object.</td><td>Any valid storage object such as <em>AttributeStorage</em> or <em>SQLStorage</em>. 

You can find these in the Archetypes Application Programming Interface (API).<br></td><td>AttributeStorage</td></tr><tr><td>type<br></td><td>Provided by the field class..

Should never be changed in a Schema.</td><td>None<br></td><td>None</td></tr><tr><td>validators<br></td><td>A list or tuple of strings naming validators that will check field input.

If you only have one validator, you may specify it as a string.<br>

Validators may also be instances of a class implementing the IValidator interface 

from from Products.validation.interfaces.IValidator. Providing a class instance 

allows you more flexibility as you may set additional parameters.<br>

Validators are checked in order specified.</td><td>The names of validators registered via Products.validation; for example, isEmail.</td><td>()</td></tr><tr><td>vocabulary <br></td><td>

Provides the values shown in selection and multi-selection inputs.

This may be specified as a static list or as the name of a class method returning

the choice list.<br></td><td>

A list of strings (in which case keys and values will be the same);

a list of 2-tuples of strings [("key1","value 1"),("key 2","value 2"),...];

a Products.Archetypes.utils.DisplayList.

Or, the name of a class method returning any of the above.</td><td>()</td></tr><tr><td>vocabulary_factory</td><td>Like the vocabulary attribute, in Plone 3 provides the values shown in selection and multi-selection inputs.</td><td>

A string name of a Zope 3 style vocabulary factory (a named utility providing zope.schema.interfaces.IVocabularyFactory)</td><td>None</td></tr><tr><td>widget</td><td>The widget that will be used to render the field for viewing and editing.

See the widget reference for a list of available widgets. <br></td><td>An instance of a widget; for example, StringWidget(). <br></td><td>StringWidget()</td></tr><tr><td>write_permission<br></td><td>The permission required for the current user to edit the field value.

Only interesting if the write mode is activated.

The write permission is checked when rendering the widget in write mode.</td><td>A permission identifier imported from Products.CMFCore.permissions</td><td>ModifyPortalContent</td></tr></tbody></table><h2>Standard Fields</h2>

<p>&nbsp;</p>

<h3 id="boolean_field">BooleanField</h3>

<p>Simple storage of <em>True</em> or <em>False</em> for a field.</p>

<strong>Standard properties</strong>









































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th>example values</th></tr></thead><tbody><tr class="odd"><td>widget</td><td>widget</td><td>BooleanWidget</td><td>

Implemented as a check box.</td><td>

<ul><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#LabelWidget">LabelWidget</a>

</li><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#BooleanWidget">BooleanWidget</a></li></ul></td></tr><tr class="even"><td>default</td><td>boolean</td><td>False</td><td>

<br></td><td> <br></td></tr><tr class="odd"><td>type</td><td><br></td><td>

boolean</td><td>

<br></td><td> <br></td></tr></tbody></table><p><strong>Note:</strong> The <em>required</em> attribute for the boolean field is often confusing.

It does <em>not</em> require that the box be checked. Use a validator if you need to require

the box be checked.</p>

<h3 id="computed_field">ComputedField</h3>

<p>Read-only field, whose content cannot be edited directly by users, but is 

computed instead from a Python expression. For example, it can be the result of 

an operation on the contents from some other fields in the same schema, 

e.g. calculating the sum of two or more currency amounts, or composing a 

full name from first name and surname.<br>

This field is usually not stored in the database, because its content is 

calculated on the fly when the object is viewed.</p>

<strong>Standard</strong><strong> properties</strong>



















































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>description</th><th>some possible values<br></th></tr></thead><tbody><tr class="odd"><td>widget</td><td>widget</td><td>

ComputedWidget</td><td><br></td><td>

<ul><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#LabelWidget">LabelWidget</a>

</li><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#ComputedWidget">ComputedWidget</a></li></ul></td></tr><tr class="even"><td>storage</td><td>storage</td><td>

ReadOnlyStorage</td><td><br></td><td> <br></td></tr><tr class="odd"><td>type</td><td><br></td><td>

computed</td><td><br></td><td> <br></td></tr><tr class="even"><td>mode</td><td>string</td><td>

r</td><td><br></td><td> <br></td></tr></tbody></table><strong>Special properties</strong>





















<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th> some possible values<br></th></tr></thead><tbody><tr class="odd"><td>expression</td><td><br></td><td>

<br></td><td>

Evaluated on the object to compute a value.</td><td> <br></td></tr></tbody></table><p>&nbsp;</p>

<h3 id="cmf_object_field">CMFObjectField</h3>

<p>Used for storing values inside a CMF Object, which can have workflow. Can only be used for BaseFolder-based content objects.</p>

<strong>Standard</strong><strong> properties</strong>









































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>description</th><th>some possible values<br></th></tr></thead><tbody><tr class="odd"><td>widget</td><td>widget</td><td>

FileWidget</td><td><br></td><td>

<ul><li><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#LabelWidget">LabelWidget</a></li><li><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#FileWidget">FileWidget</a><br></li></ul></td></tr><tr class="even"><td>storage</td><td>storage</td><td>

ObjectManagedStorage</td><td><br></td><td> <br></td></tr><tr class="odd"><td>type</td><td><br></td><td>

object</td><td><br></td><td> <br></td></tr></tbody></table><strong>Special properties</strong>









































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th>some possible values <br></th></tr></thead><tbody><tr class="odd"><td>portal_type</td><td><br></td><td>

File</td><td>

<br></td><td> <br></td></tr><tr class="even"><td>workflowable</td><td><br></td><td>

True</td><td>

<br></td><td> <br></td></tr><tr class="odd"><td>default_mime_type</td><td><br></td><td>

application/octet-stream</td><td>

<br></td><td> <br></td></tr></tbody></table><h3 id="datetime_field">DateTimeField</h3>

<p>Used for storing dates and times.</p>

<strong>Standard</strong><strong> properties</strong>









































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th>some possible values</th></tr></thead><tbody><tr class="odd"><td>widget</td><td>widget</td><td>

CalendarWidget</td><td>

<br></td><td>

<ul><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#LabelWidget">LabelWidget</a>

</li><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#CalendarWidget">CalendarWidget</a>

</li></ul></td></tr><tr class="even"><td>default</td><td>DateTime</td><td>

<br></td><td>

<br></td><td> <br></td></tr><tr class="odd"><td>type</td><td><br></td><td>

datetime</td><td>

<br></td><td> <br></td></tr></tbody></table><p><strong>Note:</strong> The default for the DateTimeField needs to be specified

as a DateTime object. If you need to set the current date/time as the default,

you'll need to use the default_method attribute to specify a class method

returning the current date/time as a DateTime object.</p>

<p>Example:</p>

<pre>from DateTime.DateTime import DateTime

...

# inside the schema definiton
&nbsp;&nbsp;&nbsp; DateTimeField('dateAdded',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; searchable = 1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; required = 0,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>default_method = 'getDefaultTime',</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; widget = CalendarWidget(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; label = 'Date Added'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ),
&nbsp;&nbsp;&nbsp; ),

...

#inside the content class definition
    def getDefaultTime(self):  # function to return the current date and time
        return DateTime()</pre>

<h3 id="file_field"><br></h3>

<h3 id="file_field"><a name="filefield" id="filefield"></a>FileField</h3>

<p>Storage for large chunks of data such as plain-text files,
office-automation documents, and so on. If you're using Plone 4 or
newer, consider using <em>plone.app.blob.field.BlobField</em> instead, that stores the file data outside of the ZODB and accepts the same parameters as <em>atapi.FileField</em>.&nbsp;See&nbsp;<a class="external-link" href="http://http//plone.org/documentation/manual/upgrade-guide/version/upgrading-plone-3-x-to-4.0/updating-add-on-products-for-plone-4.0/use-plone.app.blob-based-blob-storage">this page</a>&nbsp;for info about migration.</p>

<strong>Standard</strong><strong> properties</strong>









































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th>some possible values <br></th></tr></thead><tbody><tr class="odd"><td>widget</td><td>widget</td><td>

FileWidget</td><td><br></td><td>

<ul><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#FileWidget">FileWidget</a>

</li><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#LabelWidget">LabelWidget</a>

</li></ul></td></tr><tr class="even"><td>default</td><td>string</td><td>

<br></td><td>

<br></td><td> <br></td></tr><tr class="odd"><td>type</td><td><br></td><td>

file</td><td>

<br></td><td> <br></td></tr></tbody></table><strong>Special properties</strong>









































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th>some possible values <br></th></tr></thead><tbody><tr class="odd"><td>primary</td><td><br></td><td>

False</td><td>

<br></td><td> <br></td></tr><tr class="even"><td>default_content_type</td><td><br></td><td>

application/octet</td><td>

<br></td><td> <br></td></tr><tr class="odd"><td>primary</td><td>boolean</td><td>

False</td><td>Set this <em>True</em> to mark the field as primary for FTP or WebDAV.</td><td><br></td></tr></tbody></table><p><strong>Note:</strong> File field values are stored as strings. It's a common

practice to use streams to read/write the values as if they were files.</p>

<p>&nbsp;</p>

<h3 id="fixedpoint_field">FixedPointField</h3>

<p>For storing numerical data with fixed points.</p>

<strong>Standard</strong><strong> properties</strong>



















































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th> some possible values</th></tr></thead><tbody><tr class="odd"><td>widget</td><td>widget</td><td>

DecimalWidget</td><td><br></td><td>

<ul><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#LabelWidget">LabelWidget</a></li><li><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#DecimalWidget">DecimalWidget</a></li></ul></td></tr><tr class="even"><td>validators</td><td>validators</td><td>

isDecimal</td><td>

<br></td><td> <br></td></tr><tr class="odd"><td>default</td><td>string</td><td>

0.00</td><td>

<br></td><td> <br></td></tr><tr class="even"><td>type</td><td><br></td><td>

fixedpoint</td><td>

<br></td><td> <br></td></tr></tbody></table><strong>Special properties</strong>





















<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th>some possible values <br></th></tr></thead><tbody><tr class="odd"><td>precision</td><td><br></td><td>

2</td><td>

<br></td><td> <br></td></tr></tbody></table><p>&nbsp;</p>

<h3 id="float_field">FloatField</h3>

<p>For storing numerical data with floating points.</p>

<strong>Standard</strong><strong> properties</strong>































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th>some possible values <br></th></tr></thead><tbody><tr class="odd"><td>default</td><td>string</td><td>0.0</td><td><br></td><td> <br></td></tr><tr class="even"><td>type</td><td><br></td><td>float</td><td>

<br></td><td> <br></td></tr></tbody></table><p>&nbsp;</p>

<h3 id="image_field"><a name="imagefield" id="imagefield"></a>ImageField</h3>

<p>Stores an image and allows dynamic resizing of the image. If you're using Plone 4 or newer, consider using <em>plone.app.blob.field.ImageField</em> instead, that stores the image data outside of the ZODB, and accepts the same parameters as <em>atapi.ImageField</em>. See <a class="external-link" href="http://http//plone.org/documentation/manual/upgrade-guide/version/upgrading-plone-3-x-to-4.0/updating-add-on-products-for-plone-4.0/use-plone.app.blob-based-blob-storage">this page</a> for info about migration.</p>

<strong>Standard</strong><strong> properties</strong>



















































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th> some possible values</th></tr></thead><tbody><tr class="odd"><td>widget</td><td>widget</td><td>

ImageWidget</td><td><br></td><td>

<ul><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#ImageWidget">ImageWidget</a>

</li><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#LabelWidget">LabelWidget</a>

</li></ul></td></tr><tr class="even"><td>default</td><td>string</td><td>

<br></td><td>

<br></td><td> <br></td></tr><tr class="odd"><td>type</td><td><br></td><td>

image</td><td>

<br></td><td> <br></td></tr><tr class="even"><td>allowable_content_types</td><td>tuple of MIME strings</td><td>

Specifies the types of images that will be allowed.</td><td>

('image/gif','image/jpeg','image/png')</td><td>

('image/jpeg','image/png')</td></tr></tbody></table><p><strong>Note:</strong>&nbsp;Archetypes Image field values are stored as strings. It's a common

practice to use streams to read/write the values as if they were files.</p>

<strong>Special properties</strong>



















































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th>some possible values <br></th></tr></thead><tbody><tr class="odd"><td>original_size</td><td>tuple (w,h)</td><td>

None</td><td>

The size to which the original image will be scaled. If it's None,

then no scaling will take place; the original size will be retained. Caution:

the aspect ratio of the image may be changed.</td><td>(640,480)</td></tr><tr class="even"><td>max_size</td><td>tuple (w,h)</td><td>

None</td><td>

If specified then the image is scaled to be no bigger than either of the given 

values of width or height. Aspect ratio is preserved. Useful to prevent storage 

of megabytes of unnecessary image data.</td><td>(1024,768)</td></tr><tr class="odd"><td>sizes</td><td>dict</td><td>

{'thumb':(80,80)}</td><td>
A dictionary specifying any additional scales in which the image will
be available. Dictionary entries
should be of the form 'scaleName':(width,height). The scaled versions
will be accessible as object/&lt;imagename&gt;_&lt;scalename&gt;, e.g.
object/image_mini.<br></td><td>{ 'mini' : (80,80),

    'normal' : (200,200),

    'big' : (300,300),

    'maxi' : (500,500)}</td></tr><tr class="even"><td>pil_quality</td><td>integer</td><td>

88</td><td>

A JPEG quality setting (range 0 to 100). Lower numbers yield high compression 

and low image quality. High numbers yield low compression and better quality.</td><td>50 (a medium quality)</td></tr></tbody></table><h4>Using Image Scales</h4>

<p>
To display the original image (possibly rescaled if you used
original_size or max_size attributes), you may use a URL like
"http://url_of_content_object/imageFieldName" as the SRC attribute of
an IMG tag where <em>url_of_content_object</em> is the

URL of the content object and <em>imageFieldName</em> is the name

of the image field.</p>

<p>

To display one of the scales, use a URL like "http://url_of_content_object/imageFieldName_scale",<br>

where <em>scale</em> is one of the keys of the <em>sizes</em> dictionary.</p>

<p><em>Attention</em>: The direct attribute access as shown above works
only together with AttributeStorage, which will be used by default. To
avoid heavy memory consumption on sites with many images it is
recommended to use AnnotationStorage for the ImageField.</p>

<p>You may also generate a ready-to-insert IMG tag with the python code:</p>

<pre>obj.getField('image').tag(obj, scale='mini')</pre>

<p>

if <em>obj</em> is your content object, <em>image</em> the name of your image 

field, and <em>mini</em> the name of your scale.</p>

<p>You may rescale to other sizes than those in the sizes field attribute with code

like:</p>

<pre>obj.getField('image').tag(obj, height=480, width=640, alt='alt text',
            css_class='css_class_selector', title='html title attribute')</pre>

<p>From Plone 4 on, the plone.app.imaging package introduces a new way
to control image scales, factoring this functionality out of Archetypes
for reutilization. For example:</p>

<pre>&lt;img tal:define="scales context/@@images;
                 thumbnail python: scales.scale('image', width=64, height=64);"
     tal:condition="thumbnail"
     tal:attributes="src thumbnail/url;
                     width thumbnail/width;
                     height thumbnail/height" /&gt;</pre>

<p>Would create an up to 64 by 64 pixel scaled down version of the
image stored in the "image" field of the context. For further info,
check the <a class="external-link" href="http://dev.plone.org/plone/browser/plone.app.imaging/trunk/README.txt">plone.app.imaging README file</a>.</p>

<h3 id="integer_field">IntegerField</h3>

<p> For storing numerical data as integers.</p>

<strong>Standard</strong><strong> properties</strong>









































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th>some possible values <br></th></tr></thead><tbody><tr class="odd"><td>widget</td><td>widget</td><td>

IntegerWidget</td><td><br></td><td>

<ul><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#LabelWidget">LabelWidget</a>

</li><li>

IntegerWidget

</li></ul></td></tr><tr class="even"><td>default</td><td>integer</td><td>

0</td><td>

<br></td><td> <br></td></tr><tr class="odd"><td>type</td><td><br></td><td>

integer</td><td>

<br></td><td> <br></td></tr></tbody></table><strong>Special properties</strong>





















<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th> some possible values</th></tr></thead><tbody><tr class="odd"><td>size</td><td><br></td><td>

10</td><td>

Sets the size of the input field.</td><td> <br></td></tr></tbody></table><p>&nbsp;</p>

<h3 id="lines_field">LinesField</h3>

<p>Used for storing text as a list, for example a list of data such as keywords.</p>

<strong>Standard</strong><strong> properties</strong>









































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th>some possible values <br></th></tr></thead><tbody><tr class="odd"><td>widget</td><td>widget</td><td>

LinesWidget</td><td><br></td><td>

<ul><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#KeywordWidget">KeywordWidget</a>

</li><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#LinesWidget">LinesWidget</a>

</li><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#LabelWidget">LabelWidget</a>

</li><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#MultiSelectionWidget">MultiSelectionWidget</a>

</li><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#PicklistWidget">PicklistWidget</a>

</li><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#InAndOutWidget">InAndOutWidget</a>

</li></ul></td></tr><tr class="even"><td>default</td><td>string</td><td>

()</td><td>

<br></td><td> <br></td></tr><tr class="odd"><td>type</td><td><br></td><td>

lines</td><td>

<br></td><td> <br></td></tr></tbody></table><p>&nbsp;</p>

<h3 id="reference_field">ReferenceField</h3>

<p>Used for storing references to other Archetypes Objects.</p>

<strong>Standard properties</strong>



















































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th>some possible values <br></th></tr></thead><tbody><tr class="odd"><td>widget</td><td>widget</td><td>

ReferenceWidget</td><td><br></td><td>

<ul><ul><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#ReferenceWidget">ReferenceWidget</a>

</li></ul><ul><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#ReferenceBrowserWidget">ReferenceBrowserWidget</a>

</li>

<li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#LabelWidget">LabelWidget</a>

</li><li>

<a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#InAndOutWidget">InAndOutWidget</a>

</li></ul></ul></td></tr><tr class="even"><td>index_method</td><td><br></td><td>

_at_edit_accessor</td><td>

<br></td><td> <br></td></tr><tr class="odd"><td>type</td><td><br></td><td>

reference</td><td>

<br></td><td> <br></td></tr><tr class="event"><td>multiValued</td><td>boolean</td><td>

False</td><td>

Set multiValued True to allow multiple references (one-to-many), or False to

allow only a single reference (one-to-one).</td><td> <br></td></tr></tbody></table><strong>Special properties</strong>





























































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th>some possible values <br></th></tr></thead><tbody><tr class="odd"><td>relationship</td><td><br></td><td>

<br></td><td>

Specifes an identifier for the type of relationships associated with the field.

This should be unique within your content type, but has no larger meaning.

A ReferenceField allows you to edit the set of references with a 

particular relationship identifier from the current content object to other objects.</td><td>'KnowsAbout', 'Owns', 'WorksWith'</td></tr><tr class="odd"><td>allowed_types</td><td>tuple of portal types</td><td>

()</td><td>

Determines all the portal types that will be searched to find objects that the

user can make a reference to. It also specifies the Types that should

be allowed to be added directly from the reference widget. This is only

activated if the addable property is set. An empty list or tuple will allow references

to all portal types.</td><td>('Document', 'File')</td></tr><tr class="even"><td>allowed_types_method</td><td>string</td><td>

None</td><td>

A string containing the name of a class method that will return a list

of portal types to which references are allowed.</td><td> <br></td></tr><tr class="even"><td>vocabulary_display_path_bound</td><td>integer</td><td>

5</td><td>

Sets a limit for presentation of reference items. Up to this limit, only titles

are displayed. Above the limit, the path to the referenced object is also displayed.

The idea is that if there are a large number of referenced items, the user will 

need help to differentiate them.</td><td> <br></td></tr><tr class="odd"><td>vocabulary_custom_label</td><td>string</td><td>

None</td><td>

A string containing a python expression that will be evaluated to get the

displayed text for a referenced item. Your expression may use the variable "b" which

will be a reference to the catalog brain returned by the reference lookup.</td><td>"b.getObject().title_or_id()"</td></tr></tbody></table><p>&nbsp;</p>

<strong>More about References</strong>

<p>Archetypes References work with any object providing the

IReferenceable interface. They are mantained in the uid_catalog and

reference_catalog catalogs. You can find both at the root of your Plone

site. Check them to see their indexes and metadata.</p>

<p>Althought you could use the ZCatalogs API to manage Archetypes

references, these catalogs are rarely used directly. A ReferenceField

and its API is used instead.</p>

<p>To set a reference, you can use the setter method with either a

list of UIDs or one UID string, or one object or a list of objects (in

the case the ReferenceField is multi-valued) to which you want to add a

reference to. Note that <em>Non</em>e and <em>[]</em> are equal.<br>For example, to set a reference from the <em>myct1</em> object to the <em>areferenceableobjec</em>t object using the <em>MyReferenceField</em> field:</p>

<pre>&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; myct1.setMyReferenceField(areferenceableobject)</pre>

<p>To get the referenced object(s), just use the getter method. Note that what you get are<br>the objects themselves, not their catalog brains.</p>

<pre>&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; myct1.getMyReferenceField()</pre>

<h3 id="string_field"><br></h3>

<h3 id="string_field">StringField</h3>

<p>A field for plain-text, unformatted strings.</p>

<strong>Standard</strong><strong> properties</strong>









































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th>some possible values</th></tr></thead><tbody><tr class="odd"><td>default</td><td>string</td><td>

<br></td><td>



<br></td><td> <br></td></tr><tr class="even"><td>type</td><td><br></td><td>

string</td><td>

<br></td><td> <br></td></tr><tr class="odd"><td>widget</td><td>widget</td><td>

StringWidget</td><td>

<br></td><td>

<ul><li><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#LabelWidget">LabelWidget</a></li>

<li><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#StringWidget">StringWidget</a></li><li><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#SelectionWidget">SelectionWidget</a><br></li></ul></td></tr></tbody></table><strong>Special properties</strong>





















<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th>some possible values</th></tr></thead><tbody><tr class="odd"><td>default_content_type</td><td>string MIME type</td><td>

text/plain</td><td>

<br></td><td>Rarely changed.</td></tr></tbody></table><p>&nbsp;</p>

<h3 id="text_field">TextField</h3>

<p>A string field typically used for longer, multi-line strings.

The string may also be transformed into alternative formats.</p>

<strong>Standard</strong><strong> properties</strong>









































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th>some possible values</th></tr></thead><tbody><tr class="odd"><td>default</td><td>string</td><td>

<br></td><td>

<br></td><td> <br></td></tr><tr class="even"><td>type</td><td><br></td><td>

text</td><td>

<br></td><td> <br></td></tr><tr class="odd"><td>widget</td><td>widget</td><td>

StringWidget</td><td>

<br></td><td>

<ul><li><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#LabelWidget">LabelWidget</a></li>

<li><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#TextAreaWidget">TextAreaWidget</a></li>

<li><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#RichWidget">RichWidget</a></li></ul></td></tr></tbody></table><strong>Special properties</strong>



















































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th><th>some possible values</th></tr></thead><tbody><tr class="odd"><td>primary</td><td>boolean</td><td>

False</td><td>

Set this <em>True</em> to mark the field as primary for FTP or WebDAV.

<br></td><td> <br></td></tr><tr class="even"><td>default_content_type</td><td>string MIME type</td><td>

text/plain</td><td>

A string designating MIME the default input type for the field.</td><td>text/plain, text/html</td></tr><tr class="even"><td>allowable_content_types</td><td>tuple of MIME-type strings</td><td>

('text/plain',)</td><td>

Used in the TextArea and Rich widgets to let the user choose between

different text formats in which the content is entered.</td><td>('text/plain', 'text/html',)</td></tr><tr class="odd"><td>default_output_type</td><td>string MIME type</td><td>

text/plain</td><td>

This is used by the accessor (get) method to and decides which MIME-Type the

content should be transformed into if no special MIME-Type is demanded.</td><td>'text/html', 'text/x-html-safe'</td></tr></tbody></table><p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.3.2.
                Widgets Reference
            </h1>

            <p class="documentDescription">This page is a syntax reference and general guide for defining and using Widgets.</p>
    
            <div>
                
                    <div>







<table class="listing"><thead><tr><th colspan="3" align="center">

<h3>Widget Attribute Topics<br></h3>

</th></tr></thead><tbody><tr><td>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#common_attributes">Common Widget Attributes</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#BooleanWidget">BooleanWidget</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#CalendarWidget">CalendarWidget</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#ComputedWidget">ComputedWidget</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#DecimalWidget">DecimalWidget</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#FileWidget">FileWidget</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#ImageWidget">ImageWidget</a></p>

</td><td>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#InAndOutWidget">InAndOutWidget</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#IntegerWidget">IntegerWidget</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#KeywordWidget">KeywordWidget</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#LabelWidget">LabelWidget</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#LinesWidget">LinesWidget</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#MultiSelectionWidget">MultiSelectionWidget</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#PasswordWidget">PasswordWidget</a></p>

</td><td>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#PicklistWidget">PicklistWidget</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#ReferenceWidget">ReferenceWidget</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#ReferenceBrowserWidget">ReferenceBrowserWidget</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#RichWidget">RichWidget</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#SelectionWidget">SelectionWidget</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#StringWidget">StringWidget</a></p>

<p><a href="http://plone.org/documentation/manual/developer-manual/archetypes/fields/widgets-reference#TextAreaWidget">TextAreaWidget</a></p>

</td></tr></tbody></table><h2 id="common_attributes">Common Widget Attributes</h2>

<p>The table below describes attributes common to nearly all widgets. Illustrations 

and special attributes listings for each of the standard widgets follows.</p>



































































<table class="listing"><thead><tr><th>Name</th><th>Description</th><th>Possible Values</th></tr></thead><tbody><tr><td>condition <br></td><td>A string containing a TALES expression to determine whether or not a field/widget is 

included on a view or edit page.

This does not distinguish between view and edit mode.<br></td><td>Your TALES expression may referenc the current context as 'object' and the Plone site root as 'portal'<br></td></tr><tr><td>description <br></td><td>Help or explanatory text for the field. Usually shown on the edit form under the label and above the input field.</td><td><br></td></tr><tr><td>description_msgid</td><td>The
i18n identifier for the description message. Used to translate the
message. Should be unique within your product's i18n domain.</td><td>'help_type_field'</td></tr><tr><td>label</td><td>The label that will appear in the field.</td><td> Any string, for example, <em>Start Date</em> for a field <em>start_date</em>. Also <em>label_msgid</em> (takes string message ids for i18n.)</td></tr><tr><td>label_msgid</td><td>The i18n identifier for the label message. Should be unique within your product's i18n domain.</td><td>'label_type_field'</td></tr><tr><td>i18n_domain</td><td>The
i18n domain specifier for your product. This should be unique for your
product, and will be used to find the translation catalogs for your
product.</td><td>'productname'</td></tr><tr><td> modes</td><td> The modes that this widget will be shown in; by default there are two modes: view and edit.</td><td> A list of modes as strings; by default <em>("view", "edit")</em>.</td></tr><tr><td> populate</td><td>
If this is enabled, the view and edit fields will be populated. Usually
this is enabled, but for fields such as a password field, this
shouldn't
be the case. Usually this is true by default.</td><td> <em>True</em> or <em>False</em></td></tr><tr><td> postback</td><td> If this is enabled, then when an error is raised, the field is

repopulated; for fields such as a password field, this shouldn't be the

case. Usually this is True by default.</td><td> <em>True</em> or <em>False</em></td></tr><tr><td> visible</td><td> Determines whether or not the field is visible view and edit mode.

This is a

dictionary mapping the view mode to a string describing the

visibility.

Choices are <em>visible</em>, <em>hidden</em> (rendered in an HTML hidden form value), <em>invisible</em> (not rendered at all).</td><td>For example, <em>{'view': 'visible', 'edit': 'hidden' }</em> means that the view will show, but the edit page will hide the value.</td></tr></tbody></table><p>&nbsp;</p>

<h2>Standard Widgets</h2>

<p>&nbsp;</p>

<h3 id="BooleanWidget">BooleanWidget</h3>

<p>Renders an HTML checkbox, from which users can choose between two values such as on/off, true/false, yes/no.</p>

<blockquote>

<p><img src="developer-manual_archivos/booleanwidget.png" alt="booleanwidget.png" height="39" width="369">&nbsp;</p>

</blockquote>

<h3 id="CalendarWidget">CalendarWidget</h3>

<p>Renders a HTML input box with a helper popup box for choosing dates.</p>

<blockquote>

<p><img src="developer-manual_archivos/datetimewidget.png" alt="datetimewidget.png" height="216" width="375"></p>

</blockquote>

<h4>Special Properties</h4>

















































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>format</td><td>string</td><td>

<br></td><td>Defines the date/time format using strftime, e.g. '%d.%m.%Y', for the view.

(See the strftime section of the <a href="http://docs.python.org/lib/module-time.html">Python time documentation</a>.

<br>

If this is not specified, the long form of the portal's local time format is used.</td></tr><tr class="even"><td>future_years</td><td>integer</td><td>

5</td><td>Specifies the number of future years offered by the year drop-down portion 

of the date widget. Do not use both future_year and end_year.

(Plone 2.5+)</td></tr><tr class="odd"><td>starting_year</td><td>integer</td><td>1999</td><td>The first year offered by the year drop-down. (Plone 2.5+)</td></tr><tr class="even"><td>ending_year</td><td>integer</td><td>

None</td><td>The final year offered by the year drop-down.

Do not use both future_years and end_year. (Plone 2.5+)</td></tr><tr class="even"><td>show_hm</td><td>boolean</td><td>True</td><td>Should the widget ask for a time as well as a date? (Plone 2.5+)</td></tr></tbody></table><p>&nbsp;</p>

<h3 id="ComputedWidget">ComputedWidget</h3>

<p>Generally used for ComputedField field type, it renders the computed value.

Note that if your field has a vocabulary, and the field value is a key in that

vocabulary, the widget will lookup the key in the vocabulary and show the result.</p>

<h4>Standard Properties</h4>

















<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>modes</td><td>tuple</td><td>

('view', 'edit')</td><td>As ComputedField is a read-only field, this property can be used to prevent 

the widget from appearing in edit templates, by setting it to just ('view',).</td></tr></tbody></table><p>&nbsp;</p>

<h3 id="DecimalWidget">DecimalWidget</h3>

<p>In edit mode, renders an HTML text input box which accepts a fixed point value.</p>

<h4>Special Properties</h4>

















































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>thousands_commas</td><td>boolean</td><td>False</td><td>In view mode, formats the value to shows commas for thousands.

For example, when thousands_commas is True, "7632654849635.02" is displayed as "7,632,654,849,635.02".

(Note: this feature is not localized; it uses commas independent of locale.</td></tr><tr class="even"><td>whole_dollars</td><td>boolean</td><td>

False</td><td>Shows whole dollars in view, leaving out the cents. Enter "1.123", and "$1" is shown.

(Note: this feature is not localized; it uses the dollar sign independent of locale.)</td></tr><tr class="odd"><td>maxlength</td><td><br></td><td>

255</td><td>Maximum input size; sets the HTML input tag's maxlength attribute.</td></tr><tr class="even"><td>dollars_and_cents</td><td>boolean</td><td>False</td><td>In view mode, shows dollars and cents. Enter "123.123" and "$123.12" is shown.

(Note: this feature is not localized; it always uses the dollar sign, period, 

and two digits precision.)</td></tr><tr class="odd"><td>size</td><td><br></td><td>5</td><td>Size of the input field; sets the HTML input tag's size attribute.</td></tr></tbody></table><p>&nbsp;</p>

<h3 id="FileWidget">FileWidget</h3>

<p>Renders an HTML widget so a user can upload a file.</p>

<blockquote>

<p><img src="developer-manual_archivos/filewidget.png" alt="filewidget.png" height="137" width="263"></p>

</blockquote>

<p>&nbsp;</p>

<h3 id="ImageWidget">ImageWidget</h3>

<p>Renders an HTML widget that can be used to upload, display, delete, and 

replace images. You can provide a <em>display_threshold</em> that allows

you to set the size of an image; if it's below this

size, the image will display in the Web page.</p>

<blockquote>

<p><img src="developer-manual_archivos/imagewidget.png" alt="imagewidget.png" height="269" width="265"></p>

</blockquote>

<p>&nbsp;</p>

<h4>Special Properties</h4>

















<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>display_threshold</td><td>integer</td><td>102400</td><td>Only display the image inline if img.getSize() &lt;= display_threshold</td></tr></tbody></table><p>&nbsp;</p>

<h3 id="InAndOutWidget">InAndOutWidget</h3>

<p>In edit mode, renders a widget for moving items from one list to another.

Items are removed from the source list.

This can be used to choose multiple values from a list. This provides a good 

alternative to the MultiSelectionWidget when the vocabulary is too long for checkboxes.</p>

<blockquote>

<p><img src="developer-manual_archivos/inandoutwidget.png" alt="inandoutwidget.png" height="149" width="376"></p>

</blockquote>

<p>&nbsp;</p>

<h4>Special Properties</h4>

<p>&nbsp;</p>

<h3 id="IntegerWidget">IntegerWidget</h3>

<p>A simple HTML input box for a string.</p>

<h4>Special Properties</h4>

















<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr class="even"><td>size</td><td><br></td><td>

6</td><td>Size of the select widget; sets the HTML select tag's size attribute.</td></tr></tbody></table>























<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>maxlength</td><td><br></td><td>

255</td><td>Maximum input size; sets the HTML input tag's maxlength attribute</td></tr><tr class="even"><td>size</td><td><br></td><td>5</td><td>Size of the input field; sets the HTML input tag's size attribute.</td></tr></tbody></table><p>&nbsp;</p>

<h3 id="KeywordWidget">KeywordWidget</h3>

<p>

This widget allows the user to select keywords or categories from a list. It is 

used for the <em>Categories</em> field in the Categorization Schema (Plone 3+) 

or the equivalent <em>Keywords</em> field on the Properties Tab (Plone &lt; 3)

of a content object.<br>

Keywords are drawn from the field vocabulary and/or the unique values for the 

field in a specified catalog.<br>

Additional keywords may be added unless the enforceVocabulary property of the 

field is True.</p>

<h4>Special Properties</h4>

























<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>vocab_source</td><td><br></td><td>

portal_catalog</td><td>Sets

the catalog to search for additional vocabulary to be combined with the

vocabulary defined for the field. Additional keywords from existing content are

found using catalog.uniqueValuesFor(fieldName).</td></tr><tr class="even"><td>roleBasedAdd</td><td><br></td><td>True</td><td>Only

shows the "New keywords" input for adding keywords if the current user

has one of the roles stored in the allowRolesToAddKeywords property in

the site_properties property sheet in portal_properties</td></tr></tbody></table><p>&nbsp;</p>

<h3 id="LabelWidget">LabelWidget</h3>

<p>Used to display labels on forms -- without values or form input elements.</p>

<p>&nbsp;</p>

<h3 id="LinesWidget">LinesWidget</h3>

<p>Displays a text area so that users can enter a list of values, one per line.</p>

<blockquote>

<p><img src="developer-manual_archivos/lineswidget.png" alt="lineswidget.png" height="113" width="367"></p>

</blockquote>

<p>&nbsp;</p>

<h4>Special Properties</h4>

























<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>rows</td><td>integer</td><td>

5</td><td>Rows of the lines widget; sets the HTML textarea tag's rows attribute.</td></tr><tr class="even"><td>cols</td><td>integer</td><td>

40</td><td>Columns of the lines widget; sets the HTML textarea tag's cols attribute.</td></tr></tbody></table><p>&nbsp;</p>

<h3 id="MultiSelectionWidget">MultiSelectionWidget</h3>

<p>A selection widget; by default it's an

HTML select widget which can be used to choose multiple values. As a

checkbox users can choose one or more values from a list (useful if the

list is short).</p>

<blockquote>

<p><img src="developer-manual_archivos/multiselectionwidget-listbox.png" alt="multiselectionwidget-listbox.png" height="122" width="330"></p>

</blockquote>

<p>&nbsp;</p>

<blockquote>

<p><img src="developer-manual_archivos/multiselectionwidget-checkbox.png" alt="multiselectionwidget-checkbox.png" height="177" width="374"></p>

</blockquote>

<p>&nbsp;</p>

<h4>Special Properties</h4>

























<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>format</td><td>string</td><td>select</td><td>Possible values: 'select' or 'checkbox'. Uses a either a series of checkboxes or 

a multi-selection list. Note that checkboxes have much better usability for short

vocabularies. Consider using the InAndOutWidget for longer vocabularies.</td></tr><tr class="even"><td>size</td><td><br></td><td>

5</td><td>Defines the size of the multi-select list. Does not apply for checkboxes.</td></tr></tbody></table><p>&nbsp;</p>

<h3 id="PasswordWidget">PasswordWidget</h3>

<p>Renders an HTML password input.</p>

<h4>Special Properties</h4>

























<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>maxlength</td><td><br></td><td>

255</td><td>Maximum input size; sets the HTML input tag's maxlength attribute.</td></tr><tr class="even"><td>size</td><td><br></td><td>20</td><td>Size of the input field; sets the HTML input tag's size attribute.</td></tr></tbody></table><h4>Standard Properties</h4>

























<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th></tr></thead><tbody><tr class="odd"><td>populate</td><td>boolean</td><td>False</td></tr><tr class="even"><td>postback</td><td>boolean</td><td>False</td></tr><tr class="odd"><td>modes</td><td><br></td><td>('edit',)</td></tr></tbody></table><p>&nbsp;</p>

<h3 id="PicklistWidget">PicklistWidget</h3>

<p>Similar to the InAndOutWidget, but the values stay in the source list after 

selection.</p>

<blockquote>

<p><img src="developer-manual_archivos/picklistwidget.png" alt="picklistwidget.png" height="155" width="368"></p>

</blockquote>

<p>&nbsp;</p>

<h4>Special Properties</h4>

















<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>size</td><td>integer</td><td>6</td><td>Size of the selection box; sets the HTML select tag's size attribute.</td></tr></tbody></table><p>&nbsp;</p>

<h3 id="ReferenceWidget">ReferenceWidget</h3>

<p>Renders an HTML text input box which accepts a list of possible reference

 values. Used in combination with the Reference Field.<br><strong>Note:</strong> In Plone 2.5 and above, the ReferenceBrowserWidget is 

 a usually a better choice for a reference widget due to its ability to browse for content

 referenceable objects.</p>

<blockquote>

<p><img src="developer-manual_archivos/referencewidget.png" alt="referencewidget.png" height="110" width="381"></p>

</blockquote>

<p>&nbsp;</p>

<h4>Special Properties</h4>









































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>checkbox_bound</td><td><br></td><td>5</td><td>When the number of items exceeds this value, multi-selection lists are used. Otherwise, radio buttons or checkboxes are used.</td></tr><tr class="even"><td>destination</td><td><br></td><td>None</td><td>May be:

<ul><li>".", context object;</li><li>None, any place where Field.allowed_types can be added;</li><li>string path;</li><li>name of method on instance (it can be a combination list);</li><li>a list, combining all item above;</li><li>a dict, where {portal_type:} destination is relative to portal root</li></ul></td></tr><tr class="odd"><td>addable</td><td><br></td><td>False</td><td>Create createObject link for every addable type</td></tr><tr class="even"><td>destination_types</td><td><br></td><td>None</td><td>Either

a single type given as a string, or a list of types given as a string,

defining what types we allow adding to. Only applies when addable is

set on the widget.</td></tr></tbody></table><p>&nbsp;</p>

<h3 id="ReferenceBrowserWidget">ReferenceBrowserWidget</h3>

<p>A sophisticated widget for browsing, adding and deleting references.<br>Standard in Plone 2.5+, available for earlier versions as an add-on product.<br>Import from&nbsp;<em>Products.ATReferenceBrowserWidget.ATReferenceBrowserWidget</em>&nbsp;in Plone 2.5 and 3. In Plone 4, this widget has been improved and now lives in<em>archetypes.referencebrowserwidget.ReferenceBrowserWidget</em>.<strong><strong></strong></strong></p>

<blockquote>

<p><img src="developer-manual_archivos/referencebrowserwidget.png" alt="" height="468" width="386"></p>

</blockquote>

<h4>Special Properties</h4>

























































































































































<table style="text-align: left;" class="listing"><thead><tr><th style="text-align: left;">Name</th><th style="text-align: left;">Type</th><th style="text-align: left;">Default</th><th style="text-align: left;">Description</th></tr></thead><tbody><tr class="odd"><td>size</td><td>integer</td><td><br></td><td>Size of the field if not multiValued; sets the HTML input tag's size attribute.</td></tr><tr class="even"><td>default_search_index</td><td>string</td><td>SearchableText</td><td>when a user searches in the popup, this index is used by default</td></tr><tr class="odd"><td>show_indexes</td><td>boolean</td><td>False</td><td>If
True, a drop-down list is shown in the popup to select the index used
for searching. If set to False, default_search_index will be used.</td></tr><tr class="odd"><td>available_indexes</td><td>dict</td><td>{}</td><td>Optional
dictionary containing all the indexes that can be used for searching
along with their friendly names. Format: {'catalogindex':'Friendly Name
of Index', ... } The friendly names are shown in the widget.<br><strong>Caution:</strong>&nbsp;If you set show_indexes True, but do not use this property to specify indexes, then all the indexes will be shown.</td></tr><tr class="even"><td>allow_search</td><td>boolean</td><td>True</td><td>If True, a search form is included in the popup.</td></tr><tr class="odd"><td>allow_browse</td><td>True</td><td>Allows the user to browse content to find referenceable content.</td><td><br></td></tr><tr class="even"><td>startup_directory</td><td>string</td><td>''</td><td>Directory
shown when the popup opens. Optional. When empty, the current folder is
used. See the ATReferenceBrowser readme.txt for advanced usage.</td></tr><tr class="odd"><td>base_query</td><td>dict or name of method</td><td><br></td><td>Defines
query terms that will apply to all searches, mainly useful to create
specific restrictions when allow_browse=0. Can be either a dictonary
with query parameters, or the name of a method or callable available in
cotext that will return such a dictionary.</td></tr><tr class="even"><td>force_close_on_insert</td><td>boolean</td><td>False</td><td>If true, closes the popup when the user choses insert. This overrides the default behavior in multiselect mode.</td></tr><tr class="odd"><td>search_catalog</td><td>string</td><td>'portal_catalog'</td><td>Specifies the catalog used for searches</td></tr><tr class="even"><td>allow_sorting</td><td>boolean</td><td>False</td><td>Allows changing the order of referenced objects (requires multiValued).</td></tr><tr class="odd"><td>show_review_state</td><td>boolean</td><td>False</td><td>If True, popup will display the workflow state for objects.</td></tr><tr class="even"><td>show_path</td><td>boolean</td><td>False</td><td>If True, display the relative path (relative to the portal object) of referenced objects.</td></tr><tr class="odd"><td>only_for_review_states</td><td><br></td><td>None</td><td>If
set, content items are only referenceable if their workflow state
matches one of the specified states. If None there will be no filtering
by workflow state.</td></tr><tr class="even"><td>image_portal_types</td><td>sequence</td><td>()</td><td>Use to specify a list of image portal_types. Instances of these portal types are previewed within the popup widget</td></tr><tr class="odd"><td>image_method</td><td>string</td><td>None</td><td>Specifies
the name of a method that is added to the image URL to preview the
image in a particular resolution (e.g. 'mini' for thumbnails).</td></tr><tr class="even"><td>history_length</td><td>integer</td><td>0</td><td>If not zero, enables a history feature that show the paths of the last N visited folders.</td></tr><tr class="odd"><td>restrict_browsing_to_startup_directory</td><td>boolean</td><td>False</td><td>If True, the user will not be able to browse above the starting directory.</td></tr></tbody></table><p>The cited Plone 4 implementation of this widget includes the following additional properties:</p>

<h4>Special Properties</h4>

























































<table style="text-align: left;" class="listing"><thead><tr><th style="text-align: left;">Name</th><th style="text-align: left;">Type</th><th style="text-align: left;">Default</th><th style="text-align: left;">Description</th></tr></thead><tbody><tr class="odd"><td>startup_directory_method</td><td>string</td><td>''<br></td><td>The
name of a method or variable that, if available at the instance, will
be used to obtain the path of the startup directory. If present,
'startup_directory' will be ignored.</td></tr><tr><td valign="top">show_results_without_query</td><td valign="top">bool<br></td><td valign="top">False<br></td><td valign="top">Don't ignore empty queries, but display results.</td></tr><tr><td valign="top">hide_inaccessible</td><td valign="top">bool<br></td><td valign="top">False<br></td><td valign="top">Don't show inaccessible objects (no permission) in view mode.</td></tr><tr><td valign="top">popup_width</td><td valign="top">integer<br></td><td valign="top">500<br></td><td valign="top">Width of popup window in pixels.</td></tr><tr><td valign="top">popup_height</td><td valign="top">integer<br></td><td valign="top">550<br></td><td valign="top">Height of popup window in pixels</td></tr><tr><td valign="top">popup_name</td><td valign="top">string<br></td><td valign="top">'popup'<br></td><td valign="top">Name of template to be used for popup. To use another template you have to register a named adapter for this template.</td></tr></tbody></table><p id="RichWidget">Example of registering a popup in ZCML:</p>

<pre id="RichWidget">&lt;zope:adapter<br>    for="Products.Five.BrowserView"<br>    factory=".view.default_popup_template"<br>    name="popup"<br>    provides="zope.formlib.namedtemplate.INamedTemplate" /&gt;<br></pre>

<h3 id="ReferenceBrowserWidget">RichWidget</h3>

<p>Allows the input of text, or upload of a file, in multiple formats

that are then transformed as necessary for display.

For example, allows you to type some content, choose formatting and/or upload a file.

If available, the visual editor set in personal preferences is used for editing

and formatting.</p>

<blockquote>

<p><img src="developer-manual_archivos/richwidget.png" alt="richwidget.png" height="245" width="376"></p>

</blockquote>

<p>&nbsp;</p>

<h4>Special Properties</h4>

































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>rows</td><td>integer</td><td>5</td><td>Number of rows. (Since the visual mode of the RichWidget is controlled by JavaScript,

this is not very useful.)</td></tr><tr class="odd"><td>cols</td><td>integer</td><td>40</td><td>Number of columns. (Since the visual mode of the RichWidget is controlled by JavaScript,

this is not very useful.)</td></tr><tr class="even"><td>allow_file_upload</td><td>boolean</td><td>True</td><td>If True, a file upload option is included with the field.</td></tr></tbody></table><p>&nbsp;</p>

<h3 id="SelectionWidget">SelectionWidget</h3>

<p>Renders an HTML selection widget, which can be represented as a dropdown, or as a group of radio buttons.</p>

<blockquote>

<p><img src="developer-manual_archivos/selectionwidget-dropdown.png" alt="selectionwidget-dropdown.png" height="56" width="201"></p>

</blockquote>

<p>&nbsp;</p>

<blockquote>

<p><img src="developer-manual_archivos/selectionwidget-radio.png" alt="selectionwidget-radio.png" height="150" width="383"></p>

</blockquote>

<p>&nbsp;</p>

<h4>Special Properties</h4>

















<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>format</td><td>string</td><td>'flex'</td><td>Possible

values: 'flex', 'select', 'radio'. Uses radio buttons when set to radio, and

a single-selection list when set to select. Using flex will

automatically use single-selection lists for more than three settings

at a time, and a single-select list for up to three settings.</td></tr></tbody></table><p>&nbsp;</p>

<h3 id="StringWidget">StringWidget</h3>

<p>Renders an HTML text input box which accepts a single line of text. For simple text lines such as author.</p>

<blockquote>

<p><img src="developer-manual_archivos/stringwidget.png" alt="stringwidget.png" height="58" width="233"></p>

</blockquote>

<p>&nbsp;</p>

<strong>Special Properties</strong>

























<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>maxlength</td><td>integer</td><td>255</td><td>Maximum input length in characters; sets the HTML input tag's maxlength attribute.</td></tr><tr class="even"><td>size</td><td><br></td><td>30</td><td>Size of the input widget; sets the HTML input tag's size attribute.</td></tr></tbody></table><p>&nbsp;</p>

<h3 id="TextAreaWidget">TextAreaWidget</h3>

<p>Renders an HTML text area for typing a few lines of text. Also provides for the entry of

the content in multiple formats when <em>allowed_content_types</em> in the enclosing TextField allows it.</p>

<blockquote>

<p><img src="developer-manual_archivos/textareawidget.png" alt="textareawidget.png" height="118" width="367"></p>

</blockquote>

<p>&nbsp;</p>

<h4>Special Properties</h4>

















































<table class="listing"><thead><tr><th>Name</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>rows</td><td>integer</td><td>

5</td><td>Number of rows for the edit widget; sets the HTML textarea tag's rows attribute.</td></tr><tr class="odd"><td>cols</td><td>integer</td><td>

40</td><td>Column width of the edit widget; sets the HTML textarea tag's cols attribute.</td></tr><tr class="even"><td>append_only</td><td>boolean</td><td>

False</td><td>Set this attribute to True to make an append-only TextArea widget. New text gets

added to the top of the existing text, dividing the new text from the

existing text using the divider property. The existing text is shown

below the TextArea, and is not editable. This currently works with

TextArea widgets and using plain text format.</td></tr><tr class="odd"><td>divider</td><td>string</td><td>========================</td><td>Divider text marker to use for append only text areas. Only used then the append_only property is True.</td></tr><tr class="even"><td>maxlength</td><td>integer</td><td>False</td><td>

If non-zero, sets a maximum input length in characters. Since the HTML textarea tag 

has no maxlength property, this is enforced via a JavaScript snippet. So, it is is

not applicable when JavaScript is unavailable.</td></tr></tbody></table><h2>Add-on Widgets</h2>

<p>To find all available add-on widgets contributed by the community, <a class="external-link" href="http://plone.org/documentation/search?path=%2Fplone.org%2Fproducts&amp;portal_type=PSCProject&amp;SearchableText=widget">follow this link</a>.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.3.3.
                Validator Reference
            </h1>

            <p class="documentDescription">A quick reference to the built-in Archetypes validators.</p>
    
            <div>
                
                    <div><h2>Using Validators</h2>

<p>Archetypes fields may have validators specified in the Field schema. For example,

the schema for the basic page type includes the stanza:</p>

<pre>ATDocumentSchema = ATContentTypeSchema.copy() + Schema((
    TextField('text',
...
              validators = ('isTidyHtmlWithCleanup',),
...
    ),
</pre>

<p>This specifies that the <em>isTidyHtmlWithCleanup</em> test will be applied to 

validate form input.</p>

<p>You may specify a sequence of validators:</p>

<pre>validators = ('isMaxSize', 'isTidyHtmlWithCleanup',),
</pre>

<p>and the validators will tested in order.</p>

<p>The validators sequence may contain two kinds of entries:</p>

<ul><li>The string names of validators registered with the validation service (see Products.validation);</li>

    

    <li>Instances of classes implementing the IValidator interface

        (Products.validation.interfaces.IValidator.IValidator).

    </li></ul><p>A validation specification using a validator class instance can look like:</p>

<pre>validators = ( ExpressionValidator('python: int(value) == 5'), )
</pre>

<p>&nbsp;</p>

<h2>Registered Validators</h2>

<p>

These are validators pre-registered with the validation service.

They may be specified by name.</p>































































































































<table class="listing"><tbody><tr><th>Name</th><th>Use</th><th>Details</th></tr><tr class="odd"><td>isDecimal</td><td>Is the input a decimal number.</td><td>Allows exponent notation.</td></tr><tr class="even"><td>isInt</td><td>Is the input an integer.</td><td><br></td></tr><tr class="odd"><td>isPrintable</td><td>Does not contain unprintable characters</td><td>r'[a-zA-Z0-9\s]+$'</td></tr><tr class="even"><td>isSSN</td><td>Is a well-formed social-security number</td><td>Very naive: r'^\d{9}$'</td></tr><tr class="odd"><td>isUSPhoneNumber</td><td>Is a valid US phone number</td><td>Looks for 10 digits, ignores spaces, parens and dashes</td></tr><tr class="even"><td>isInternationalPhoneNumber</td><td>Is a valid international phone number</td><td>Looks for any number of digits, ignores spaces, parens and dashes</td></tr><tr class="odd"><td>isZipCode</td><td>Very naive: is five or nine digits</td><td><br></td></tr><tr class="even"><td>isURL</td><td>Is a valid URL</td><td>Recognizes most protocols</td></tr><tr class="odd"><td>isEmail</td><td>Is a valid e-mail address</td><td>A pretty good regular expression test</td></tr><tr class="even"><td>isMailTo</td><td>Is an e-mail address preceded by "mailto:"</td><td><br></td></tr><tr class="odd"><td>isUnixLikeName</td><td>Passes the basic test to be a Unix-style name</td><td>r"^[A-Za-z][\w\d\-\_]{0,7}$"</td></tr><tr class="even"><td>isMaxSize</td><td>Tests if an upload, file or something supporting len() is smaller than a 

       given max size value.</td><td>Tests against a <em>maxsize</em> attribute on the field</td></tr><tr class="odd"><td>isValidDate</td><td>Tests whether or not input value can be converted to a DateTime object.</td><td>&nbsp;</td></tr><tr class="even"><td>isEmpty</td><td>Input value must be empty.</td><td>&nbsp;</td></tr><tr class="odd"><td>isEmptyNoError</td><td>Input value must be empty.</td><td>Validation will fail if input value is not empty; but no error will show.</td></tr><tr class="even"><td>isValidId</td><td>Input value is a valid identifier.</td><td>&nbsp;</td></tr><tr class="odd"><td>isTidyHtml</td><td>Uses mx.Tidy to validate HTML input. Fails on errors and warnings.</td><td>&nbsp;</td></tr><tr class="even"><td>isTidyHtmlWithCleanup</td><td>Uses mx.Tidy to validate HTML input. Fails only on errors; cleans up.</td><td>&nbsp;</td></tr><tr class="even"><td>isNonEmptyFile</td><td>The uploaded file is not empty.</td><td>&nbsp;</td></tr><tr class="even"><td>isTAL</td><td>Validates as Template Attribute Language</td><td>&nbsp;</td></tr></tbody></table><p>&nbsp;</p>

<h2>Useful Validation Classes</h2>

<p>These classes are useful for creating your own validation class instances.

Imports and prototypes are shown. See source for details.</p>

<h3>ExpressionValidator</h3>

<p>Evaluates an expression to test the input value.</p>

<pre>from Products.validation.validators.ExpressionValidator import ExpressionValidator

def ExpressionValidator(expression=None, errormsg=None)
</pre>

<h3>RegexValidator</h3>

Tests value against a regular expression after removing <em>ignore</em>

<p> characters.</p>

<pre>from Products.validation.validators.RegexValidator import RegexValidator

def RegexValidator(name, regex, title=name, description='',
 errmsg='fails tests of %s' % name, ignore=None)
</pre>

<h3>RangeValidator</h3>

<p>Tests to see if specified minval &lt;= input_value &lt; maxval</p>

<pre>from Products.validation.validators.RangeValidator import RangeValidator

def RangeValidator(name, minval=0.0, maxval=0.0, title='', description='')
</pre></div>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                2.4.
                Other Useful Archetypes Features
            </h1>

            <p class="documentDescription">Complementary features you'd be pleased to know about. </p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.4.1.
                How to use events to hook the Archetypes creation process
            </h1>

            <p class="documentDescription">Times
have changed since the days of at_post_create_script(). Here is the way
to hook into Zope3 (or Five's) event system in order to execute code
during the Archetypes content creation and or editing process.</p>
    
            <div>
                
                    <div><p>In the old days the only way to execute code during the object

creation process for Archetypes was to add a method to your content

type called <em>at_post_create_script</em>. In this script you would add any code that should execute after Archetypes was done creating the object.</p>

<p>The new method for hooking the Archetypes object creation and editing process is to use Zope3 style events, like&nbsp;<em>Products.Archetypes.interfaces.IObjectInitializedEvent</em>.</p>

<h2>Prerequisites</h2>

<p>Have a content type handy so we can add a post creation hook to it.
To learn how to create a content type, check previous sections of this
manual.</p>

<p>We're going to use a content type called <em>ExampleContent</em> with the interface <em>IExampleContent</em> for this how to. The code structure will look like this:</p>

<pre>tutorial/configure.zcml
tutorial/interfaces.py
tutorial/content/examplecontent.py</pre>

<h2>Step by step</h2>

<p>First let's create the interface for our <em>ExampleContent</em> type. In <em>interfaces.py</em>, add:</p>

<pre>from zope.interfaces import Interface

class IExampleContent(Interface):
    ''' Interface for the ExampleContent type
    '''</pre>

<p>You can store the implementation for your event handlers anywhere

but for the purpose of this example we're going to put it in the same

module as the <em>ExampleContent</em> type:</p>

<pre>from zope.interface import implements
from Products.ATContentTypes import atct

def addSubFolder(obj, event):
    obj.invokeFactory(type_name='Folder', id='subfolder')

class ExampleContent(atct.ATFolder):
    implements(IExampleContent)
    portal_type = archetype_name = 'ExampleContent'  # &lt;-- this is no longer needed with GenericSetup.</pre>

<p>All we need to do now is register the <em>addSubFolder</em> method as a handler for&nbsp;<em>Products.Archetypes.interfaces.IObjectInitializedEvent</em> and for anything implementing the <em>IExampleContent</em> interface. We do this in a <em>configure.zcml</em> file:</p>

<pre>&lt;subscriber for=".interfaces.IExampleContent
                 Products.Archetypes.interfaces.IObjectInitializedEvent"
            handler=".content.examplecontent.addSubFolder" /&gt;</pre>

<p>Notice that there are two interfaces in the "for" attribute. This is

because we are registering a multi-adapter. Now when you add an <em>ExampleContent</em> type the <em>addSubFolder</em>

method will be executed after Archetypes has created the object. The

object itself will be passed to the handler and we can use the object

reference to make additional modifications, in this case adding a sub

folder.</p>

<p>You can register as many handlers as you need.</p>

<h2>Warnings from your future</h2>

<p>Having implemented all of your content type's event hooks you might then run off and try using <em>invokeFactory</em>&nbsp;somewhere in your code only to realize that your&nbsp;<em>IObjectInitializedEvent</em> handlers are not being executed. This is because <em>invokeFactory</em>

does not notify Zope's event system that new objects are being created.

You have to provide these notifications yourself. So here is an example:</p>

<pre>import zope.event
from Products.Archetypes.event import ObjectInitializedEvent
some_folder.invokeFactory(type_name='ExampleContent', id='foobar')
obj = getattr(some_folder, 'foobar')
zope.event.notify(ObjectInitializedEvent(obj))</pre>

<p>This will both create your object and invoke any&nbsp;<em>IObjectInitializedEvent</em> handlers you have registered. Notice that we are importing <em>ObjectInitializedEvent</em>, not the interface <em>IObjectInitializedEvent</em>.

We want to actually instantiate an event passing it our newly created

object as the single parameter and then pass the event to <em>zope.event.notify</em>. From there, Zope takes care of figuring out which handlers need to execute.</p>

<p>So for example, in our <em>addSubFolder</em> method above, any
events registered for the folder we created would not fire. To complete
our hook in this case we should provide a notification for our newly
created folder. Archetypes or other products may be expecting
notifications so when using invokeFactory, always send an <em>IObjectInitializedEvent </em>for the object<em>. </em>The complete method looks like this:</p>

<pre>def addSubFolder(obj, event):
    obj.invokeFactory(type_name='Folder', id='subfolder')
    folder = getattr(obj, 'subfolder')
    zope.event.notify(ObjectInitializedEvent(folder))
</pre>

<h2>Further information</h2>

<div><span class="Apple-style-span">

<p><span class="Apple-style-span"><span class="Apple-style-span">T</span><span class="Apple-style-span">h</span><span class="Apple-style-span">e</span><span class="Apple-style-span">&nbsp;</span><span class="Apple-style-span"><em>IObjectInitializedEvent</em> is fired once during the objects creation process. To hook the editing process for an object use&nbsp;<em>IObjectEditedEvent</em>.</span></span></p>

<p>The <span class="Apple-style-span"><span class="Apple-style-span"><span class="Apple-style-span"></span></span></span><a class="external-link" href="http://plone.org/documentation/manual/tutorial/borg/sending-and-handling-events/">Sending&nbsp;and&nbsp;handling&nbsp;events</a> tutorial is a little out of date but provides a broader explanation of the underlying mechanics. <a class="external-link" href="http://plone.org/documentation/manual/tutorial/five-zope3-walkthrough/events">Walking through Five to Zope 3 - Events</a> is another great introduction to events handling.&nbsp;<span class="Apple-style-span"><span class="Apple-style-span"></span></span></p>

</span></div>

<p><span class="Apple-style-span">

</span></p>

<p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                2.5.
                Appendix: Practicals
            </h1>

            <p class="documentDescription"></p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.5.1.
                 How-To Extend A Basic Archetype Content Type 
            </h1>

            <p class="documentDescription">This
How-To describes what to do next after you've gotten the basic
Archetype examples working. You can add functions, views, actions, and
edit-page validation. </p>
    
            <div>
                
                    <div id="parent-fieldname-text">

<p>

Ok, so you've got the Archetype examples to work, and now you'd like to

know how to flesh out the basic example into something useful. (That's

how I started; I knew I needed to make new Content Types, but didn't

know how they worked. I got the examples going, then tried to figure

out how to modify them to do what I wanted.) I found learning

Plone/Zope very frustrating until I got to this point. Then, once I

figured out how to make Content Types do what I wanted, it all made

sense.</p>

<strong>Adding Functions</strong>

<p>This is probably one of the first things

on your mind. Where do I add functions to my Content Type? How do I

call them? What syntax do I use? Well, these were the things that I

wondered about. I figured out how to do them after some trial and

error. I never made a real website before, where I had to write scripts

(a blog doesn't count). So even though I had a lot of python

experience, I was confused at first.

[<em>First, know that the Zope server converts a URL path into an

object path, to find the object that will render your page. This is

covered in the Zope Developer's guide. The key point you need to know

is that there's a parallel between the URL and your object hierarchy,

but it's not exactly the same</em>.]</p>

<p>

To cut to the chase, Zope figures out which object/function the URL is

pointing to, and it takes the query string (?arg=val,arg2=val2, etc.)

and uses it to figure out all the right arguments for the function

call. So, you define your function in the ususal way, i.e.,</p>

<pre>class MyExample (BaseContent):
  """ My example Archetype Content Type. """

  # define the schema
  # override the default actions

  def my_function (self, foo1, foo2):
    """ You need a doc string here!! I lost a lot of time finding this out.
        Archetypes needs this when registering the function in the framework.
        You'll get a 404 error if you forget the doc string. """
    temp1 = "foo"  # this is not persisted in the ZODB
    self.this_is_a_persisted_member_in_the_ZODB = "I'm here to stay %s" % (foo1,)
    # if you don't return anything, then the Zope server will not re-render a page
    # anything you return will be rendered
    # return "got here" will show up as text
    # return context.index_html() will return the default page (should be reasonable in any content; people won't get lost)
    # return context.base_edit() has the effect of "jumping" to the edit page</pre>

<strong>Adding Actions</strong>

<p>



I was confused when I saw the description of <em>actions</em>

in the Plone manual. Here's how I think of them: they're just the

hyper-linked tabs along the top of the Content Type (content actions)

or horizontal site navagation (site actions). The links are typically

to a Content Type function (that returns a page), or to a page template

(I only know how to make .pt and .cpt types so far). The actions for

the Content Type are defined (overriden) using the Factory Type

Information format, and the process well described in the Archetype

tutorials. I'll just add that you can make most of the tabs (actions)

visible=True or visible=False. You can append your own actions that

show up as tabs for your content type.</p>

<strong>Changing Page Views</strong>

<p>You can change the various views of

your content type by defining new page templates to display your data.

Typically, these page templates (.pt) are placed within the skins/

directory of your product. I can't fill you in on exactly how Zope maps

the URL (http://.../myArchExample/my_view) to the my_view.pt, but the

details are taken care of (by the Install.py script?) and you should

put your page templates in the skins/ directory. <em>[This section needs updating, as soon as I learn how it's done.]</em></p>

<strong>Validating the Edit Form</strong>

<p>



You probably have a need to validate the data that users enter on the edit page.  This process is called <em>validation</em>, and the scripts that implement the rules are called <em>validators</em>.

There's a clean way to do this in Archetypes using built-in field

validators and your own post_validation() function for the Content

Type. You don't have to write any (.cpt,.cpy,.vpy) form templates, or

controller scripts. Of course, validation is optional, so you can skip

either step.</p>

<ol><li>Use field validators on individual entries (see the validator = (,) field attribute).  This is the first-line of validation.</li><li>Define

a post_validation() function. This allows you to validate fields in the

context of the entire class, and set error (re-do) flags for individual

fields.</li></ol><p>

After the user hits the 'submit' button on the edit page, the field

validators are run first. If any validators fail, the input field is

highlighted, and the user is sent back to the edit page to fix the

errors.</p>

<p>If all the field validators pass, then your post_validate(self,

REQUEST, errors) is called. The form keys and data are passed to you in

the REQUEST dictionary. Your code will validate the edit form values in

the REQUEST dictionary. If you see errors that require fixing, you'll

set them in the errors dictionary (using the corresponding key in the

REQUEST). For example, here's a</p>

<pre>class MyExample (BaseContent):
  """ My example Archetype Content Type. """

  # define the schema
  # override the default actions

  def post_validate (self, REQUEST, errors):
    """ This function checks the edit form values in context.
        It's called after the field validation passes.  """
    if REQUEST['type'] == 'buy' and REQUEST['quantity'] == 0:
      error['quantity'] = "Quantity must be non-zero."</pre>

<strong>Adding Child Members</strong>

<p>

If your content type is a folder-like object, you can write functions

that will add child objects. This may be useful, for example, if your

Content Type is a ledger, and you need to add new transactions when the

user hits an action. The following example code shows how to do this.</p>

<pre>class MyExample (BaseFolder):
  """ My example Archetype Content Type. """

  # define the schema
  # override the default actions

  def addTransaction (self, type, quantity):
    """ This function creates a new MyTransaction object in the folder. """
    # create a unique id for this transaction
    newId = self.generateUniqueId('MyTransaction')
    # create a new MyTransaction object
    self.invokeFactory(id=newId, type_name='MyTransaction')
    myTransaction = getattr(self, newId)
    return myTransaction.base_edit()     # send the user to the edit page</pre>

</div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.5.2.
                Implement Archetypes ComputedField and ComputedWidget on your Product and reference other Fields 
            </h1>

            <p class="documentDescription">A simple use of ComputedField and ComputedWidget referencing other fields, built-in or 3rd party, in the same Plone product </p>
    
            <div>
                
                    <div><h2>Motivation</h2>

<h3>There are many reasons why this how-to exists:</h3>

<ul><li>Almost no Archetypes examples using ComputedField and ComputedWidget</li><li>We want our product to process some data on itself, but reload isn't a matter of concern</li><li>We love PZP (Python-Zope-Plone)!</li></ul><h3>What do we need?</h3>

<ul><li>A Plone installation</li><li>A nice text editor (my wintel box runs SciTE)</li><li>Some

product (for real dummies like me, try

http://plone.org/documentation/tutorial/anonymously-adding-custom-content-types-with-argouml-and-archgenxml/view)</li></ul><p><strong>What we are going to achieve?</strong></p>

<ul><li>Make a page process it's own information</li></ul><p><br>Let's

say you created a product, maybe using ArgoUML (an UML editor) and

ArchGenXML. One thing you might realize it's missing on creating UML's

is that: we create classes (Plone products), their types are also

classes (Archetypes' fields and widgets) and Attributes (Fields and

Widgets' properties) as TD's (tagged data) for Archetypes' types, but

we have no <em>methods</em>!<br><br>But we could do more if we inserted

code: classes are made of attributes and methods (code). But as UML

editors are not that Python friendly, we do that by hand.<br><br></p>

<h3>So, how?</h3>

<p>If

you already have navigated the path of a product, you've stumbled on

some source files (.py) inside, so take some time to read their source (<em>Read the source, Luke!</em>). Probably you've seen some like this (for example, MyOrder.py):<br><br></p>

<pre>from AccessControl import ClassSecurityInfo
from Products.Archetypes.atapi import *
from Products.Laborde.config import *

from Products.DataGridField import DataGridField, DataGridWidget # we talk about this later
from Products.DataGridField.Column import Column #really!

schema = Schema((
    StringField(
        name='PurchaseOrderID',
        widget=StringWidget(
            label="PurchaseOrderID",
            description="Enter this purchase order unique identification number.",
            label_msgid='MyOrder_label_PurchaseOrderID',
            description_msgid='MyOrder_help_PurchaseOrderID',
            i18n_domain='MyOrder',
        ),
        required=True,
        searchable= True
    ),
    DataGridField(
        name='PurchaseOrderItems',
        required=True,
        searchable=True,
        widget=DataGridWidget(),
       &nbsp;allow_empty_rows = False,
        columns=(
            "Maker",
            "Model",
            "Description",
            "UnitaryCost",
            "Quantity"
        ),
    ),

    ComputedField(
        name='TotalCost',
        searchable=True,
        expression="context.calculateTotal()",
        widget=ComputedWidget(
            label="Total",
            modes=('view')
        ),
    ),

),
)

PurchaseOrder_schema = BaseSchema.copy() + \
    schema.copy()

class PurchaseOrder(BaseContent):
    """
    """

    # some class defitnitions

    # a function that calculates total
    # but it doesn't even check (try-except) data it uses

    def calculateTotal(self):
        Total = 0.0
        for n in self.PurchaseOrderItems:
            Quantity = float(n['Quantity'])
            UnitaryCost = float(n['UnitaryCost'])
            Total = Total + Quantity * UnitaryCost
        Total = '%1.2f' % Total # this makes our total have 2 decimals for display
        return Total

registerType(PurchaseOrder, PROJECTNAME)
</pre>

<p>&nbsp;</p>

<p>Aargh! I've just core dumped and almost killed 30!<br><br>The

above code can be divided in two parts: Schema and Class (Product). We

have declared 3 different fields in the schema: the first is a bultin

trivial Archetype field; the second is imported from the Product

DataGridField (you need it installled on your Plone instance to work);

the third is our the field we want to change as someone changes values

on the form.</p>

<pre>expression="dir()" # useful to check avaible objects</pre>

<p>,</p>

<pre>expression="1+1" # 10 if you have two neurons, like me. Otherwise, 2.
</pre>

<p>,</p>

<pre>expression="dir(context)" # avaible context child objects</pre>

<p>or</p>

<pre>expression="context.calculateTotal()" # VoilÃ¡! Reference to some real(?) code!</pre>

<p><br>We've just called something (a function, in fact) named <em>calculateTotal</em>.<br><br>But

smart as we are, we realized that expresssions called this way must be

somewhere in our context scope. I mean, inside our class definition.<br><br>The

function definition itself isn't that simple: it adds up the total and

returns its value. What isn't simple? Our generous DataGridField

returns a tuple of dictionaries like:</p>

<pre>(
    {"Maker":"HP","Model":"scanjet 4670","Description":"scanner","UnitaryCost":"99.00","Quantity":"1"},
    {"Maker":"LG","Model":"L173SA","Description":"17 LCD monitor","UnitaryCost":"299.95","Quantity":"2"},
    {"Maker":"Seagate","Model":"SA32300","Description":"Hard drive","UnitaryCost":"134.50","Quantity":"2"}
)
</pre>

<p>&nbsp;</p>

<p>The <em>for</em>

loop iterates over every item on the tuple and searches for two

dictionary items. Other field are rather simple to retrieve data: just

use field's name attribute.<br><br>The <em>widget=SomeWidget(modes='view',...) </em>realizes

the feat of showing this field only on the view mode: not when adding

the item and editting, nor when editting an existing item.</p>

<h3>What's next?</h3>

<ul><li>What could we do with PhotoField (ImageWidget)?</li><li>try-except is always recomended</li><li>Could this better than <em>mutate</em>?</li><li>Can we make a file avaible for download with some strange mime type based on the information of this product?</li></ul></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.5.3.
                Making the view page of a content type use your schemata declarations 
            </h1>

            <p class="documentDescription">How to make the schemata declarations in a Archetypes schema be used in the view page of a content type. </p>
    
            <div>
                
                    <div id="parent-fieldname-text" class="kssattr-atfieldname-text kssattr-templateId-widgets/rich kssattr-macro-rich-field-view">

<h1>Introduction</h1>

<p>Declaring schematas in your Archetype schema



has the nice effect of displaying the fields of the different schemas



on different edit pages (very much like a "wizard" for adding a new



content type instance). Often times you might like to also have the



view page be divided according to the different schemas you have



declared. This is not done automatically by Archetypes so in this



document I'll show you how to do it yourself. Don't worry! It's really



quite easy.</p>

<h1>Python class and schema</h1>

<p>I'll be using a



simple article content type I have constructed for this how-to to show



you how the schematas can be used on your content type's view page. The



example type is really not very usable, but just complex enough to show



you how to do this. It has a schema of four fields in addition to the



default id and title fields: abstract, body, firstname, lastname. The



abstract and body fields are in a schemata named article and the



firstname and lastname field in a schemata named author.</p>

<p>I



have also defined the title and id fields to be in schemata article.



This was done so I won't have an extra schemata called default and so I



can use the title field for the title of the article. (Remember to use <code>BaseSchema.copy()</code>!)</p>

<p>The



class itself has just the schema declaration and a new view action



definition. I have defined the view action to use a template called



article_view that we'll be getting to shortly.</p>

<p>Here is the file in it's entirety:</p>

<p>&nbsp;</p>

<pre>from Products.Archetypes.public import *

from Products.CMFCore import CMFCorePermissions



from config import PKG_NAME



schema = BaseSchema.copy() + Schema((

        TextField('abstract',

                required=1,

                searchable=1,

                widget = TextAreaWidget(description="Abstract", label="Abstract"),

                schemata = 'article'),

        TextField('body',

                required=1,

                searchable=1,

                widget = TextAreaWidget(description="Body", label="Body"),

                schemata = 'article'),

        TextField('firstname',

                required=1,

                searchable=1,

                widget = StringWidget(description="First name", label="First name"),

                schemata = 'author'),

        TextField('lastname',

                required=1,

                searchable=1,

                widget = StringWidget(description="Last name", label="Last name"),

                schemata = 'author'),

        ))



schema['title'].schemata = 'article'

schema['id'].schemata = 'article'



class Article(BaseContent):

        schema = schema



        actions = (

                        {'id': 'view',

                        'name': 'View',

                        'action': 'string:${object_url}/article_view',

                        'permissions': (CMFCorePermissions.View,)

                        },

        )



registerType(Article, PKG_NAME)

</pre>

<h1>View template</h1>

<p>The



view template article_view is the main part of this how-to. It has the



page template code to generate the different pages for the different



schematas.</p>

<p>First you should copy the base.pt file from the



Archetypes skins folder (on my Debian GNU/Linux unstable it's in



/usr/share/zope/Products/Archetypes:1.3/skins/archetypes) to your



product's skins folder. It has most of the template code you'll need



ready, so you'll only need to make some minor changes to make this



work. Also it uses all the default macros and such, so you'll view page



will look like a real plone page.</p>

<p>The base.pt template just



goes through all the fields of your content type and shows their



widgets. What we want to do is to have it only go through the fields of



one schemata at a time and give us links to see the others. This will



be done using REQUEST parameters to the scripts.</p>

<p>I'll go



though the changes from the top of the file downwards so you'll have a



easier time keeping up and making the changes to your own template.</p>

<h2>Links to the different schematas</h2>

<p>We'll want the list of different schematas to be at the top of the page, so that'll go in first. Find the line that says '<code>&lt;metal:main_macro define-macro="main"&gt;</code>'.



This is where the body of the template starts. After this line is the



header with the title and the little icons for edit, print and such,



and I want to have my links to show up above that. So after the



beginning of the body and above the header add the following code:</p>

<p>&nbsp;</p>

<pre>        &lt;div style="margin-bottom: 1em"&gt;

                &lt;span tal:repeat="schemata python: here.Schemata().keys()"&gt;

                        &lt;b tal:condition="python: schemata != 'metadata'"&gt;[&lt;a tal:attributes="href string:?page=${schemata}"&gt;&lt;span tal:replace="schemata" /&gt;&lt;/a&gt;]&lt;/b&gt;

                &lt;/span&gt;

        &lt;/div&gt;

</pre>

<p>This just repeats over our schematas' names (we get them with <code>here.Schemata().keys()</code>)



and prints all of them on one line as links, each one in square



brackets. The links are to the same view page, but they all set a



parameter in REQUEST called page that points to the schemata we are



linking to. This isn't very pretty so you'll probably want to make them



look nicer if you like. The '<code>schemata != 'metadata'</code>'

part

is because there's a schemata called metadata created automatically for

your content type to support default standard metadata which can be set

via the properties tab and that we do not want to include here.</p>

<h2>Showing only the schemata we want</h2>

<p>In the next part we'll be diving deeper into the code. You're looking for a part that says '<code>tal:repeat="field python:here.Schema().filterFields(isMetadata=0)"</code>'.



This repeats through the fields of your content type and the following



parts show their widgets. What we want to do here is to have it repeat



through the fields of the schemata we want instead of all of them. In



the previous part we set a parameter in REQUEST called page that points



to the schemata we want to see, and here we want to use that to pick



which schemata's fields to loop over. So just go ahead and replace the



part with '<code>tal:repeat="field python:here.Schemata()[here.REQUEST.get('page', here.Schemata().keys()[0])].filterFields(isMetadata=0)"</code>'.



This just gets the page parameter from REQUEST (if page is not found,



ie. the template is called with no parameters, then first schemata, in



this case article, is used) and loops through the fields of the



schemata with that name.</p>

<p>The completed article_view.pt looks like this:</p>

<p>&nbsp;</p>

<pre>&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"

      lang="en"

      xmlns:tal="http://xml.zope.org/namespaces/tal"

      xmlns:metal="http://xml.zope.org/namespaces/metal"

      xmlns:i18n="http://xml.zope.org/namespaces/i18n"

      metal:use-macro="here/main_template/macros/master"&gt;



  &lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;



  &lt;body&gt;



    &lt;div metal:fill-slot="main"&gt;



      &lt;metal:main_macro define-macro="main"&gt;



        &lt;div style="margin-bottom: 1em"&gt;

                &lt;span tal:repeat="schemata python: here.Schemata().keys()"&gt;

                        &lt;b tal:condition="python: schemata != 'metadata'"&gt;[&lt;a tal:attributes="href string:?page=${schemata}"&gt;&lt;span tal:replace="schemata" /&gt;&lt;/a&gt;]&lt;/b&gt;

                &lt;/span&gt;

        &lt;/div&gt;



        &lt;metal:header_macro define-macro="header"&gt;

          &lt;div metal:use-macro="here/document_actions/macros/document_actions"&gt;

            Document actions (print, rss, etc)

          &lt;/div&gt;

          &lt;h1 tal:content="title_string | here/title_or_id" /&gt;

          &lt;tal:has_document_byline tal:condition="exists:here/document_byline"&gt;

            &lt;div metal:use-macro="here/document_byline/macros/byline"&gt;

              Get the byline - contains details about author and modification date.

            &lt;/div&gt;

          &lt;/tal:has_document_byline&gt;

        &lt;/metal:header_macro&gt;



        &lt;metal:body_macro metal:define-macro="body"

                          tal:define="field_macro field_macro | here/widgets/field/macros/view;"

                          tal:repeat="field  python:here.Schemata()[here.REQUEST.get('page', here.Schemata().keys()[0])].filterFields(isMetadata=0)"&gt;

          &lt;tal:if_visible define="mode string:view;

                                  visState python:field.widget.isVisible(here, mode);

                                  visCondition python:field.widget.testCondition(here, portal, template);"

                          condition="python:visState == 'visible' and visCondition"&gt;

            &lt;metal:use_field use-macro="field_macro" /&gt;

          &lt;/tal:if_visible&gt;

        &lt;/metal:body_macro&gt;



        &lt;metal:folderlisting_macro metal:define-macro="folderlisting"

                                   tal:define="fl_macro here/folder_listing/macros/listing | nothing;

                                               folderish here/isPrincipiaFolderish | nothing;"&gt;

            &lt;tal:if_folderlisting condition="python:folderish and fl_macro"&gt;

                &lt;metal:use_macro use-macro="fl_macro" /&gt;

            &lt;/tal:if_folderlisting&gt;

        &lt;/metal:folderlisting_macro&gt;



        &lt;metal:footer_macro define-macro="footer"&gt;

        &lt;/metal:footer_macro&gt;



      &lt;/metal:main_macro&gt;



    &lt;/div&gt;



  &lt;/body&gt;



&lt;/html&gt;

</pre>

<h1>Conclusion</h1>

<p>So that was it. I told you it was going to be easy!</p>

<p>Happy hacking!</p>

</div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.5.4.
                 Enabling versioning on your custom content-types 
            </h1>

            <p class="documentDescription">Plone
3 includes a robust versioning system as well as a tool for viewing
diffs, which allows you to easily see the changes between two
revisions. This document explains how to integrate versioning and diff
functionality with your custom Archetypes-based content-types. </p>
    
            <div>
                
                    <div id="parent-fieldname-text" class="kssattr-atfieldname-text kssattr-templateId-widgets/rich kssattr-macro-rich-field-view">

<h2>Prerequisites</h2>

<p>You'll

need a Plone 3 instance and a custom product which contains at least

one Archetypes-based content-type on which you want to enable

versioning. &nbsp;</p>

<p>You'll also need to have the <strong>Working Copy Support (Iterate)</strong> product installed. &nbsp;This product is part of the Plone core so to install it, all you need to do it visit the&nbsp;<strong>Add-on Products</strong>&nbsp;section&nbsp;(a.k.a. Quickinstaller)&nbsp;of the <strong>Plone control panel</strong> and select it for installation.</p>

<h2>Creating a setup handler script for GenericSetup</h2>

<p>The

integration code we'll be writing here is best run as a setup handler

using GenericSetup. If your product doesn't already have a GenericSetup

profile and a custom setup handler, <a class="external-link" href="http://plone.org/tutorial/borg/setup-using-genericsetup">this tutorial</a> provides instructions on how to create those.</p>

<h2>Declaring versionable types in your setup handler</h2>

<p>The

portal_repository tool stores a list of content-types on which version

is enabled. &nbsp;With the following code we create a list of the custom

types on we which we want to activate versioning and then notify the

repository tool to start versioning the types in this list.</p>

<p>If

you copy the code below, make sure to edit the TYPES_TO_VERSION setting

so that it contains a list of the types on which you want to activate

versioning.</p>

<pre>from Products.CMFCore.utils import getToolByName
from Products.CMFEditions.setuphandlers import DEFAULT_POLICIES

# put your custom types in this list
TYPES_TO_VERSION = ('Scientist', 'Article', 'Presentation')

def setVersionedTypes(portal):
    portal_repository = getToolByName(portal, 'portal_repository')
    versionable_types = list(portal_repository.getVersionableContentTypes())
    for type_id in TYPES_TO_VERSION:
        if type_id not in versionable_types:
            # use append() to make sure we don't overwrite any
            # content-types which may already be under version control
            versionable_types.append(type_id)
            # Add default versioning policies to the versioned type
            for policy_id in DEFAULT_POLICIES:
                portal_repository.addPolicyForContentType(type_id, policy_id)
    portal_repository.setVersionableContentTypes(versionable_types)</pre>

<p>Now we call this function from the&nbsp;<span class="Apple-style-span">importVarious() function in our setup handler script. &nbsp;Make sure to pass the portal object as a parameter.</span></p>

<p><span class="Apple-style-span"></span></p>

<pre>def importVarious(context):
    """Miscellanous steps import handle"""
    portal = context.getSite()
    setVersionedTypes(portal)</pre>

<h2>Enabling visual diffs on your versioned types</h2>

<p>Now

that you've enabled versioning, you'll probably want to enable visual

diffs so you can compare the changes made between different versions of

an object.</p>

<p>Starting in Plone 3.2 the diff tool can be configured via a
GenericSetup configuration file. &nbsp;You'll want to create or edit
the <strong>diff_tool.xml</strong>

file in the /profiles directory of your product. &nbsp;Here's an

example&nbsp;confirmation&nbsp;file that enables compound diffs on the 3

content-types used in the example above.</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;object&gt;
  &lt;difftypes&gt;
    &lt;type portal_type="Scientist"&gt;
      &lt;field name="any" difftype="Compound Diff for AT types"/&gt;
    &lt;/type&gt;

    &lt;type portal_type="Article"&gt;
      &lt;field name="any" difftype="Compound Diff for AT types"/&gt;
    &lt;/type&gt;

    &lt;type portal_type="Presentation"&gt;
      &lt;field name="any" difftype="Compound Diff for AT types"/&gt;
    &lt;/type&gt;
  &lt;/difftypes&gt;
&lt;/object&gt;</pre>

<p>For

Plone versions earlier than 3.2, there is not a GenericSetup handler

for configuring the diff tool, but you can create these settings

through the ZMI using the <strong>portal_diff</strong> tool. &nbsp;In the <strong>Portal Type</strong> drop-down menu select the content-type on which you want to enable diffs. &nbsp;In the <strong>Field name</strong> box type "any". &nbsp;For the <strong>Diff Type</strong> select "Compound Diff for AT Types". &nbsp;Finally click the <strong>Add Field</strong> button. &nbsp;Repeat these steps for each content-type.</p>

<h2>Deploying your new versioning and diffs policy</h2>

<p>To

deploy these changes you'll need to re-run you product's GenericSetup

policy. &nbsp;If your instance is not running in debug mode, you'll first

need to restart your Zope instance to make your new filesystem code

available.&nbsp;</p>

<p>Assuming you've used paster to create your product package, reinstalling your product in the <strong>Add-on Products</strong> section&nbsp;of the <strong>Plone control panel</strong>&nbsp;should be sufficient to re-run your<strong>&nbsp;<span class="Apple-style-span">GenericSetup policy</span></strong>. &nbsp;If your product's install method does not run your&nbsp;GenericSetup&nbsp;policy, you may need to visit the <strong>portal_setup</strong> tool in the ZMI and run it manually.</p>

<h2>Verifying that versioning and visual diffs are now enabled</h2>

<p>Visit

an instance of one of the types on which you've enabled versioning.

&nbsp;Make some edits to one or more of the fields save those changes.

&nbsp;Next, visit the <strong>history</strong> tab for the item you just

edited. You should see a list showing two versions. &nbsp;Click the link to

compare versions you should see a diff showing you what has been

changed between the two revisions.</p>

</div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                2.5.5.
                 b-org: Creating content types the Plone 2.5 way 
            </h1>

            <p class="documentDescription">Plone
2.5 brings us closer to the promised land of Zope 3. Zope 3 brings us a
new way of working. This tutorial will show how to marry the old and
the new, to make Plone products that are more extensible, better tested
and easier to maintain.</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-4">

            <h1>
                2.5.5.1.
                Introduction
            </h1>

            <p class="documentDescription">What is b-org, and what will you learn here?</p>
    
            <div>
                
                    <div><p>b-org stands for "base-organisation". The name had nothing whatsoever to do with my desire to get an svn URL of <a href="http://svn.plone.org/svn/collective/borg">http://svn.plone.org/svn/collective/borg</a>. Promise. In fact, it used to be called <i>company</i>,
which some people rightly pointed out is a bit too generic and opens up
the possibility of conflicts with other people's code. It just proves
that naming generic components is difficult.</p><p><b>Generic </b>is the key word here. Functionally, b-org provides infrastructure to help you manage <b>Departments</b>, <b>Employees</b> and <b>Projects</b> in a natural way. Departments are containers for employees, employees are linked to projects by references. Using <i>membrane</i>,
these objects become sources for users and groups, so that a department
is a group for all the employees in it, and employees become real users
of the system, with usernames and passwords. Projects manage local
roles, so that employees that have been associated with the project are
able to add and modify content in it. Other users may or may not be
able to view content in a project, depending on its workflow state.</p><p>However,
b-org makes no assumptions about which metadata you want to associate
with departments, employees or projects. For that, it expects you to
plug in your own content schema. It also delegates almost all its
functionality to smaller components, so that if you, for example, want
to store authentication details via LDAP or change the way in which
users are employees to projects, you can do so by implementing small,
isolated components rather than sub-classing and re-implementing large
chunks of the three basic content types.<br></p><p>That's all well and
good, but you're probably not going to want to read a lengthy tutorial
just about how great b-org is. As the title promises, this tutorial is
about <b>leveraging new technologies available in Plone 2.5</b> to
write better content types and other software in Plone. Hopefully, you
will find the techniques described here useful whether you are writing
a member management module using membrane (mmmm), or other code. I for
one, want to go and rewrite several of my products (like Poi) to make
them more extensible and flexible after having adopted these
techniques. Hopefully, you will also learn something about the <b>development process</b>, in particular <b>test-driven development</b>, that I followed, and how the future of Plone is entangled in <b>Zope 3</b>.</p><p>This tutorial should be viewed as complementary to, rather than superceding, my earlier tutorial entitled <a title="RichDocument: Creating content types the Plone 2.1 way" href="http://plone.org/documentation/manual/developer-manual/archetypes/appendix-practicals/richdocument"><i>RichDocument - Creating Content Types the Plone 2.1 way</i></a>.
The techniques of RichDocument, in particular relating to extending
ATContentTypes, are still valid in Plone 2.5. What Plone 2.5 allows us
to do, however, is to achieve better separation of concerns between
content storage, business logic and view logic, due to the added spices
of Zope 3. For RichDocument, the gain wouldn't be that great since it's
relatively simple (and focuses on doing as little as possible by
re-using as much as possible from ATContentTypes). Hence, I didn't
update the RichDocument tutorial, nor do I feel as compelled to update
RichDocument itself (yet). b-org is a more ambitious example which
allows us to illustrate the new techniques more fully.</p><p>One thing to note is that this tutorial is still centered on <b>Archetypes</b>,
and assumes you know the basics of Archetypes development on the
filesystem. Archetypes is rooted in a pre-Zope 3 world, and there are
times when we have to accommodate it in ways that make our clean
patterns a bit messier - luckily, not too often. There are ways of
managing content in Zope 3 that can be applied to Plone, for example by
way of <a title="Using zope.formlib With Plone" href="http://plone.org/documentation/manual/developer-manual/archetypes/appendix-practicals/using-zope-formlib-with-plone">zope.formlib</a>,
but these are generally not quite ready to replace what we can do today
with Archetypes. In the future, they may be, but more likely Archetypes
will converge a bit more with its Zope 3 equivalents and blur the lines
between the two approaches. The upshot is that what you know about
Archetypes today continues to be relevant, and is augmented by the Zope
3-inspired techniques you will find here.<br></p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-4">

            <h1>
                2.5.5.2.
                A whirlwind tour of Zope 3
            </h1>

            <p class="documentDescription">Zope
3 is still fairly new. After reading this tutorial, it should hopefully
start to feel a bit more familiar. In this section, we will give a
brief overview of what is different in Zope 3 and how it fits into
Plone.</p>
    
            <div>
                
                    <div><p>The
name Zope 3 is a lie. True - it is brought to you by many of the same
clever people who built Zope 2, one of the most advanced open source
app servers of its day. True, it is still Python, it still publishes
things over the web, and there are still Zope Page Templates. However,
Zope 3 is about small, re-usable components orchestrated into a
flexible framework. It is this flexibility that allows us to use Zope 3
technologies in Zope 2 applications like Plone.</p>

<p>A piece of wizardry called <em>Five</em> (Zope 2 + Zope 3 = Five,
geddit?) makes a number of Zope 3 components directly available in Zope
2, and since Zope 2.8, almost all of Zope 3 has shipped with Zope 2 as
a python library. Plone 2.5's primary purpose was to lay the
foundations for taking advantage of Zope 3 technologies in Plone.</p>

<p>Zope 3 may seem a bit alien at first, because it uses strange concepts such as <strong>adapters</strong> and <strong>utilities</strong>.
Luckily, these are not so difficult to understand, and once you do, you
will find that they help you focus your development on smaller and more
manageable components. You will also find that these basic concepts
underpin most of the innovative parts of Zope 3.</p>

<h3>Interfaces</h3>

<p>Everything in Zope 3 starts with interfaces. Unlike Java or C#, say,
Python does not have a native type for an interface, so an interface in
Zope 3 is basically a class that contains only empty methods and
attributes, and inherits from <em>Interface</em>. Here is a basic example:</p>

<pre>from zope.interface import Interface, Attribute

class IShoe(Interface):
    """A shoe
    """

    color = Attribute("Color of the shoe")
    size = Attribute("Shoe size")

class IShoeWearing(Interface):
    """An object that may wear shoes
    """

    def wear(left, right):
        """Wear the given pair of shoes
        """
</pre>

<p>Interfaces are primarily documentation - everything has docstrings. Also note that the <em>wear()</em> method lacks a body (there is not even a <em>pass</em> statement - the docstring is enough to keep the syntax valid), and does not take a <em>self</em>
parameter. That is because you will never instantiate or use an
interface directly, only use it to specify the behaviour of an object.</p>

<p>An object can be associated with an interface in a few different
ways. The most common way is via its class. We say that the class <em>implements</em> an interface, and objects of that class <em>provide</em> that interface:</p>

<pre>from zope.interface import implements

class Shoe(object):
    """A regular shoe
    """

    implements(IShoe)
    
    color = u''
    size = 0
</pre>

<p>The <em>implements(IShoe)</em> line means that objects of this class
will provide IShoe. Further, we fulfill the interface by setting the
two attributes (we could have implemented them as properties or used a
an __init__() method as well). The <em>IShoeWearing</em> interface will be implemented in the section on adapters below.</p>

<p>We use interfaces to model components. Interfaces are normally the <strong>first stage of design</strong>,
in that you should define clear interfaces and write actual classes to
fulfill those interfaces. This formalism makes for great documentation
- interfaces are conventionally found in an <em>interfaces</em>
module, and this is typically the first place you look after browsing a
package's documentation. It also underpins the adapter and utility
system - otherwise known as the Component Architecture - as described
below.</p>

<p>Note that you can use common OOP techniques in designing interfaces.
If one interface describes a component that has an "is-a" or "has-a"
relationship to another component, you can let interfaces subclass or
reference each other. An object will provide the interfaces of its
class, and all its base-classes, and all base-interfaces of those
interfaces. Don't worry about untangling that - it works the way you
would expect.</p>

<p>You can also apply interfaces directly to an object. Of course, if
that interface has methods and attributes, they must be provided by the
object, and unless you resort to crazy dynamic programming, the object
will get those from its class, which means that you may as well have
applied the interface to the class. However, some interfaces don't have
methods or attributes, but are used as markers to distinguish a
particular feature of an object. Such <strong>marker interfaces</strong> may be used as follows:</p>

<pre>class IDamaged(Interface):
    """A shoe that is damaged
    """
</pre>

<pre>&gt;&gt;&gt; from zope.interface import alsoProvides
&gt;&gt;&gt; boot = Shoe()
&gt;&gt;&gt; IDamaged.providedBy(boot)
False
&gt;&gt;&gt; alsoProvides(boot, IDamaged)
&gt;&gt;&gt; IDamaged.providedBy(boot)
True
</pre>

<p>Marker interfaces are very useful for things that change at run-time
in response to some event (e.g. some user action), and thus cannot be
determined in advance. In a moment, you see that what you will learn
about adapters and adapter factories below also applies to marker
interfaces - it is possible to alter which adapter factory is invoked
by applying a different marker interface.</p>

<p>It's also possible to apply interfaces directly to classes (that is the <em>class itself</em>
provides the interface, as opposed to the more usual case where the
class implements the interface so that objects of that class provides
it - this is useful because it allows you to group those classes
together and describe the <em>type</em> of class they are) and to
modules (where you want to describe the public methods and variables of
a module). These constructs are less common, so don't worry about them
for now. Look at the documentation and interfaces (!) in the <em>zope.interface </em>package for more.</p>

<h3>Adapters</h3>

<p>The most important thing that Zope 3 promises is <strong>separation of concerns</strong>. In Zope 2, almost everything has a base class that pulls in a number of mix-in classes, such as <em>SimpleItem</em> (surely, the most ironically named class in Zope 2) and its plethora of base classes that include <em>RoleManager</em>, <em>Acquisition.Implicit </em>and many others. This means that a class written for Zope 2 is nearly impossible to re-use outside of Zope.</p>

<p>Furthermore, in Zope 2 we are tightly wedded to the <em>context</em> (aka <em>here</em>)
because it is so convenient to use in page templates, workflow scripts
etc. For example, people often write an Archetypes class that contains
a schema (storage logic), methods for providing various operations
(business logic) and methods for preparing things to display in a page
template (view logic). Often, people do this simply because they can't
think of a better place to put things, but it does mean that re-using
any part of the functionality becomes impossible without importing the
whole class - and its base classes, which include Archetypes'
BaseObject, CMF's DynamicType, and Zope's SimpleItem - to name a few!</p>

<p>Think about the example above. The <em>Shoe</em> class is
well-contained and only concerned with one thing - storing the
attributes of shoes. It can be used as an abstraction of shoe anywhere,
and is very lightweight. Now let's consider that we may want to wear
shoes as well. We can create a pair of shoes easily enough:</p>

<pre>&gt;&gt;&gt; left = Shoe()
&gt;&gt;&gt; right = Shoe()
&gt;&gt;&gt; left.size = right.size = 10
&gt;&gt;&gt; left.color = right.color = u"brown"</pre>

<p>Now we want someone to wear these shoes. Let's say we have a person:</p>

<pre>class IPerson(Interface):
    """A person
    """

    name = Attribute("The person's name")
    apparel = Attribute("A list of things this person is wearing")

class Person(object):

    implements(IPerson)

    name = u''
    apparel = ()
</pre>

<p>In a Zope 2 world, we may have required Person to mix in some <em>ShoeWearingMixin</em>
class that specified exactly how shoes should be worn. That makes for
fat interfaces that are difficult to understand. In a Zope 3 world, we
would more likely use an adapter.</p>

<p>An adapter is a glue component that can adapt an object providing
one interface (or a particular combination of interfaces, in the case
of a multi-adapter) to another interface. We already have a
specification for something that wears shoes, in the form of <em>IShoeWearing</em>. Here is a snippet of code that may use this interface:</p>

<pre>&gt;&gt;&gt; wearing = ...
&gt;&gt;&gt; wearing.wear(left, right)</pre>

<p>The question is what to do with the '...' - how do we obtain an
object that provides IShoeWearing? Code like this is normally operating
on some context, which in this case may be a <em>Person</em>. If that Person implemented IShoeWearing (or at least the <em>wear() </em>method), it would work, but then we are making undue demands on Person. What we need is a way to <em>adapt </em>this IPerson to something that is IShoeWearing. To do that, we need to write an adapter:</p>

<pre>from zope.interface import implements
from zope.component import adapts

class PersonWearingShoes(object):
    """Adapter allowing a person to wear shoes
    """
    implements(IShoeWearing)
    adapts(IPerson)

    def __init__(self, context):
        self.context = context

    def wear(self, left, right):
        self.context.apparel += (left, right)
</pre>

<p>Here, we implement the IShoeWearing interface. Note how the <em>wear()</em> method now has a <em>self</em> parameter, since this is a real object. Also note the <em>__init__()</em> method, which takes a parameter conventionally called <em>context</em>. This is <em>the thing that is being adapted</em>,
in this case an object providing IPerson. We store this as an instance
variable and then reference it later. Note that adapters are almost
always transient objects that are created on the fly (we will see how
in a second).</p>

<p>We could now do something like this:</p>

<pre>&gt;&gt;&gt; wearing = PersonWearingShoes(person)
&gt;&gt;&gt; wearing.wear(left, right)
</pre>

<p>However, this still requires that we know exactly which adapter to invoke for the particular object (<em>person </em>in
this case), effectively creating a tight coupling between the adapter,
the thing being adapted, and the code using the adapter.</p>

<p>Luckily, the Zope 3 Component Architecture knows how to find the
right adapter if you only tell it about the available adapters. We do
that using <strong>ZCML</strong>, the Zope Configuration Markup
Language. This is an XML dialect that is used to configure many aspects
of Zope 3 code, such as permissions and component registration. You can
do what ZCML does in Python code as well, but typically it's more
convenient to use ZCML because it allows you to separate your logic
from your configuration.</p>

<p>ZCML directives are stored in file called <em>configure.zcml</em>, which itself may include other files. A <em>configure.zcml</em>
file in your product directory (Products/myproduct/configure.zcml) will
be picked up automatically by Five. Here is a snippet that will
register the above adapter:</p>

<pre>&lt;adapter factory=".shoes.PersonWearingShoes" /&gt;</pre>

<p>You will sometimes see a fuller form of this directive, like:</p>

<pre>&lt;adapter
    factory=".shoes.PersonWearingShoes"
    for=".interfaces.IPerson"
    provides=".interfaces.IShoeWearing"
    /&gt;</pre>

<p>Here, we are specifying full dotted names to interfaces in the <em>for</em> or <em>provides</em> attributes. These are equivalent to the <em>adapts()</em> and <em>implements()</em> calls we used when defining the adapter. Note that <em>adapts()</em> did not work prior to Zope 2.9 (so the ZCML <em>for</em>
attribute is mandatory), and that if your adapter class for some reason
implements more than one interface (e.g. because it's inheriting
another adapter that has its own <em>implements()</em> call), you may need to specify <em>provides</em> to let Zope 3 know which interface you're really adapting to.</p>

<p>Notice here that the dotted names begin with dot. This means "relative to the current package". You can write <em>"..foo.bar"</em> to reference the parent package as well. You could specify an absolute path instead, e.g. <em>Products.Archetypes.interfaces.IBaseObject </em>or <em>zope.app.annotation.interfaces.IAttributeAnnotatable</em>. Typically, you use the full dotted name for things in other packages and the relative name for things in your own package.</p>

<p>The <em>factory</em> attribute normally references a class. In Python, a class is just a callable (taking the parameters specified in its <em>__init__() </em>method)
that returns an instance of itself. You can reference another callable
as well if you need to, such as a function that takes the same
parameters (only <em>context</em> in this case - obviously there is no <em>self</em> for functions), finds or constructs and object (which must provide <em>IShoeWearing</em>)
and then returns it. This is rarely used, but can be very powerful (for
example, it could find an object providing the given interface in the
adapted object's annotations - but don't worry if you don't understand
that for now).</p>

<p>With this wiring in place, we can now find an adapter for an IPerson
to IShoeWearing. The Component Architecture will ensure that we find
the correct adapter:</p>

<pre>&gt;&gt;&gt; wearing = IShoeWearing(person)
&gt;&gt;&gt; wearing.wear(left, right)
&gt;&gt;&gt; person.apparel == (left, right,)
True
</pre>

<p>We are "calling" the interface, which is a convenience syntax for an
adapter lookup. If an adapter cold not be found, you will get a<em> ComponentLookupError</em>. There are plenty of functions in <em>zope.component</em> to discover adapters and other components - see <em>zope.component.interfaces</em> for the full story.</p>

<p>It is important to realise that the adapter lookup is essentially a
search. The Component Architecture will look at the interfaces provided
by <em>person </em>and look for a suitable adapter to IShoeWearing. As
mentioned before, it's possible for an object to provide many
interfaces, e.g. inherited from its base classes, implemented
explicitly by the object (by declaring <em>implements(IFoo, IBar)</em>),
via ZCML or because an object directly provides an interface. It is
therefore possible that there are multiple adapters that could be
applicable. In this case, Zope 3 will use the <em>interface resolution order</em> (IRO) to find the<strong> most specific</strong> adapter. The IRO is much like you would expect of polymorphism in traditional OOP:</p>

<ul><li>an interface directly provided by the object is more specific than one provided by its class</li><li>an object provided by an object's class is more specific than that provided by a base class</li><li>if an object has multiple base classes, interfaces are inherited in the same order as methods are inherited</li><li>if a class implements multiple interfaces, the first one specified is more specific than the second one, and so on<br></li></ul><p>Remember
marker interfaces? One use of marker interfaces is to imply a
particular adapter. Think about the case where you may have&nbsp;
specific adapter to IShoeWearing for some marker interface IAmputee. If
you mark a person as an IAmputee due to some unforunate accident, the
IShoeWearing adapter may raise a warning rather than modify the apparel
list.</p>

<p>All of this may seem a little roundabout and unfamiliar, but you'll
get to grips with it soon enough. Let's re-cap how we arrived at this:</p>

<ol><li>We modelled our application domain with some interfaces - IPerson, IShoe</li><li>We modelled an aspect of a person (or other object) for wearing shoes - IShoeWearing</li><li>We wrote some simple classes that implemented the domain interfaces IPerson and IShoe</li><li>We wrote and registered a simple adapter that could adapt an IPerson to IShoeWearing</li></ol><p>Then
we showed how this could be used by some hypothetical client code. The
upshot is that the client code only needed to know about IPerson and
IShoeWearing, not how the aspect of a person that involves wearing
shoes is implemented. The Component Architecture will ensure that the
appropriate adapter is found, regardless of whether the person is a
vanilla IPerson, a sub-class with a more specific sub-interface, or an
instance with a marker interface applied.</p>

<p>&nbsp;</p>

<h3>Multi-adapters, named adapters and views<br></h3>

<p>In the example above, we used an adapter with a single context. That
is the most common form of adapter, but sometimes there is more than
one object that forms the context of an adapter. As a rule of thumb, if
you find yourself passing a particular parameter into every method of
an adapter, it should probably be a multi-adapter.</p>

<p>The most common example of a multi-adapter that you will come across is that of a <em>view</em>,
which incidentally is also how Zope 3 solves the "where do I put my
view logic" code. We will cover views in detail later, but for now
think of them as a python class that is automatically instantiated and
bound to a page template when it's rendered. In the template, the
variable <em>view</em> refers to the view instance and can be used in TAL expressions to gain things to render or loop on.</p>

<p>When dealing with a view, there are two things that make up its context - the context content object (conventionally called <em>context</em>) and the current request (conventionally called <em>request</em>). Thus, a view class is a multi-adapter from the tuple <em>(context, request)</em> to IBrowserView. As it happens, there are ZCML directives called <em>browser:page </em>and <em>browser:view</em>
that make it easier to register a view and bind a page template to it,
handle security etc. However, abstractly a view looks like this:</p>

<pre>class PersonView(object):
    implements(IBrowserView)
    adapts(IPerson, IHttpRequest)

    def __init__(self, context, request):
        self.context = context
        self.request = request

    def name(self):
        return self.context.name

    def requested_shoes(self):
        return self.request.get('requested_shoes', [])
</pre>

<p>Notice how this adapts both IPerson and IHttpRequest, and thus takes two parameters in its <em>__init__() </em>method. As you will learn later, views typically inherit the <em>BrowserView</em> base class for convenience, but the principle is the same.</p>

<p>To obtain a multi-adapter, you can't use the "calling an interface"
syntax that you use for a regular adapter. Instead, you must use the <em>getMultiAdapter() </em>method:</p>

<pre>&gt;&gt;&gt; from zope.component import getMultiAdapter
    ...
&gt;&gt;&gt; personView = getMultiAdapter((person, request,), IBrowserView)
</pre>

<p>You could use <em>queryMultiAdapter() </em>instead if you wanted it to return None instead of raise a ComponentLookupError when it fails to find the adapter.</p>

<p>The above code has a problem, however (apart from being an
incomplete example) - what if you have more than one view on the same
object, say for two different tabs? To resolve this ambiguity, views
are actually <em>named multi-adapters</em>. The names correspond to the names used as part a URL, and are registered using the <em>name</em> attribute in ZCML. This is used in <em>browser:page</em> and <em>browser:view</em> directives, but can also be used in the standard <em>adapter</em> directive:</p>

<pre>&lt;adapter factory=".sampleviews.PersonView" name="index.html" /&gt;</pre>

<p>To get this particular view, we can write:</p>

<pre>&gt;&gt;&gt; personView = getMultiAdapter((person, request,), name=u'index.html')</pre>

<p>

conventionally, we leave off the required interface when we used named adapters, although you can supply it if necessary.</p>

<p>Multi-adapters are useful for other things as well. If you have an
adapter and find that every method takes at a common parameter, it's a
good candidate for a multi-adapter. Also observe that in the case
above, we could register a different adapter for a different type of
request as well as for a different type of object. Again, the Component
Arhictecture will find the most specific one looking at both interfaces.</p>

<p>Named adapters do not have to be multi-adapters, of course. They are
typically used in cases where something (e.g. the user) is making a
selection from a set of possible choices (such as choosing the
particular view among many possible views).</p>

<h3>Utilities</h3>

<p>In the CMF, we have <em>tools</em>, which are essentially singletons. They contain various methods and attributes and may be found using the ubiquitous <em>getToolByName()</em>
function. The main problem with tools is that they live in content
space, as objects in the ZODB, and require a lot of Zope 2 specific
things.</p>

<p>Let's say we had a shoe locating service (very useful when you can't find your shoes):</p>

<pre>class IShoeLocator(Interface):
    """A service for finding your shoes
    """

    def findShoes(owner):
        """Find all shoes for the given owner.
        """

class DefaultShoeLocator(object):
    implements(IShoeLocator)
    
    def findShoes(self, owner):
        return ... 
</pre>

<p>The Component Architecture contains a very flexible <em>utility registry</em>,
which lets you look up things by interface and possibly by name. Unlike
adapters, utilities do not have context, and they are instantiated only
once, when Zope starts up. Global utilities are not persistent (but
local utilities are - see below).</p>

<p>As with adapters, we register utilities with ZCML:</p>

<pre>&lt;utility factory=".locator.DefaultShoeLocator" /&gt;
</pre>

<p>Alternatively, you could skip the <em>implements()</em> call on the
factory and set it in ZCML. This may also be necessary in order to
disambiguate if you have more than one interface being provided by the
utility component:</p>

<pre>&lt;utility 
    factory=".locator.DefaultShoeLocator" 
    provides=".interfaces.IShoeLocator
    /&gt;</pre>

<p>Now you can find the utility using <em>getUtility()</em>:</p>

<pre>&gt;&gt;&gt; from zope.component import getUtility
&gt;&gt;&gt; locator = getUtility(IShoeLocator)
&gt;&gt;&gt; locator.findShoes(u"optilude")
    ...
</pre>

<p>The utility registry turns out to be a very useful generic registry, because like the adapter registry, it can manage <em>named utilities</em>. Let's say that you had a few different shoes you wanted to keep around:</p>

<pre>&gt;&gt;&gt; left = Shoe()
&gt;&gt;&gt; right = Shoe()
    ...

&gt;&gt;&gt; from zope.component import provideUtility
&gt;&gt;&gt; provideUtility(left, name=u'left-shoe')
&gt;&gt;&gt; provideUtility(right, name=u'right-shoe')
</pre>

<p>We can now find these utilities again using the <em>name</em> argument to <em>getUtility()</em>.</p>

<pre>&gt;&gt;&gt; to_put_on = getUtility(IShoe, name=u'left-shoe')
</pre>

<p>Of course, we are still using the transient global utility registry,
so these will diseappear when Zope is restarted. We could use local
components instead (see below), or we could register them using ZCML.
If we had defined the shoes <em>left</em> and <em>right</em> in a module <em>shoes.py</em>, we could write:</p>

<pre>&lt;utility
    component=".shoes.left"
    name="left"
    /&gt;

&lt;utility
    component=".shoes.right"
    name="right"
    /&gt;
</pre>

<p>An alternative would have been to define two classes <em>LeftShoe</em> and <em>RightShoe</em> and use the <em>factory</em> attribute of the directive instead of <em>component</em> (which refers to an instance, rather than a class/factory).</p>

<h3>Local components</h3>

<p>The examples above all use global, transient registries that are
reloaded each time Zope is restarted. That is certainly what you want
for code and functionality. Sometimes, you would like for utilities to
be a bit more like their CMF cousins and also manage persistent state.
To achieve that you need to use local components, which are stored in
the ZODB.</p>

<p>Prior to Zope 3.3, which is included in Zope 2.10, local components were a bit of a black art. Then came the <em>jim-adapter</em>
branch and everything was greatly simplified. The theory is still the
same, the API is just much more sane. Each time Zope executes a request
(or if you implicitly invoke <em>zope.component.setSite()</em>, for example in a test), it discovers which is the nearest <em>site</em>
to the context. In Plone, the site is normally the root of the Plone
instance, but in theory any folder could be turned into a site.</p>

<p>A <em>site</em> has a local component registry, where local
utilities and adapters may be defined. This means that a particular
utility or adapter can be specific to a particular Plone site, not
affecting other Plone instances in the same Zope instance. You cannot
use ZCML to register local components, since ZCML is inherently global
(at least for now) - it does not know anything about your particular
sites. However, you can register them with Python code, e.g. in an
Install.py or a GenericSetup profile, using calls like <em>provideUtility()</em> (and its equivalent, <em>provideAdapter()</em>) called on a local site manager instance:</p>

<pre>&gt;&gt;&gt; from zope.component import getSiteManager

&gt;&gt;&gt; getUtility(IShoe, name=u'left-shoe) is left
True

&gt;&gt;&gt; sm = getSiteManager(context)
&gt;&gt;&gt; sm.provideUtility(myShoe, name=u'left-shoe')
&gt;&gt;&gt; getUtility(IShoe, name=u'left-shoe) is myShoe
True
</pre>

<p>Unfortunately, Plone 2.5 does not run on Zope 2.10. We won't cover
local components here, because, well, I never learnt how to do it the
Zope 2.9 way, and what I saw of it scared me. I'm told it's not that
bad, and there is documentation in <em>Five</em> and in Zope 3 itself.
Local components will become more important in Plone 3.0, where Zope
2.10 or later will be required and more things that use local
components will be part of the core.</p>

<p>b-org does not use local components yet, and we will see how the
extension mechanism would benefit from local components so that you
could have one b-org extension installed in one Plone instance and
another extension installed in another Plone instance, without the two
interfering. Luckily, to code that <em>uses</em> adapters and utilities, it is completely transparent whether they are global or local.</p>

<h3>Conclusion</h3>

<p>That's it! If you can master the concepts of interfaces, adapters
and utilities you will go far in a Zope 3 world. They will become much
more natural as you use them a few times, and you'll probably wonder
how you ever managed without them. Hopefully, that point will come
before the end of this tutorial, which is largely focused on showing
how the principle of separation of concerns can be imposed upon your
Archetypes and Plone code.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-4">

            <h1>
                2.5.5.3.
                Overview of b-org
            </h1>

            <p class="documentDescription">The big picture</p>
    
            <div>
                
                    <div><p>To the user, b-org presents itself as three content types:</p><p></p><dl><dt>Department </dt><dd>A
container for employees, and a source of groups. That is, each
department becomes a group, and the employees within that department
become group members. </dd><dt>Employee </dt><dd>Information about
employees, and a source of users. That is, each active employee object
becomes a user who can log in and interact with the portal. </dd><dt>Project </dt><dd>A
project workspace - a folder where employees can collaborate on
content. Content inside the project folder has a custom workflow, and
employees who are related to the project (by reference) have elevated
permissions over this content. </dd></dl>Out of the box, these are not
terribly interesting, because they have only the minimum of metadata
required to function. The task of providing actual schema fields, view
templates, content type names (if Department, Employee and Project are
not appropriate) and other application-specific facets is left up to
simpler third-party products that plug into b-org. One example of such
a product is included, which models a hypothetical charity use case and
is called <i>charity</i>.<br><br>This seemingly innocuous orchestration of functionality is achieved by a variety of means:<br><dl><dt>Archetypes </dt><dd>Used to build the actual content types and their schemata. </dd><dt>The Zope 3 Component Architecture </dt><dd>Is used to make all this exensibility possible - you will see lots of examples of interfaces, adapters and utilities.  <br></dd><dt>Membrane </dt><dd>The content types are registered with <i>membrane</i> to be able to act as groups and users </dd><dt>PAS and PlonePAS </dt><dd>The
Pluggable Authentication Service is used by membrane to actually
provide user sources. A custom PAS plug-in is also used to manage local
roles for members and managers within projects and departments. </dd><dt>GenericSetup </dt><dd>The next-generation set-up and installation framework is used to install and configure b-org. <i>charity</i> demonstrates how GenericSetup XML profiles can be used directly, without depending on the actual GenericSetup import mechanism.<br></dd><dt>Zope 3 events<br></dt><dd>Zope 3's event dispatch mechanism is used to ensure employee users actually own their own Employee objects, among other things.</dd><dt>Zope 3 views </dt><dd>The <i>charity</i> demo uses views for its display templates.</dd><dt>Annotations </dt><dd>Employees' passwords are hashed and stored in an annotation </dd><dt>Placeful workflow </dt><dd>To let content inside projects have a different workflow to that of the rest of the site, each project uses a <i>CMFPlacefulWorkflow</i> policy. </dd></dl><p>On
the following pages, you will learn about each of these components and
how it fits together. Meanwhile, you can follow along the code by
looking in the <a href="http://svn.plone.org/svn/collective/borg/trunk">subversion repository</a>, or getting b-org from its <a title="borg" href="http://plone.org/documentation/manual/developer-manual/products/borg">product page</a>.<br></p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-4">

            <h1>
                2.5.5.4.
                To Archetype or not to Archetype
            </h1>

            <p class="documentDescription">Archetypes
is still the most complete framework for building content types
quickly. With the advent of Zope 3, there is an alternative in Zope 3
schemas. Here's why b-org doesn't use them.</p>
    
            <div>
                
                    <div><p>There
is a growing consensus that Archetypes has grown a little too
organically. On the one hand, Archetypes has given us a lot of
flexibility, and made many of us more productive than we would ever
have thought possible (for those who remember the heady days of plain
Zope 2, and then plain CMF development). On the other hand, Archetypes
has become fairly monolithic. The reference engine, for example, is
woven tightly into the field type machinery, and the way that views are
composed from widgets makes these almost impossible to re-use outside
of Archetypes.</p><p>In practical terms, the biggest headache that
arises from Archetypes' evolution is the very same problem we
identified when introducing Zope 3 concepts - it's hard to re-use
Archetypes-based components without sub-classing and repeating a large
portion of a type's configuration. Take <a href="http://plone.org/products/poi">the Poi issue tracker</a>,
for example - I frequently get requests from people who want to add a
few use-case specific fields to each issue, or add some new
functionality such as having private issues or issues submitted on
behalf of someone else. The problem is that I don't want to put all
this functionality in Poi itself, because this would increase the
complexity of the product and thus the maintenance burden and probably
impact the intuitiveness of the UI, when in reality not everyone would
benefit from such new features.</p><p>Ideally, someone would be able to
plug in their own schema fields and add some logic in well-defined
places without having to re-invent all of Poi. However, this is
difficult, because, for example, the "add issue" button assumes you are
adding a <i>PoiIssue</i> object, which has a schema defined wholly in <i>Products/Poi/content/PoiIssue.py</i>.
There are custom form controller scripts to handle saving of issues,
and a lot of methods are found in the various content classes to do
things like send mail notifications or perform issue searches for
various lists. Again, changing the logic of who gets an email
notification or how a particular list of open issues is calculated may
involve subclassing one or all of Poi's content types, re-registering
view templates and other content type information, and possibly
customise a number of templates and scripts to reference the new
subclassed types. Of course, when Poi itself changes, keeping these
customisations up-to-date becomes difficult.</p><p>Zope 3 has, in
keeping with its philosophy, approached these problems by promising
separation of concerns. In Zope 3, you would typically define an
interface that specifies the <i>schema</i> of a content type, and then create a class that is only concerned with holding and persisting the data for this schema:</p><pre>from zope.interface import Interface<br>from zope import schema<br><br>class IIssue(Interface):<br>    """A tracker issue<br>    """<br><br>    title = schema.TextLine(title=u"The short title of this issue", required=True)<br>    severity = schema.Int(title=u"The severity of this issue", required=True, default=3)<br><br>...<br><br>from persistent import Persistent<br>from zope.interface import implements<br>class Issue(Persistent):<br>    implementS(IIssue)<br><br>    title = u""<br>    severity = 0<br></pre><p>The actual functionality for sending notifications etc would be in various adapters (e.g to <i>INotifying</i>), the view logic in views. Forms can be created from schema interfaces like <i>IIssue </i>above, using <i>zope.formlib</i>.
This can handle proper add forms (so the object is not created until
the form has been filled in, which is another headache with CMF content
types and therefore also Archetypes), validation, edit forms etc. Each
form, adapter and menu entry (for the "add" menu, say) is registered
separately, meaning that they can also be overridden and customised
separately. Rocky Burt has written an excellent tutorial on <a title="Using zope.formlib With Plone" href="http://plone.org/documentation/manual/developer-manual/archetypes/appendix-practicals/using-zope-formlib-with-plone">how to use formlib in a Plone context </a>that may be enlightening.<br></p><p>There
are voices that say we should dump Archetypes entirely in favour of
Zope 3-style content objects. Other voices (including my own) say that
this may be a bit premature. Certainly, Zope 3 schemas and content
objects are not yet fully integrated into CMF and Plone, so you end up
depending on some CMF base classes at the very least. Moreover, the
number and richness of widgets available for Zope 3 forms does not yet
match that of Archetypes. Fundamentally, Archetypes has been around for
a long time and has grown to meet a wide variety of use cases, whereas
in the context of Plone at least, Zope 3 schemas are a new kid on the
block.</p><p>The point is - Archetypes is not going to go away, not for
a long time anyway, and are still the right choice for many types of
applications. Almost all of Plone's add-on products use Archetypes, and
it is well-understood by our developer community. The more likely
scenario is that Archetypes will evolve in the same way that Zope 2 is
evolving, by seeing its internals refactored piecemeal and
pragmatically to take advantage of Zope 3 equivalents and concepts,
until theoretically an Archetypes schema and content object is just a
different spelling for what Zope 3 is doing, and Zope 3's content type
story offers the same richness as Archetypes does (and more).</p><p>In
the meantime, Archetypes is the right choice for b-org (and for other
membrane-based systems). What we will try to do, however, is to
alleviate the aforementioned problems by making use of Zope 3 design
techniques, in order to make b-org extensible and flexible.<br></p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-4">

            <h1>
                2.5.5.5.
                The extension story
            </h1>

            <p class="documentDescription">One
of the main drivers behind the componentisation of b-org is that it
should be easy to extend and customise for third party developers.
We'll take a look at how such customisations may look, before
considering how we made it possible.</p>
    
            <div>
                
                    <div><p>b-org ships with an example called <i>charity</i>, found in the <i>examples/charity</i>
directory, which demonstrates one use-case specific implementation of
b-org. This is quite simple, consisting of the following top-level
files and directories:</p><p></p><dl><dt>configure.zcml</dt><dd>Registers the schema extension adapters (see below) and references the browser package</dd><dt>Extensions/ </dt><dd>Contains an <i>Install.py</i>
script that configures the Factory Type Information for the Department,
Employee and Project content types. It does so by using GenericSetup
XML files, but invokes the import handlers explicitly rather than
through a GenericSetup profile. <br></dd><dt>Â&nbsp;browser/</dt><dd>Contains Zope 3 views for the charity department, employee and project content types, and a <i>configure.zcml</i> to register these. More on views in a later section. </dd><dt>schema/ </dt><dd>Contains adapters that extend the schemas for Departments, Employees and Projects with use-case specific fields.<br></dd></dl><p></p><p>To use <i>charity</i> you should copy or symlink it from <i>Products/borg/examples/charity </i>to <i>Products/charity</i>. It can be installed as normal, but you must install b-org first. See <i>borg/README.txt</i> for the full install instructions!<br></p><p>A key aim is to make it possible to meaningfully extend b-org without needing to subclass all its types. Of course, you <i>can</i>
do that, but in most cases it's not necessary. Unfortunately, the
mechanisms and techniques described here will be "global" in nature.
That is, you will not be able to have two different modes of
customisation for two different Plone instances in the same Zope
instance. This is because prior to Zope 2.10 (which Plone 2.5 does not
support - it wasn't out until several months after Plone 2.5 was
released), the "local" components story in Zope 3 was not fully
developed. There is also a specific problem with the way the schema
extension mechanism works which makes it inherently global. <br></p><p>When
Plone 3.0 rolls around, it will support local components much better,
and Archetypes 1.5, in conjunction with a third-party product called
ContentFlavors (or possibly another similar tool), will enable the kind
of extension story described here to work on almost any type. At that
point, the forerunner you see in b-org now will be obsolete.</p><p>Of
course, if you don't need two different b-org customisations for two
different Plone sites in the same Zope instance (which I suspect most
people can work around - having two separate Zope instances of course
isolates you from all of this), you should be fine.</p><h3>The schemas extenders</h3><p>If you look at <i>charity/configure.zcml</i> you will see the following registrations:</p><pre>Â&nbsp; &lt;adapter factory=".schema.department.DepartmentSchemaExtender" /&gt;<br>Â&nbsp; &lt;adapter factory=".schema.employee.EmployeeSchemaExtender" /&gt;<br>Â&nbsp; &lt;adapter factory=".schema.project.ProjectSchemaExtender" /&gt;</pre><p>These
schema extenders are adapters that hook into a specific part of b-org.
We will describe this in more detail later, but here is how they look
from the point of view of the extending product:</p><pre>from zope.interface import implements<br>from zope.component import adapts<br><br>from Products.Archetypes.atapi import *<br><br>from Products.borg.interfaces import IEmployeeContent<br>from Products.borg.interfaces import ISchemaExtender<br><br>CharityEmployeeSchema = Schema((<br><br>    StringField('title',<br>        accessor='Title',<br>        required=True,<br>        user_property='fullname',<br>        widget=StringWidget(<br>            label=u"Full name",<br>            description=u"Full name of this employee",<br>        ),<br><br>    ),<br><br>    StringField('email',<br>        validators=('isEmail',),<br>        required=True,<br>        searchable=True,<br>        user_property=True,<br>        widget=StringWidget(<br>            label=u"Email address",<br>            description=u"Enter the employee's email address",<br>        ),<br>    ),<br><br>    StringField('phone',<br>        required=False,<br>        searchable=True,<br>        user_property=True,<br>        widget=StringWidget(<br>            label=u"Phone number",<br>            description=u"Enter the employee's phone number",<br>        ),<br>    ),<br><br>    StringField('mobilePhone',<br>        required=False,<br>        searchable=True,<br>        user_property=True,<br>        widget=StringWidget(<br>            label=u"Mobile phone number",<br>            description=u"Enter the employee's mobile phone number",<br>        ),<br>    ),<br><br>    StringField('location',<br>        searchable=True,<br>        user_property=True,<br>        widget=StringWidget(<br>            label=u"Location",<br>            description=u"Your location - either city and country - or in a company setting, where your office is located.",<br>        ),<br>    ),<br><br>    StringField('language',<br>        user_property=True,<br>        vocabulary="availableLanguages",<br>        widget=SelectionWidget(<br>            label=u"Language",<br>            description=u"Your preferred language.",<br>        ),<br>    ),<br><br>    TextField('description',<br>        required=True,<br>        searchable=True,<br>        user_property=True,<br>        default_content_type='text/html',<br>        default_output_type = 'text/x-html-safe',<br>        allowable_content_types = ('text/html', 'text/structured', 'text/x-web-intelligent',),<br>        widget=RichWidget(<br>            label=u"Biography",<br>            description=u"Enter a short biography of the employee",<br>        ),<br>    ),<br><br>    ))<br><br>class EmployeeSchemaExtender(object):<br>    """Extend the schema of an employee to include additional fields.<br>    """<br>    implements(ISchemaExtender)<br>    adapts(IEmployeeContent)<br><br>    def __init__(self, context):<br>        self.context = context<br><br>    def extend(self, schema):<br>        schema = schema + CharityEmployeeSchema<br>        # Reorder some fields<br>        schema.moveField('description', after='mobilePhone')<br>        schema.moveField('location', before='description')<br>        schema.moveField('language', before='description')<br>        schema.moveField('roles_', after='description')<br>        return schema<br><br></pre><br><p>This example is <i>employee.py</i>.
The other extensions are simpler, and work on the exact same principle.
When calculating the schema of a content type, the b-org types (by
virtue of <i>Products.borg.content.schema.ExtensibleSchemaSupport</i>,
a mix-in class that all the b-org types uses, and which the
aforementioned changes to Archetypes should make obsolete) will look up
an adapter from the content object (which is marked with <i>IEmployeeContent</i>, in this case), to <i>ISchemaExtender</i>. This will be given the chance to extend (and modify) the schema of the type. <br></p><p>The
returned value is cached (to avoid an expensive re-calculation each
time the schema is used). This cache can be invalidated upon an event,
which you will see in <i>charity/Extensions/Install.py</i>:</p><pre>from zope.event import notify<br>from Products.borg.content.schema import SchemaInvalidatedEvent<br>from Products.borg.content.employee import Employee<br><br>...<br><br>def install(self, reinstall=False):<br>    ...<br>    notify(SchemaInvalidatedEvent(Employee))<br></pre>The event is an instance of a class that implements <i>ISchemaInvalidatedEvent</i>, and takes a class as an argument to know which class the schema is being invalidated for.<br><br><h3>Defining new views and type information<br></h3>We
have now managed to add new schema fields to Department, Employee and
Project. The auto-generated edit form will pick these up for editing,
but we probably also want some custom views. We may also want to change
other aspects of the Factory Type Information (FTI) which controls how
the type is presented within Plone's UI (an FTI is an object in <i>portal_types</i>).<br><br>First, we define some views in the <i>browser</i> package. These are described in a later section, but lookin at <i>charity/configure.zcml</i>, you will see:<br><pre>&lt;include package=".browser" /&gt;</pre>This will bring in <i>charity/browser/configure.zcml</i>, which contains several directives like:<br><pre>  &lt;page  <br>      name="charity_employee_view"<br>      for="Products.borg.interfaces.IEmployeeContent"<br>      class=".employee.EmployeeView"<br>      template="employee.pt"<br>      permission="zope2.View"<br>      /&gt;</pre>This, along with the class <i>Products.charity.browser.employee.EmployeeView </i>and the template<i> charity/browser/employee.pt</i> will make a view <i>@@charity_employee_view</i>
(the @@ is optional, but serves to disambiguate views from content
objects, for example) available on any employee (or rather, any object
providing <i>IEmployeeContent</i>).<br><br>We then need to tell Plone
that this view should be invoked when you view an Employee object or
click its 'View' tab. This is done by setting the <i>(Default)</i> and <i>view</i> method aliases for the Employee type. See <a href="http://plone.org/documentation/tutorial/richdocument/actions-and-aliases">this page of the RichDocument tutorial</a> for some background.<br><br>To achieve this, we could modify <i>portal_types/Employee</i> in Python during the <i>Install.py</i> script. However, to make it easier to define the FTI, we use a GenericSetup XML file instead. Take a look at <i>charity/Extensions/setup/types/Employee.py</i>, for example:<br><pre>&lt;?xml version="1.0"?&gt;<br>&lt;object name="Employee"<br>        meta_type="Factory-based Type Information"<br>        xmlns:i18n="http://xml.zope.org/namespaces/i18n"&gt;<br><br> &lt;property name="title"&gt;Employee&lt;/property&gt;<br> &lt;property name="description"&gt;A charity employee or volunteer.&lt;/property&gt;<br> &lt;property name="content_icon"&gt;employee.gif&lt;/property&gt;<br> &lt;property name="content_meta_type"&gt;Employee&lt;/property&gt;<br> &lt;property name="product"&gt;borg&lt;/property&gt;<br> &lt;property name="factory"&gt;addEmployee&lt;/property&gt;<br> &lt;property name="immediate_view"&gt;base_edit&lt;/property&gt;<br> &lt;property name="global_allow"&gt;False&lt;/property&gt;<br> &lt;property name="filter_content_types"&gt;False&lt;/property&gt;<br> &lt;property name="allowed_content_types" /&gt;<br> &lt;property name="allow_discussion"&gt;False&lt;/property&gt;<br><br> &lt;alias from="(Default)" to="@@charity_employee_view"/&gt;<br> &lt;alias from="view" to="@@charity_employee_view"/&gt;<br> &lt;alias from="edit" to="base_edit"/&gt;<br> &lt;alias from="properties" to="base_metadata"/&gt;<br> &lt;alias from="sharing" to="folder_localrole_form"/&gt;<br><br> &lt;action title="View" action_id="view" category="object" condition_expr=""<br>    url_expr="string:${object_url}" visible="True"&gt;<br>  &lt;permission value="View"/&gt;<br> &lt;/action&gt;<br><br> &lt;action title="Edit" action_id="edit" category="object" condition_expr=""<br>    url_expr="string:${object_url}/edit" visible="True"&gt;<br>  &lt;permission value="Modify portal content"/&gt;<br> &lt;/action&gt;<br><br> &lt;action title="Properties" action_id="metadata" category="object" condition_expr="" <br>    url_expr="string:${object_url}/properties" visible="True"&gt;<br>  &lt;permission value="Modify portal content"/&gt;<br> &lt;/action&gt;<br><br> &lt;action title="Sharing" action_id="local_roles" category="object" condition_expr="" <br>    url_expr="string:${object_url}/sharing" visible="True"&gt;<br>  &lt;permission value="Modify portal content"/&gt;<br> &lt;/action&gt;<br><br>&lt;/object&gt;<br></pre>This
defines the various aspects of the FTI, and is basically a modified
copy of the equivalent file from the b-org extension profile. You'll
learn more about these in the section on GenericSetup, but for now
observe that we invoke this explicitly in Install.py, via some
boilerplate utility code:<br><pre>from Products.charity.Extensions.utils import updateFTI<br><br>def install(self, reinstall=False):<br>    ...<br>    if not reinstall:<br>        updateFTI(self, charity, 'Department')<br>        updateFTI(self, charity, 'Employee')<br>        updateFTI(self, charity, 'Project')<br></pre>This will update the FTIs by examing <i>Products/charity/Extensions/setup/types</i>. Each file there is named corresponding to the name of the FTI it modifies.<br><br><h3>Adding new functionality<br></h3>Extending
the schema and modifying the FTI to support different views is probably
enough for a large number of use cases. If you find yourself thinking
"I wish I could add a method to the Employee class to support ...",
take your left hand, hold it out, raise you right hand and slap your
left wrist sternly, then read the section on adapters again.<br><br>For
example, let's say you wanted to send an email to administrators when a
particular button in the view was clicked. You could do that in an
adapter. For examples, in your <i>interfaces </i>module, you could could have:<br><pre>from zope.interface import Interface<br><br>class IAdministratorNagging(Interface):<br>    """Someone who will nag the admin<br>    """<br><br>    def nag(message):<br>        """Send nagging email<br>        """<br></pre><p>Then, an adapter from IEmployee in module <i>nag.py</i>:</p><pre>from zope.interface import implements<br>from zope.component import adapts<br><br>from interfaces import IAdministratorNagging<br>from Products.borg.interfaces import IEmployeeContent<br><br>from Products.CMFCore.utils import getToolByName<br><br>class NaggingEmployee(object):<br>    implements(IAdministratorNagging)<br>    adapts(IEmployeeContent)<br><br>    def __init__(self, context):<br>        self.context = context<br><br>    def nag(self, message):<br>        mailHost = getToolByName(self.context, 'MailHost')<br>        ...<br></pre><p>And finally, in your <i>configure.zcml</i>:</p><pre>&lt;adapter factory=".nag.NaggingEmployee" /&gt;<br></pre><p>Then, in the form handler that is about to nag the employee, you would do:</p><pre>from Products.myproduct.interfaces import IAdministratorNagging<br>nagger = IAdministratorNagging(employee)<br>nagger.nag("Give me more disk space!")<br></pre><p>Obviously, this is a somewhat contrived example, but hopefully you get the gist.</p><h3>Modifying workflow and other configuration<br></h3><p>The
b-org workflows are not special. In your Install.py, you could modify
them or change the workflow assignments as you would any other content
type. You can also use <i>CMFPlacefulWorkflow</i> to assign different workflows depending on context, if need be.</p><p>Similarly,
if you need to modify the behaviour of the Department, Employee and
Project types in other ways, for example by modifying settings in <i>portal_properties</i>,
you are of course free to do so. The intended pattern is that your
b-org customisation product encapsulates the various settings and
extensions that describe your use case.<br></p><h3>Changing fundamental b-org behaviour</h3><p>Lastly,
as you learn about b-org you will see how it uses adapters to hook into
membrane. If you need to override its behaviour, you can add an <i>overrides.zcml</i> to your product, which is otherwise identical to a <i>configure.zcml</i>
in format, but is able to override earlier registrations (such s those
in b-org). For example, you could override the adapter from <i>IEmployeeContent</i> to <i>IUseRelated</i> to change the way in which user ids is assigned, or the adapter to <i>IUserAuthentication</i> to change the way in which authentication is performed.<br></p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-4">

            <h1>
                2.5.5.6.
                Filesystem organisation
            </h1>

            <p class="documentDescription">b-org attempts to adhere to modern ideal about how code should be laid out on the filesystem.</p>
    
            <div>
                
                    <div><p>In the Zope 3 world, the <em>Products</em>
pseudo-namespace is frowned upon. In Zope 2, every extension module
lives in the Products/ folder. This raises some obvious namespace clash
concerns, but also separates Zope modules further from plain-Python
modules. In Zope 3, you can install a module anywhere in your <em>PYTHONPATH</em>. For example, in Plone 3.0, there will be a module called <em>plone.portlets</em>, normally installed in <em>lib/python/plone/portlets</em>.</p>

<p>For modules that need to act like Zope products (i.e. they need an <em>initialize()</em> method, they install content types, they register a GenericSetup profile or CMF skins or use an <em>Extensions/Install.py</em>
method, say), this works in Zope 2.10 and later. It can also be made to
work in earlier version of Zope using a product (ironically) called <em>pythonproducts</em>.</p>

<p>For the purposes of borg, we stick with the traditional <em>Products/</em> installation. It's nice to have imports like <em>from borg import ...</em>,
but fundamentally, b-org is very closely tied to Zope (2) and Plone, so
the re-use argument goes away, and that nice import syntax is not
really worth the extra dependency and configuration.</p>

<p>One thing you may notice, though, is that the <em>borg</em> product
is named in lowercase, in keeping with Zope 3 and Python naming
conventions. Looking inside it, you will see the following key files
and directories:</p>

<p>&nbsp;</p>

<dl><dt>__init__.py </dt><dd>Initialises the Zope 2 product machinery,
registers content types, the skin layer and the GenericSetup extension
profile that is used to install b-org.</dd><dt>config.py </dt><dd>Holds various constants </dd><dt>configure.zcml </dt><dd>Starts the Zope 3 snowball going. This references other packages with their own <em>configure.zcml </em>files. </dd><dt>content/ </dt><dd>Contains the Archetypes content types for Department, Employee and Project. Also contains some utilities, like <em>EmployeeLocator</em>, an adapter to find employees, two utilities used to provide vocabularies <em>AddableTypesProvider</em> and <em>ValidRolesProvider</em>, and the the schema extension mechanism in <em>schema.py</em>.</dd><dt>events/ </dt><dd>Contains
event subscribers which modify ownership of an Employee object so that
the employee user owns it (and can thus edit their own profiles, for
example), as well as to set up the local workflow when a Project is
created.</dd><dt>interfaces/ </dt><dd>Contains all the interfaces that b-org defines, in various sub-modules like <em>interfaces/employee.py</em> for the Employee-related interfaces. All of these are imported into <em>interfaces/__init__.py</em>, so that you can write <em>from Products.borg.interfaces import ...</em>.</dd><dt>membership/</dt><dd>Contains various adapters for plugging into membrane which enable b-orgs user-and-group functionality. </dd><dt>pas/ </dt><dd>Contains a custom PAS plug-in which is used to manage the local roles for Project members</dd><dt>permissions.py </dt><dd>Contains
custom add-content permissions, so that the ability to add Department,
Employee and Project content objects can be controlled by different
permissions.</dd><dt>profiles/ </dt><dd>Contains the GenericSetup extension profile that sets up b-org. This is registered in the <em>borg/</em>__init__.py<em>.</em> </dd><dt>setuphandlers.py </dt><dd>Defines
a custom GenericSetup "import step" which configures aspects of b-org
that cannot be expressed in the existing GenericSetup XML formats.</dd><dt>skins/ </dt><dd>Contains the borg skin layer, which is registered in <em>borg/__init__.py</em>. This contains only the b-org icons. These could potentially have been defined in a <em>browser</em>
package using Zope 3 resources, but are included in a traditional skin
layer to make them easier to customise using conventional methods. See
the section on Zope 3 views for more details.<br></dd><dt>&nbsp;tests/</dt><dd>Contains unit and integration tests. </dd><dt>zmi/ </dt><dd>Defines a ZMI page for adding the PAS plug-in, for completeness' sake. </dd></dl><p>You will notice that there are many directories, and many of these directories contain the same set of files - <em>employee.py</em>, <em>department.py</em> and <em>project.py</em>.
This is a side-effect of the finer-grained components and increased
separation of concerns that stem from Zope 3 design concepts. For
products that act less as framework, the degree of separation may be
lower, and thus the product may appear smaller. However, as you browse
b-org's source code, it should become obvious why things are placed
where they are, and how code is grouped together by logical
functionality rather than a tight coupling to Archetypes content types.</p>

<p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-4">

            <h1>
                2.5.5.7.
                Interfaces
            </h1>

            <p class="documentDescription">In
Zope 3, everything is connected to an interface in some way. Sure
enough, b-org has a slew of them. Getting the interface design right is
often more than half the battle, so pay attention to this part.</p>
    
            <div>
                
                    <div><p>If you were trying to understand b-org without a comprehensive tutorial to hand, you would do well to look at the <i>interfaces</i> package. You will notice that this is subdivided into various files</p><p></p><dl><dt>interfaces/department.py </dt><dd>Contains a description of a department (<i>IDepartment</i>) and a marker interface for the content object that stores the department (<i>IDepartmentContent</i>). </dd><dt>interfaces/employee.py </dt><dd>Contains the equivalent interfaces, <i>IEmployee</i> and <i>IEmployeeContent</i>, as well as the definition of a specific event interface, <i>IEmployeeModified.</i></dd><dt>interfaces/project.py </dt><dd>Again contains <i>IProject</i> and <i>IProjectContent</i>, as well <i>ILocalWorkflowSelection</i>, which is used to denote a utility that defines the placeful workflow policy that projects will use.</dd><dt>interfaces/workspace.py </dt><dd>Holds the interface <i>IWorkspace</i>, which is used by the local-role PAS plug-in to extract which users should have which local roles in a project. </dd><dt>interfaces/schema.py </dt><dd>Contains interfaces relevant to the custom schema extension mechanism - <i>ISchemaExtender</i>, <i>IExtensibleSchemaProvider</i> and <i>ISchemaInvalidatedEvent</i>. </dd><dt>interfaces/utils.py </dt><dd>Defines interfaces that are used as input to various vocabularies - <i>IEmployeeLocator</i>, <i>IAddableTypesProvider</i> and <i>IValidRolesProvider</i>.</dd></dl><p></p><p>In
order to understand what each of these interfaces describes in more
detail, look at the files above. Recall that interfaces are mainly
documentation - these interfaces are accompanied by docstrings and
generally self-documenting code.</p><p>The various interfaces intended for public consumption are imported to <i>interfaces/__init__</i>.py, so that client code can write, e.g.:</p><pre>from Products.borg.interfaces import IEmployee<br></pre>This is a common idiom. If you find yourself with too many interfaces to manage in <i>interfaces/__init__.py</i>, you don't necessarily need to do this, but it's probably a sign that you should be breaking your code into smaller packages! <br><br>Remember that unless you have a particular need to depend on Zope 2, then you don't need to pollute the <i>Products</i> namespace with such components! (and even if you do, with <i>PythonProducts</i>
or Zope 2.10, you can do without the Products/ namespace too). For
example, we could have placed the employee functionality in a package <i>borg.employee</i>, found in <i>lib/python/borg/employee</i> as a plain-python library, possibly depending on Zope 3 components (i.e. packages in the <i>zope.</i>* namespace).<br><br>Conversely, if you have relatively few interfaces, you can simply have an <i>interfaces.py</i> module without a directory.<br><br><h3>Separating Archetypes from real components</h3>One thing you may notice is that we have split the interface describing the concept of e.g. an employee (<i>IEmployee</i>) from the interface that describes the employee content object in the ZODB (<i>IEmployeeContent</i>). Whether this is always the right thing to do is debatable, but the reasoning goes something like this:<br><br>Archetypes objects contain a very large API. Archetypes <i>schemas</i> and the infamous <i>ClassGen</i> generate methods on the content objects corresponding to schema fields, so that a field <i>name</i> gets an accessor called <i>getName()</i> and a mutator called <i>setName()</i>. This is all rather Archetypes-specific, and in Zope 3 schemas, we typically prefer simple properties (a <i>name</i>
attribute) to pairs of methods. To avoid being constrained by the
Archetypes when defining interfaces (Archetypes is just one
implementation choice), we created <i>IEmployee</i> as follows:<br><pre>class IEmployee(Interface):<br>    """An employee, which is also a user.<br>    """<br><br>    id = schema.TextLine(title=u'Identifier',<br>                         description=u'An identifier for the employee',<br>                         required=True,<br>                         readonly=True)<br><br>    fullname = schema.TextLine(title=u'Full name',<br>                               description=u"The employee's full name for display purposes",<br>                               required=True,<br>                               readonly=True)</pre>To support this, we could put the relevant properties into the Archetypes content object, but this is cumbersome, since the <i>property()</i>
declaration normally used to convert methods to properties will only
work when those methods actually exist, not when they are created by <i>ClassGen</i>.<br><br>Instead, we mark the content object with a marker interface, <i>IEmployeeContent</i> and then register an adapter to <i>IEmployee</i>.
Strictly speaking, this is cheating, since the adapter makes
assumptions about its context (such as which methods are available, and
the fact that it uses Archetypes) that are not formally defined in the
interface. To save excessive typing and retain some sanity in the
interface definitions, it's not a terrible compromise though. Here's
the adapter, from <i>membership/employee.py</i>:<br><pre>class Employee(object):<br>    """Provide department information.<br>    """<br>    implements(IEmployee)<br>    adapts(IEmployeeContent)<br><br>    def __init__(self, context):<br>        self.context = context<br><br>    @property<br>    def id(self):<br>        return self.context.getId()<br><br>    @property<br>    def fullname(self):<br>        return self.context.Title()</pre><p>Now, you can write:</p><pre>emp = IEmployee(some_employee_content_object)<br>print emp.fullname<br></pre><p>Another
side-effect of this pattern is that we can separate things that are
Archetypes-dependent from things that operate on the more general
notion of an employee. For example, membrane generally makes
assumptions about operating on Archetypes content objects, so the
various membrane adapters adapt IEmployeeContent, whereas the view for
charity employees is only concerned with "real" employees and so adapts
the context to IEmployee.<br></p><p>This pattern is repeated for Departments and Projects as well.<br></p><h3>Interfaces intended for utilities and adapters</h3>Although
interface design should generally not be too concerned with how those
interfaces are implemented, you will often think "this is going to be
used a a utility" or "this will most likely be an adapter". In this
case, you may want to make some reference in the doc-string at least.
For example, the <i>ILocalWorkflowSelection</i> interface states:<br><pre>class ILocalWorkflowSelection(Interface):<br>    """A selection of a local workflow for projects.<br><br>    This will normally be looked up as a utility.<br>    """<br><br>    workflowPolicy = schema.TextLine(title=u'Workflow policy identifier',<br>                                    description=u'The id of the placeful workflow policy to use',<br>                                    required=True,<br>                                    readonly=True)<br></pre>Conversely,
many interfaces are context-dependent, which means that most likely
they will either be directly provided by a particular object or
adaptable to it. Take the <i>IAddableTypesProvider</i>:<br><pre>class IAddableTypesProvider(Interface):<br>    """A component capable of finding addable types in a given context.<br>    """<br><br>    availableTypes = schema.Tuple(title=u'Available types',<br>                                  description=u'A list of all addable types',<br>                                  value_type=schema.Object(ITypeInformation))<br><br>    defaultAddableTypes = schema.Tuple(title=u'Default addable types',<br>                                       description=u'A list of types to be addable by default',<br>                                       value_type=schema.Object(ITypeInformation))        <br></pre>The implication here is that client code will do something like:<br><pre>from Products.borg.interfaces import IAddableTypesProvider<br>addableTypes = IAddableTypesProvider(context).availableTypes<br></pre>Whether
IAddableTypesProvider was provided directly by the context or (more
likely) provided via an adapter is not important. The only time this
distinction is really useful is in the case of marker interfaces, such
as <i>IEmployeeContent</i>:<br><pre>class IEmployeeContent(Interface):<br>    """Marker interface for employee content objects"""<br></pre>These are often checked with <i>providedBy()</i>:<br><pre>assert IEmployeeContent.providedBy(employeeContentObject)<br># we've got an employee, good<br></pre>Again, the guiding principle here is <i>separation of concerns</i>. The aspect of a component that can provide a list of addable types (<i>IAddableTypesProvider</i>)
is logically distinct from (and could be varied independently of) the
aspect of a component that specifies it represents a project (<i>IProject</i>), even though it so happens that at present projects are the only time we concern ourselves with restricting addable types. <br><br>In the olden days, we would probably have put methods like <i>getAvailableProjectAddableTypes() </i>into the <i>Project</i>
content type. Hopefully, you'll see why this is less optimal than
having it in a separate component (hint: what if you in your
customisation of b-org wanted to be much more particular about which
types were addable?). You will hopefully start to pick up "fat"
interfaces during interface design - if you had a neat <i>IProject</i>
interface that described attributes of a project that were to be saved
alongside the project object, and then found a couple of methods about
defining addable types that were related to one another but not so much
to the data of a project in general, you would hopefully reach for a
new interface. If so - well done, you're getting there.<br></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-4">

            <h1>
                2.5.5.8.
                Test-driven development
            </h1>

            <p class="documentDescription">Testing should come first, not last, when doing development.</p>
    
            <div>
                
                    <div><p>One
of the greatest things that Zope 3 has established is a culture of
test-driven development. Because Zope 3 components tend to be small and
not dependent on a large framework or (typically) a running application
server, tests are easier to write and execute faster. Most Zope 3
testing happens in the form of testable documentation - DocTests -
which tell the story of how a component should be used along with
testable examples.</p><p>The <a href="http://plone.org/documentation/tutorial/testing">testing tutorial</a> explains the philosophy behind test-driven development and the tools and techniques available in Zope. It is <b>required reading</b> if you are not familiar with testing in Zope, and probably quite useful even if you are.</p><h3>Testing strategy</h3>Tests
were (largely) written against interfaces and stub implementations,
before the actual functionality was written. One of the first test
cases to be created was <i>test_adapters.py</i>, which simply verifies
that the various adapter registrations are in effect. This is obviously
an integration test (using PloneTestCase), since it is verifying what
happens on a "normal" Zope start-up.<br><br>You will also notice tests named after the three content types, <i>test_department.py</i>, <i>test_employee.py</i> and <i>test_project.py</i>.
Each of these contains tests that verify the given type is available
and can be instantiated and edited. This catches errors in Archetypes
registrations or schemas. There are then further tests for the <i>membrane </i>integration and for the adapters to the canonical interfaces <i>IDepartment</i>, <i>IEmployee</i> and <i>IProject</i>. Lastly, non-trivial methods in content types and relevant adapters are given their own test fixtures.<br><br>By
being systematic and diligent with tests, many, many bugs were caught
and dealt with before they ever hit a live system. Of course, this does
not replace in-browser acceptance testing, which was also performed
regularly.<br><br>At the time of writing, there are no <i>zope.testbrowser</i>
based functional tests for the user interface. That is regrettable -
and this is an open source project after all, so feel free to
contribute some!<br><br><h3>Test set-up</h3><p>You will find b-org's tests in the <i>tests</i>
module. Most of these use are DocTest integration tests, using
PloneTestCase. Make sure you use a recent version of PloneTestCase (or
svn trunk) since there have been some recent changes in how Zope 3
components (or rather, ZCML registrations) are loaded for test runs.
The upshot is that with PloneTestCase, things should "just work" for
integration testing - components you have defined in ZCML in your
products will be loaded as they would when Zope is started.</p><p>The file <i>base.py </i>contains an insulating base class for b-org tests, called <i>BorgTestCase</i> and its sister-class <i>BorgFunctionalTesetCase</i>. When imported, this file will trigger the setup of a Plone site with the <i>membrane </i>and <i>borg </i>extension profiles installed, as such:</p><pre>from Testing import ZopeTestCase<br><br># Let Zope know about the two products we require above-and-beyond a basic<br># Plone install (PloneTestCase takes care of these).<br>ZopeTestCase.installProduct('membrane')<br>ZopeTestCase.installProduct('borg')<br><br># Import PloneTestCase - this registers more products with Zope as a side effect<br>from Products.PloneTestCase.PloneTestCase import PloneTestCase<br>from Products.PloneTestCase.PloneTestCase import FunctionalTestCase<br>from Products.PloneTestCase.PloneTestCase import setupPloneSite<br><br># Set up a Plone site, and apply the membrane and borg extension profiles<br># to make sure they are installed.<br>setupPloneSite(extension_profiles=('membrane:default', 'borg:default'))</pre><h3>Integration and unit tests</h3><p>Most of the tests are integration test that are set up like so:</p><pre>import unittest<br>from Testing.ZopeTestCase import ZopeDocTestSuite<br><br>from base import BorgTestCase<br>from utils import optionflags<br><br>def test_creation():<br>    """Test that departments can be created an initiated.<br><br>    &gt;&gt;&gt; self.setRoles(('Manager',))<br>    &gt;&gt;&gt; id = self.portal.invokeFactory('Department', 'dept')<br>    &gt;&gt;&gt; dept = self.portal.dept<br><br>    Set roles.<br><br>    &gt;&gt;&gt; dept.setRoles(('Reviewer',))<br>    &gt;&gt;&gt; tuple(dept.getRoles())<br>    ('Reviewer',)<br><br>    Add an employee and set it as a manager.<br><br>    &gt;&gt;&gt; id = dept.invokeFactory('Employee', 'emp')<br>    &gt;&gt;&gt; dept.setManagers((dept.emp.UID(),))<br>    &gt;&gt;&gt; tuple(dept.getManagers())<br>    (&lt;Employee at ...&gt;,)<br>    """<br><br>...<br><br>def test_suite():<br>    return unittest.TestSuite((<br>            ZopeDocTestSuite(test_class=BorgTestCase,<br>                             optionflags=optionflags),<br>        ))<br></pre><p>There is also a plain-python (no loading of Zope necessary, which is much faster) unit test for the password digest in <i>test_passwords.py</i>.
This is appropriate because the functionality under test does not
depend on the Zope application server or database being loaded. Use
plain-python (or perhaps rather, plain Zope 3) tests whenever you can
to reduce interdependencies and test load times:</p><pre>import unittest<br><br>from zope.testing.doctestunit import DocTestSuite<br>from utils import configurationSetUp, configurationTearDown, optionflags<br><br>def test_passwords_hashed():<br>    """Check that passwords are hashed<br><br>    We expect that the password will be saved as a SHA-1 digest.<br><br>    &gt;&gt;&gt; import sha<br>    &gt;&gt;&gt; digest = sha.sha('secret').digest()<br><br>    Set a password.<br><br>    &gt;&gt;&gt; from Products.borg.content.employee import Employee<br>    &gt;&gt;&gt; e = Employee('emp')<br>    &gt;&gt;&gt; e.setPassword('secret')<br><br>    The value is stored in an annotation, and there is no direct way to<br>    access it (deliberately). Thus, check the annotation directly.<br><br>    &gt;&gt;&gt; from zope.app.annotation.interfaces import IAnnotations<br>    &gt;&gt;&gt; from Products.borg.config import PASSWORD_KEY<br>    &gt;&gt;&gt; annotations = IAnnotations(e)<br>    &gt;&gt;&gt; password = annotations[PASSWORD_KEY]<br><br>    Ensure it is what we expected:<br><br>    &gt;&gt;&gt; password == digest<br>    True<br>    """<br><br>...<br><br>def test_suite():<br>    return unittest.TestSuite((<br>            DocTestSuite(setUp=configurationSetUp,<br>                         tearDown=configurationTearDown,<br>                         optionflags=optionflags),<br>        ))</pre><p>The functions <i>configurationSetUp()</i> and <i>configurationTearDown()</i> are defined in <i>utils.py</i>
and are used to load specific ZCML files that enable the test
environment to function. This is necessary because without
PloneTestCase's integration test layer in effect, there will be no
compnent registrations when the tests are run! This may be more
cumbersome (though in reality, the same set of components tend to be
used), but also allows better control over the environment in which
test are run, in addition to (much) faster test execution times.</p><p>From <i>utils.py</i>:</p><pre>import doctest<br>from zope.app.tests import placelesssetup<br>from zope.configuration.xmlconfig import XMLConfig<br><br># Standard options for DocTests<br>optionflags =  (doctest.ELLIPSIS |<br>                doctest.NORMALIZE_WHITESPACE |<br>                doctest.REPORT_ONLY_FIRST_FAILURE)<br><br><br>def configurationSetUp(self):<br>    """Set up Zope 3 test environment<br>    """<br><br>    placelesssetup.setUp()<br><br>    # Ensure that the ZCML registrations in membrane and borg are in effect<br>    # Also ensure the Five directives and permissions are available<br><br>    import Products.Five<br>    import Products.membrane<br>    import Products.borg<br><br>    XMLConfig('configure.zcml', Products.Five)()<br>    XMLConfig('meta.zcml', Products.Five)()<br><br>    XMLConfig('configure.zcml', Products.membrane)()<br>    XMLConfig('configure.zcml', Products.borg)()<br><br>def configurationTearDown(self):<br>    """Tear down Zope 3 test environment<br>    """<br><br>    placelesssetup.tearDown()</pre><p>You will also find a regular unit test in <i>test_setup.py</i>, simply because this was quicker to write:</p><pre>from base import BorgTestCase<br><br>from Products.membrane.interfaces import ICategoryMapper<br>from Products.membrane.config import ACTIVE_STATUS_CATEGORY<br>from Products.membrane.utils import generateCategorySetIdForType<br><br>from Products.borg.config import LOCALROLES_PLUGIN_NAME, PLACEFUL_WORKFLOW_POLICY<br><br>class TestProductInstall(BorgTestCase):<br><br>    def afterSetUp(self):<br>        self.types = ('Department', 'Employee', 'Project',)<br><br>    def testTypesInstalled(self):<br>        for t in self.types:<br>            self.failUnless(t in self.portal.portal_types.objectIds(),<br>                            '%s content type not installed' % t)<br><br>    ...<br><br>def test_suite():<br>    from unittest import TestSuite, makeSuite<br>    suite = TestSuite()<br>    suite.addTest(makeSuite(TestProductInstall))<br>    return suite<br></pre><p>Finally, there is an docstring DocTest for the <i>ExtensibleSchemaSupport </i>class.
This is because this class if largely standalone (it probably shouldn't
be b-org at all, but in a more general module, except Archetypes will
gain similar functionality of its own for Plone 3.0) and the test
provided important documentation in the class' docstring.</p><p>The class looks like this:</p><pre>class ExtensibleSchemaSupport(Base):<br>    """Mixin class to support instance-based schemas.<br><br>    Note: you must mix this in before BaseFolder or BaseContent, e.g.:<br><br>    class Foo(ExtensibleSchemaSupport, BaseContent):<br>        ...<br><br>    This is based on Archetype's VariableSchemaSupport.<br><br>    Define a content type with a marker interface:<br><br>    &gt;&gt;&gt; from zope.interface import Interface, implements<br>    &gt;&gt;&gt; class IMyType(Interface):<br>    ...     pass<br><br>    &gt;&gt;&gt; from Products.Archetypes.atapi import *<br>    &gt;&gt;&gt; from Products.borg.content.schema import ExtensibleSchemaSupport<br>    &gt;&gt;&gt; class MyType(ExtensibleSchemaSupport, BaseObject):<br>    ...     implements(IMyType)<br>    ...     schema = BaseSchema.copy() + Schema((StringField('foo'),))<br>    &gt;&gt;&gt; registerType(MyType, 'testing')<br><br>    Create a schema extender:<br><br>    ...<br><br>    """<br>    implements(IExtensibleSchemaProvider)<br><br>    ...<br></pre><p>And the test runner, in <i>test_schema.py</i>, contains:</p><pre>import unittest<br>from Testing.ZopeTestCase import ZopeDocTestSuite<br><br>from base import BorgTestCase<br>from utils import optionflags<br><br>def test_suite():<br>    return unittest.TestSuite((<br>            ZopeDocTestSuite('Products.borg.content.schema',<br>                             test_class=BorgTestCase,<br>                             optionflags=optionflags),<br>        ))</pre></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-4">

            <h1>
                2.5.5.9.
                Setup using GenericSetup
            </h1>

            <p class="documentDescription">b-org uses GenericSetup to impose itself on your Plone instance. Here's how it works.</p>
    
            <div>
                
                    <div><p>Hands up if you have ever written a workflow definition in Python and tried to figure out how to install it in your <i>Extensions.py</i>
and thought, this is the least useful API I have ever had to deal with.
Actually, the API is not that bad, it's just not very good for
performing set-up. Similarly, it may start to make your
separation-of-concerns-brainwashed mind a little uneasy that we tend to
define aspects of the type's configuration as class attributes in an
Archetypes class (though of course it's better than using a CMF FTI
dict or mangling <i>portal_types</i> directly).</p><p>The fine folks who gave us the CMF came up with another way, called <i>GenericSetup</i> (after a few name changes - you may see the names <i>CMFSetup</i> and <i>ContentSetup</i>
as well, which refer to predecessors of what is not GenericSetup). This
is based on a declarative XML syntax that can represent site
configuration. The configuration of an entire site is called a <i>profile</i>
and can be imported and exported to replicate state across multiple
Plone (or CMF) sites. There is a smaller version of a profile called an
<i>extension profile</i> which can be used to extend a base profile. Both membrane and b-org use extension profiles to install themselves.</p><p>GenericSetup is described a <a href="http://plone.org/documentation/tutorial/understanding-and-using-genericsetup-in-plone">tutorial</a>
by Rob Miller, cheif GenericSetup protagonist, so we won't repeat too
much of the detail here. However, you should be aware that in Plone
2.5, GenericSetup has a slightly awkward user experience and does not
have any well-defined way of performing uninstall, which stems from the
fact that it was originally designed for the use case of taking a
snapshot of the configuration of an entire site, not for installing and
uninstalling products and extensions!</p><p>The other main shortcoming
at the moment is that there is no way to specify interdependencies
between profiles. It is important that membrane is installed before
b-org, but if you're not careful it will happen the other way around.
When you create a Plone site, you will be able to choose a number of
extension profiles to apply (including meaningless ones like <i>Archetypes</i>
- meaningless because Plone already invokes those when you set up a
site). In this list, "Base organisation" comes before "membrane" by
virtue of alphabetical sorting. Therefore, you can't just choose both
and click "Add". Instead, you should select "membrane" first, and then
add "Base organisation" via portal_setup, as described in the b-org <i>README.txt:</i></p><ol><li>Go to <i>portal_setup</i> in the ZMI</li><li>Click the <i>Properties</i> tab</li><li>Select
"Base organisation" as the active profile (since this is an extension
profile, it won't override the base profile that set up your Plone
site) and click <i>Update</i>.<br></li><li>Go to the <i>Import</i> tab and click <i>Import all steps</i>
at the bottom. Note that although it seems like this will re-install a
whole bunch of stuff, it will only execute those steps that are
actually listed in the <i>import_steps.xml</i> for the <i>active profile</i>, which in this case is b-org's.<br></li></ol><br>If
you didn't already set up membrane and you created a Plone site without
the membrane extension profile, follow the same steps to install
membrane <i>before</i> you install b-org.<br><br>So why did we do all
this? Firt of all, both membrane and b-org are really infrastructure
that fundamentally influence how you build your site, so the lack of
uninstall isn't as bad as it would have been for more user-facing
products. Secondly, with Plone 3.0, this will become easier, as the
QuckInstaller (and hence the <i>Add/Remove Products</i> control panel page) becomes Extension Profile aware and gives some uninstall support.<br><br>At the end of this section, you will see how you can use a traditional QuickInstaller <i>Install.py</i> method and still get the nice XML syntax, with a bit of extra work.<br><br><h3>Import steps</h3><p>To GenericSetup, the installation of a third party product via an extension profile is considered to be the <i>importing</i> of that profile. A file <i>import_steps.xml</i>
is used to determine which actual import steps will be executed. First,
we need to tell GenericSetup where the import steps are defined,
though, by registering the extension profile. This is done in the
product's <i>__init__.py</i>:</p><pre>from Products.CMFPlone.interfaces import IPloneSiteRoot<br>from Products.GenericSetup import EXTENSION, profile_registry<br><br>...<br><br>def initialize(context):<br>    ...<br>    profile_registry.registerProfile('default',<br>                                     'Base organisation',<br>                                     'Organisation and project infrastructure',<br>                                     'profiles/default',<br>                                     'borg',<br>                                     EXTENSION,<br>                                     for_=IPloneSiteRoot)<br></pre><p>This references the directory <i>profiles/default</i>, which contains various files:</p><p></p><dl><dt>import_steps.xml </dt><dd>Lists the steps to be performed during import (set-up) </dd><dt>export_steps.xml </dt><dd>Lists
the steps to be performed during export - that is, if the configuration
is changed in the ZODB and the site admin wishes to export the
configuration to a file, these steps will be performed. </dd><dt>membrane_tool.xml </dt><dd>Configuration for membrane tools </dd><dt>skins.xml </dt><dd>Sets up skins in portal_types </dd><dt>types.xml </dt><dd>Configures
FTIs (Factory Type Information settings) for the content types that
b-org ships with. Each of the types listed here has a corresponding
file in <i>profiles/default/types</i> (the name of the type and the
name of the file should match). This file contains all the various FTI
settings, such as friendly name, meta type, actions and aliases. </dd><dt>workflows.xml </dt><dd>Configures workflows. This works in the same way as <i>types.xml</i>
- the main file configures the names of the workflows and the bindings
of workflows to content types. The actual workflow definitions,
including states and transitions, are found in <i>profiles/default/workflows</i>.<br></dd></dl>The <i>import_steps.xml</i> which orchistrates all this looks like follows:<p></p><pre>&lt;?xml version="1.0"?&gt;<br>&lt;import-steps&gt;<br>  &lt;import-step id="borg_various" version="20060803-01"<br>               handler="Products.borg.setuphandlers.importVarious"<br>               title="Various base-org Settings"&gt;<br>    &lt;dependency step="typeinfo"/&gt;<br>    &lt;dependency step="skins"/&gt;<br>    &lt;dependency step="workflow"/&gt;<br> &lt;/import-step&gt;<br>&lt;/import-steps&gt;<br></pre>Note that we don't actually specify most of the files - they are referenced by the <i>base profile</i>
that was used to set up Plone or the extension profile for membrane.
GenericSetup knows all the registered profiles' steps, and looks for
the corresponding files.<br><br><h3>Various setup handlers</h3><p>The
one setup handler you do see is the "various" handler. This is
dependent on the set-up of type info, skins and workflow. Ordinarily,
setup handlers will utilise GenericSetup base classes, adapters and
utility functions to parse XML files. However, it's not always
convenient to invent a generic XML syntax for all types of
configuration. The <i>importVarious</i> pattern is used by many
products that need to perform some custom set-up in Python. It is
invoked as if it were a handler for an XML file, but it just happens to
have different side-effects. The main caveat with this type of set-up,
of course, is that it cannot symmetrically export (and then re-import)
the configuration, and it is more difficult to re-use.</p><p><i>importVarious</i> looks as follows:</p><pre>from StringIO import StringIO<br><br>...<br><br>def setupPlugins(portal, out):<br>    """Install and prioritize the project local-role PAS plug-in.<br>    """<br><br>    ...<br><br>def setupPortalFactory(portal, out):<br>    """Add borg types to portal_factory<br>    """<br><br>    ...<br><br>def addProjectPlacefulWorkflowPolicy(portal, out):<br>    """Add the placeful workflow policy used by project spaces.<br>    """<br><br>    ....<br><br>def importVarious(context):<br>    """<br>    Import various settings.<br><br>    Provisional handler that does initialization that is not yet taken<br>    care of by other handlers.<br>    """<br>    site = context.getSite()<br>    out = StringIO()<br><br>    setupPlugins(site, out)<br>    setupPortalFactory(site, out)<br>    addProjectPlacefulWorkflowPolicy(site, out)<br><br>    logger = context.getLogger("borg")<br>    logger.info(out.getvalue())</pre><p>We set up the PAS plugins, register our types with <i>portal_factory </i>and
add a placeful workflow policy. The exact code to perform each of these
steps is not listed here to save space, but they use the same
techniques you would use in an <i>Install.py</i> file. Note that the <i>portal_factory</i> setup is available in a more friendly XML format in Plone 2.5.1 and later, which was released after b-org.<br></p><h3>GenericSetup without portal_setup</h3>When Plone 3.0 arrives, it will make the <i>Add/Remove Products</i>
control panel aware of extension profiles, and thus provide a more user
friendly way of performing install using GenericSetup. It will also
support uninstall. Until that time, however, it is possible to re-use
the GenericSetup XML handlers to parse files like <i>types.xml</i>Â&nbsp; and <i>workflow.xml</i> from a regular <i>Install.py</i> installation. We do this in the <i>charity</i> example.<br><br>When importing, GenericSetup requires a setup environment, and usually an object to work on. A simple <i>SetupEnviron</i> is found in <i>charity/Extensions/utils.py</i>, along with a method called <i>updateFTI()</i> which can take an FTI object and update its settings based on a <i>types.xml</i>-like file. This method takes a module and the id of an FTI to update, and finds the corresponding file.<br><br>It is used in <i>charity/Extensions/Install.py</i> as follows:<br><pre>from Products import charity<br><br>from Products.charity.Extensions.utils import updateFTI<br><br>def install(self, reinstall=False):<br><br>    ...    <br><br>    if not reinstall:<br>        updateFTI(self, charity, 'Department')<br>        updateFTI(self, charity, 'Employee')<br>        updateFTI(self, charity, 'Project')<br></pre><br>The relevant files may be found in <i>charity/Extensions/setup/types/</i>.<br></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-4">

            <h1>
                2.5.5.10.
                Using membrane to provide membership behaviour
            </h1>

            <p class="documentDescription">How b-org uses membrane to let employees be users and departments be groups</p>
    
            <div>
                
                    <div><p>Since
version 2.5, the user management infrastructure in Plone has been
replaced by PAS, the Zope Pluggable Authentication Service, and
PlonePAS, a Plone integration layer for this. PAS offers several
advantages over plain user folders, mainly in terms of flexibility.
Unfortunately, it is also more difficult to work with through-the-web
and has a very decentralised API, based on the notion of plugin
components, that can be difficult to understand at first.</p><p>Membrane (or rather, <i>membrane</i>
with a lowercase m) is a component first developed by Plone Solutions
and later improved by Rob Miller and others. It is similar to <i>CMFMember</i>
in that it can turn content objects into users, although it is less
concerned with replicating existing Plone functionality and more
concerned with making a thin integration layer to plug into. It
therefore fits b-org very well.</p><p>Membrane works on Archetypes objects (though theoretically it could be used with other objects as well). It adds a tool called <i>membrane_tool</i>
which contains a registry of content types that are member- or
group-sources, as well as a special catalog. Using the Archetypes
catalog multiplex, it is able to catalog objects (which may also be
cataloged in <i>portal_catalog</i>) and find them again based on
various interfaces (that is, it catalogs the interfaces provided by an
object). membrane provides a number of PAS plug-ins that will search
this catalog when looking for users and delegate to the content objects
(or rather, adapters on the content object) for obtaining user
information, performing authentication and so on.</p><h3>Registering with membrane</h3><i>membrane_tool</i>
contains an API for registering content types as membership providers,
but the easiest option is to use a GenericSetup profile (see the
section on GenericSetup for the full story). In <i>profiles/default/membrane_tool.xml</i>, you will find:<pre>&lt;?xml version="1.0"?&gt;<br>&lt;object name="membrane_tool" meta_type="MembraneTool"&gt;<br>  &lt;membrane-type name="Department"&gt;<br>    &lt;active-workflow-state name="active" /&gt;<br>  &lt;/membrane-type&gt;<br>  &lt;membrane-type name="Employee"&gt;<br>    &lt;active-workflow-state name="active" /&gt;<br>  &lt;/membrane-type&gt;<br>  &lt;membrane-type name="Project"&gt;<br>    &lt;active-workflow-state name="published" /&gt;<br>    &lt;active-workflow-state name="private" /&gt;<br>  &lt;/membrane-type&gt;<br>&lt;/object&gt;<br></pre>This
registers the three content types (by their portal type), and specifies
the workflow states in which they are "active" as member and group
sources.<br><br><h3>Applying marker interfaces</h3>When looking for
content objects that provide group and member information, membrane
will use a number of marker interfaces that indicate support for
various types of behaviour. These are implemented by the three content
type classes.<br><br>In <i>content/department.py</i>, you will find:<br><pre>from Products.membrane.interfaces import IPropertiesProvider<br><br>...<br><br>class Department(ExtensibleSchemaSupport, BaseFolder):<br>    """A borg department.<br><br>    Departments can contain other employees.<br>    """<br><br>    implements(IDepartmentContent, IPropertiesProvider)<br></pre>All
this means is that the Department's schema is capable of providing
properties to PAS. Properties (normally related to users, but groups
can have properties as well) are just metadata about the user or group.
Membrane supports as PAS properties plugin that will look for
Archetypes schema fields with <i>member_property=True</i> set and report these back as user properties. Although <i>Department</i>
does not use any such properties at the moment, we add this marker so
that extension modules that use the schema extension mechanism can
benefit from this.<br><br>The equivalent setup for Employees, in <i>content/employee.py</i>, is a little more interesting.<br><pre>from Products.membrane.interfaces import IUserAuthProvider<br>from Products.membrane.interfaces import IPropertiesProvider<br>from Products.membrane.interfaces import IGroupsProvider<br>from Products.membrane.interfaces import IGroupAwareRolesProvider<br><br>...<br><br>class Employee(ExtensibleSchemaSupport, BaseContent):<br>    """A borg employee.<br><br>    Employees are also users.<br>    """<br><br>    implements(IEmployeeContent,<br>               IUserAuthProvider,<br>               IPropertiesProvider,<br>               IGroupsProvider,<br>               IGroupAwareRolesProvider, <br>               IAttributeAnnotatable)<br></pre>Here, we are saying that:<br><ul><li>An Employee can be used as a source of authentication (i.e. as a user), since it is marked with <i>IUserAuthProvider</i>. Note that the actual authentication is performed by a different adapter.</li><li>An Employee can provide user properties to PAS via membrane, following <i>IPropertiesProvider</i>.<br></li><li>An Employee can be part of a group, because of <i>IGroupsProvider</i>.<br></li><li>An employee can be given roles. There is an <i>IRolesProvider</i> interface that we cold use for basic role awareness. The <i>IGroupAwareRolesProvider</i> is a sub-interface that will cause membrane to also look at the user's groups.</li></ul>The <i>IAttributeAnnotatable </i>interface is part of Zope 3's annotations framework, discussed in a later section.<br><br>Projects does not require any particular marker interfaces.<br><br><h3>Providing membership behaviour</h3>When
membrane looks for objects to provide membership-related behaviour, it
will not only look for objects directly providing a particular
interface, but also for objects that can be <i>adapted to</i> that interface. For example, the presence of the interface <i>IGroup</i> informs membrane that an object can act as a group, and contains methods that describe the members of that group. <br><br>Of course, we could have declared that <i>Department</i> implemented <i>IGroup</i>
and written these methods directly in the Department content object.
Hopefully you'll agree now that this would not be optimal, since it
mixes the content-object aspect and the group-behaviour aspect of
Department into a single monolithic object. Instead, we will use an
adapter, which also means that if you require different behaviour in an
extension to b-org, you have only to override the adapter, leaving the
core content object alone.<br><br>In <i>membership/department.py</i>, you will see:<br><pre>class Group(object):<br>    """Allow departments to act as groups for contained employees<br>    """<br>    implements(IGroup)<br>    adapts(IDepartmentContent)<br><br>    def __init__(self, context):<br>        self.context = context<br><br>    def Title(self):<br>        return self.context.Title()<br><br>    def getRoles(self):<br>        """Get roles for this department-group.<br><br>        Return an empty list of roles if the department is in a workflow state<br>        that is not active in membrane_tool.<br>        """<br>        mb = getToolByName(self.context, MEMBRANE_TOOL)<br>        wf = getToolByName(self.context, 'portal_workflow')<br><br>        reviewState = wf.getInfoFor(self.context, 'review_state')<br>        wfmapper = ICategoryMapper(mb)<br>        categories = generateCategorySetIdForType(self.context.portal_type)<br>        if wfmapper.isInCategory(categories, ACTIVE_STATUS_CATEGORY, reviewState):<br>            return self.context.getRoles()<br>        else:<br>            return ()<br><br>    def getGroupId(self):<br>        return self.context.getId()<br><br>    def getGroupMembers(self):<br>        mt = getToolByName(self.context, MEMBRANE_TOOL)<br>        usr = mt.unrestrictedSearchResults<br>        members = {}<br>        for m in usr(object_implements=IMembraneUserAuth.__identifier__,<br>                     path='/'.join(self.context.getPhysicalPath())):<br>            members[m.getUserId] = 1<br>        return tuple(members.keys())</pre>Mostly,
this is about examining the Department content object to find roles
(which are listed in an Archetypes field, editable by the Manager
role). When calculating roles, we make sure that we don't give roles if
the Department group-source is actually disabled (by virtue of its
workflow state and the settings in membrane_tool). The group title and
id are taken from the object as well.<br><br>The most interesting method is <i>getGroupMembers()</i>. Here, we perform a search in the <i>membrane_tool</i> catalog for objects adaptable to<i> IMembraneUserAuth</i>. This interface is the basic interface in membrane describing things that can act as users - there is an adapter from <i>IUserAuthProvider</i> to <i>IMembraneUserAuth</i>.
We restrict this to objects inside the Department object. The net
effect is that all Employee objects inside the Department are returned.<br><br>Now,
let's say you had a need for a Department which in addition to acting
as a group for all members inside it, also allowed some members from
other departments to be in that group. In this case, you could use a
schema extender to add a <i>ReferenceField</i> to the schema of
Department that allowed the Department owner to reference other
Employees. You would then provide an override adapter, perhaps
subclassing <i>Products.borg.membership.department.Group</i> but overriding <i>getGroupMembers()</i> to append the ids of the referenced users as well as the contained ones ... or instead of, depending on your needs.<br><br>As
it happens, Projects also act as groups, with members being assigned by
reference, using two reference fields - one for project members, and
one for project manangers. Here is the equivalent adapter from <i>membership/project.py</i>:<br><pre>class Group(object):<br>    """Allow projects to be groups for related members and managers<br>    """<br>    implements(IGroup)<br>    adapts(IProjectContent)<br><br>    def __init__(self, context):<br>        self.context = context<br><br>    def Title(self):<br>        return self.context.Title()<br><br>    def getRoles(self):<br>        # The project does not imply any special roles *globally*, although<br>        # the IWorkspace adapter above enables some local roles<br>        return ()<br><br>    def getGroupId(self):<br>        return self.context.getId()<br><br>    def getGroupMembers(self):<br>        return [IUserRelated(m).getUserId() for m in<br>                                 self.context.getRefs(PROJECT_RELATIONSHIP) +<br>                                 self.context.getRefs(PROJECT_MANAGER_RELATIONSHIP)]</pre>As may be expected, the membrane adapters for <i>Employee</i> are a bit more involved. They consist of the following:<br><dl><dt>IUserRelated adapter</dt><dd>Provides
a user id for employees. Note that user ids and user names are possibly
different when PAS is used: the user id must be globally unique; the
user name is the named used for logging in. </dd><dt>IUserAuthentication adapter </dt><dd>Used to perform actual authentication by validating a supplied username and password.<br></dd><dt>IUserRoles adapter</dt><dd>Used to determine which roles the particular user is given. </dd><dt>IMembraneUserManagement </dt><dd>Used
by membrane and Plone's UI to deal with changes to the user, such as
the adding of a new user (not implemented here, since we </dd></dl>All these adapters are found in <i>membership/employee.py</i>. <br><br>The <i>IUserRelated</i> adapter is the simplest, as it simply invokes the user name. Note that by default, membrane will use the Archetypes <i>UID() </i>function
as the user id. This is sensible, but unfortunately Plone's UI (and
that of third party products) is not always aware of the distinction
between user id and user name. Ideally, only the user name would ever
be displayed, the user id being an internal concept, but in practice
you may end up with things like member folder names that are long,
unfriendly UID strings. Sometimes this may even be unavoidable in the
general case, because it's possible that two different sources of users
could use the same user name for two different user ids! For the
purposes of b-org, however, we assume user names are unique and
well-defined. The adapter is therefore quite trivial:<br><pre>class UserRelated(object):<br>    """Provide a user id for employees.<br><br>    The user id will simply be the id of the member object. This overrides the<br>    use of UIDs<br>    """<br>    implements(IUserRelated)<br>    adapts(IEmployeeContent)<br><br>    def __init__(self, context):<br>        self.context = context<br><br>    def getUserId(self):<br>        return self.context.getId()</pre>The
id of the content object that represents the employee is used as the
user id. This is also used as the user name, as defined in the <i>IUserAuthentication </i>adapter:<br><pre>class UserAuthentication(object):<br>    """Provide authentication against employees.<br>    """<br>    implements(IUserAuthentication)<br>    adapts(IEmployeeContent)<br><br>    def __init__(self, context):<br>        self.context = context<br><br>    def getUserName(self):<br>        return self.context.getId()<br><br>    def verifyCredentials(self, credentials):<br>        login = credentials.get('login', None)<br>        password = credentials.get('password', None)<br><br>        if login is None or password is None:<br>            return False<br><br>        digest = sha(password).digest()<br><br>        annotations = IAnnotations(self.context)<br>        passwordDigest = annotations.get(PASSWORD_KEY, None)<br><br>        return (login == self.getUserName() and digest == passwordDigest)</pre>In the <i>verifyCredentials()</i> method, the adapter is passed the login and password as entered by the user in a dict (<i>credentials</i>)
and then compares those to the values stored on its context (the
Employee content object). The password is stored as a SHA1 digest in an
annotation to make sure it cannot be read back by examining the content
object - more on this in the section on annotations. Be aware also that
the <i>IUserAuthentication</i> adapter is called on every request
after a user is logged in and can deny access for whatever reason by
returning non-True. This means that it is important that the method is
as efficient as possible - expensive database lookups, for example, are
probably not a good idea here!<br><br>The <i>IUserRoles</i> adapter is
trivial. Roles are stored on the content object in a field that is
editable only by managers. Of course, we could have picked roles from
some other rule if necessary:<br><pre>class UserRoles(object):<br>    """Provide roles for employee users.<br><br>    Roles may be set (by sufficiently privilged users) on the user object.<br>    """<br>    implements(IUserRoles)<br>    adapts(IEmployeeContent)<br><br>    def __init__(self, context):<br>        self.context = context<br><br>    def getRoles(self):<br>        return self.context.getRoles()</pre>The <i>getRoles()</i> method returns an iterable of strings representing applicable roles. Note that depending on group membership (and the <i>IGroupAwareRolesProvider</i> marker as described above) and local roles the user may in fact have more roles than what this method returns! The <i>IUserRoles</i> interface is concerned only with global roles intrinsic to the user.<br><br>Finally, we have the <i>IMembraneUserManagement</i> adapter. This lets membrane know what to do when it is asked by Plone's UI to add, edit or remove users. In particular, the <i>doChangeUser()</i> method enables the <i>PasswordResetTool</i> to do its magic. Note that we have not implemented <i>doAddUser()</i>, because there is no well-defined global policy for where the actual <i>Employee</i> content object should be added! Recently membrane has gained some functionality whereby a site-local utility providing <i>IUserAdder</i><i> </i>from
membrane can be queried for this policy. That may be useful for b-org
extension products, but b-org is still not in a position to make a
general policy for this, so it is not implemented out of the box.<br><pre>class UserManagement(object):<br>    """Provides methods for adding deleting and changing users<br><br>    This is an implementation of IUserManagement from PlonePAS<br>    """<br>    implements(IMembraneUserManagement)<br>    adapts(IEmployeeContent)<br><br>    def __init__(self, context):<br>        self.context = context<br><br>    def doAddUser(self, login, password):<br>        """This can't be done unless we have a canonical place to store users<br>        some implementations may wish to define one and implement this.<br>        """<br>        raise NotImplementedError<br><br>    def doChangeUser(self, login, password, **kw):<br>        self.context.setPassword(password)<br>        if kw:<br>            self.context.edit(**kw)<br><br>    def doDeleteUser(self, login):<br>        parent = aq_parent(aq_inner(self.context))<br>        parent.manage_delObjects([self.context.getId()])<br></pre><p>That's
it! Through these adapters, the three b-org content types are able to
act as sources of groups and users. Hopefully, you will appreciate the
flexibility of the separation of concerns into adapters for things like
editing user properties, determining user id, calculating roles and
performing authentication. If you extend b-org, you can provide a more
specific adapter to any of the above interfaces to customise the
membership behaviour.<br></p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-4">

            <h1>
                2.5.5.11.
                Writing a custom PAS plug-in
            </h1>

            <p class="documentDescription">Projects
require that members are given particular local roles within a project
space. This is achieved using a custom PAS plug-in.</p>
    
            <div>
                
                    <div><p>PAS was introduced in the previous section on <i>membrane</i>.
Truth be told, it can be a bit of a jungle of plug-ins and delegation
because it is so very generic. Luckily, Plone (and membrane) takes care
of most of the complexity for us. Sometimes, however, it is desirable
to influence the authentication and role management at a lower level.<br><br></p><h3>Workspace adapters</h3>b-org ships with a bit of framework, adapted from some similar code in an unreleased version of <i>teamspace</i> by Wichert Akkerman, which can provide local roles in a "workspace" - in this case a Project. It relies on an adapter to the <i>IWorkspace</i>
interface to determine the mapping of users and roles in the particular
context. Before showing how this plug-in is written and registered,
however, let's look at how it is used by a Project.<br><br>In <i>membership/project.py</i> you will find:<br><pre>class LocalRoles(object):<br>    """Provide a local role manager for projects<br>    """<br>    implements(IWorkspace)<br>    adapts(IProjectContent)<br><br>    def __init__(self, context):<br>        self.context=context<br><br>    def getLocalRoles(self):<br>        project = IProject(self.context)<br>        roles = {}<br>        for m in project.getManagers():<br>            roles[m.id] = ('Manager',)<br>        for m in project.getMembers():<br>            if m.id in roles:<br>                roles[m.id] += ('TeamMember',)<br>            else:<br>                roles[m.id] = ('TeamMember',)<br>        return roles<br><br>    def getLocalRolesForPrincipal(self, principal):<br>        r = self.getLocalRoles()<br>        return r.get(principal, ())<br></pre>This
queries the lists of managers and members assigned (by reference) to
the project and specifies that both managers and members should get the
role <i>TeamMember</i> and managers should also get the role <i>Manager</i>.<br><br>As
it turns out, this behaviour is also useful in Departments, which can
be given one or more department managers by reference. The idea is that
department managers should be allowed to add and remove Employees
within that Department (recall that <i>Department</i> is a folderish container for <i>Employee</i> objects). The analogous adapter in <i>membership/department.py</i> reads:<br><pre>class LocalRoles(object):<br>    """Provide a local role manager for departments<br>    """<br>    implements(IWorkspace)<br>    adapts(IDepartmentContent)<br><br>    def __init__(self, context):<br>        self.context = context<br><br>    def getLocalRoles(self):<br>        project = IDepartment(self.context)<br>        roles = {}<br>        for m in project.getManagers():<br>            roles[m.id] = ('Manager',)<br>        return roles<br><br>    def getLocalRolesForPrincipal(self, principal):<br>        r = self.getLocalRoles()<br>        return r.get(principal, ())</pre>Thus, a container wanting to use the PAS plug-in we're about to see to manage local roles only need to be adaptable to <i>IWorkspace</i>. In fact, this whole machinery ought to be factored out into a separate component, possibly sharing code to <i>teamspace</i>,
another product which provides similar functionality. Mostly, this is
down to laziness - creating another product (with all its boilerplate)
and managing another dependency in the <i>Products</i> folder seemed
too onerous when b-org was being developed. Hopefully, with Zope
2.10/Plone 3.0 and a growing preference for plain-Python packages and
"eggs", it will seem a little less of an obstacle to split products up
into multiple smaller pieces. So much for making excuses.<br><br><h3>The plug-in</h3>The PAS plug-in that uses the <i>IWorkspace</i> interface can be found in <i>pas/localrole.py</i>. It looks like this:<br><pre># Borrowed from Project pasification branch - written primarily by<br># Wichert Akkerman and Copyright Amaze Internet Services<br><br># This module is releasd under the Zope Public License<br><br>from sets import Set<br><br>from Globals import InitializeClass<br>from Acquisition import aq_inner, aq_chain, aq_parent<br>from AccessControl import ClassSecurityInfo<br>from Products.PageTemplates.PageTemplateFile import PageTemplateFile<br><br>from Products.PluggableAuthService.utils import classImplements<br>from Products.PluggableAuthService.plugins.BasePlugin import BasePlugin<br>from Products.PlonePAS.interfaces.plugins import ILocalRolesPlugin<br><br>from Products.borg.interfaces import IWorkspace<br><br>manage_addWorkspaceLocalRoleManagerForm = PageTemplateFile(<br>        "../zmi/WorkspaceLocalRoleManagerForm.pt", globals(),<br>        __name__="manage_addProjectRoleManagerForm")<br><br>def manage_addWorkspaceLocalRoleManager(dispatcher, id, title=None, REQUEST=None):<br>    """Add a WorkspaceLocalRoleManager to a Pluggable Authentication Services."""<br>    plrm = WorkspaceLocalRoleManager(id, title)<br>    dispatcher._setObject(plrm.getId(), plrm)<br><br>    if REQUEST is not None:<br>        REQUEST.RESPONSE.redirect(<br>                '%s/manage_workspace?manage_tabs_message=WorkspaceLocalRoleManager+added.'<br>                % dispatcher.absolute_url())<br><br><br>class WorkspaceLocalRoleManager(BasePlugin):<br>    meta_type = "Workspace Roles Manager"<br>    security  = ClassSecurityInfo()<br><br>    def __init__(self, id, title=None):<br>        self.id = id<br>        self.title = title<br><br>    #<br>    # ILocalRolesPlugin implementation<br>    #<br><br>    security.declarePrivate("getRolesInContext")<br>    def getRolesInContext(self, user, object):<br>        roles = []<br>        uid = user.getId()<br><br>        obj, workspace = self._findWorkspace(object)<br>        if workspace is not None:<br>            if user._check_context(obj):<br>                roles.extend(workspace.getLocalRolesForPrincipal(uid))<br><br>        return roles<br><br>    security.declarePrivate("checkLocalRolesAllowed")<br>    def checkLocalRolesAllowed(self, user, object, object_roles):<br>        roles = []<br>        uid = user.getId()<br><br>        obj, workspace = self._findWorkspace(object)<br>        if workspace is not None:<br>            if not user._check_context(obj):<br>                return 0<br>            roles = workspace.getLocalRolesForPrincipal(uid)<br>            for role in roles:<br>                if role in object_roles:<br>                    return 1<br><br>        return None<br><br>    security.declarePrivate("getAllLocalRolesInContext")<br>    def getAllLocalRolesInContext(self, object):<br>        rolemap = {}<br><br>        obj, workspace = self._findWorkspace(object)<br>        if workspace is not None:<br>            localRoleMap = workspace.getLocalRoles()<br>            for (principal, roles) in localRoleMap.items():<br>                rolemap.setdefault(principal, Set()).update(roles)<br><br>        return rolemap<br><br>    # Helper methods<br><br>    security.declarePrivate("_findWorkspace")<br>    def _findWorkspace(self, object):<br>        """Find the first workspace, if any, in the acquistion chain of this<br>        object. Returns a tuple obj, workspace where workspace is the adapted<br>        IWorkspace.<br>        """<br><br>        for obj in self._chain(object):<br>            workspace = IWorkspace(obj, None)<br>            if workspace is not None:<br>                return obj, workspace<br>        return None, None<br><br>    security.declarePrivate("_chain")<br>    def _chain(self, object):<br>        """Generator to walk the acquistion chain of object, considering that it <br>        could be a function.<br>        """<br><br>        # Walk up the acquisition chain of the object, to be able to check<br>        # each one for IWorkspace.<br><br>        # If the thing we are accessing is actually a bound method on an<br>        # instance, then after we've checked the method itself, get the<br>        # instance it's bound to using im_self, so that we can continue to <br>        # walk up the acquistion chain from it (incidentally, this is why we <br>        # can't juse use aq_chain()).<br><br>        context = aq_inner(object)<br><br>        while context is not None:<br>            yield context<br><br>            funcObject = getattr(context, 'im_self', None)<br>            if funcObject is not None:<br>                context = aq_inner(funcObject)<br>            else:<br>                # Don't use aq_inner() since portal_factory (and probably other)<br>                # things, depends on being able to wrap itself in a fake context.<br>                context = aq_parent(context)<br><br>classImplements(WorkspaceLocalRoleManager, ILocalRolesPlugin)<br>InitializeClass(WorkspaceLocalRoleManager)<br></pre>On
first glance, there is quite a lot going on here, but it is not so hard
to understand. First, we define a good old-fashioned Zope 2 factory and
ZMI add form. This is good practice, because PAS plug-ins can be
managed via <i>acl_users</i> in the ZMI. If you find yourself
wandering there, however, remember to bring a torch and keep a trail of
breadcrumbs to find your way out. A backup wouldn't hurt either if you
try to change things. It is, unfortunately, not the most intuitive of
interfaces.<br><br>We will see how the plug-in is registered and activated in a moment, but first notice that the plug-in implements an interface, <i>ILocalRolesPlugin</i>,Â&nbsp;
which is defined by PlonePAS, the PAS-in-Plone integration layer. This
defines methods that will be called by the PAS machinery to determine,
in this case, local roles. Note that this is <i>not</i> an adapter
(perhaps it would have been if PAS had been invented in Zope 3, though
Zope 3 has its own authentication machinery that is evolved from PAS
and works slightly differently). When created, the <i>ProjectLocalRoleManager</i> is an Zope 2 object that lives in the ZODB in <i>acl_users</i>.<br><br>The methods of the <i>ILocalRolesPlugin</i>
interface are fairly self-explanatory in purpose. They allow PAS to
extract the local roles for a particular user in a particular context (<i>getRolesInContext()</i>),
to check whether a user in fact has one of the roles required to access
a particular method attribute in a particular context (<i>checkLocalRolesAllowed()</i>), and to get a map of users-to-roles in a particular context.<br><br>The complex parts are, as often is the case, concerned with acquistion. The helper method <i>_findWorkspace()</i> attempts to walk up the object hierarchy to find the first possible <i>IWorkspace</i> (it will only consider one) to get hold of the appropriate <i>IWorkspace</i>
adapter that is then used to determine the actual roles that apply, as
above. Without walking up the content hierarchy, it would not be
possible to let the local roles of a particular project apply when in
the context of a piece of content <i>inside</i> that project (i.e. a sub-object of the folderish <i>Project</i> object). There is some reasonably hairy acqusition-juggling going on in the _<i>chain()</i>
method to return this chain as a generator. The hairiness comes from
the fact that the thing that is being checked may in fact be a method
that is being accessed, and aqusition chains can get themselves in all
kinds of knots, especially when Five is in the mix.<br><br>Lastly, we need to declare a <i>ClassSecurityInfo</i> and call <i>InitializeClass</i> to get Zope 2 to play ball.<br><br><h3>Registering the plug-in</h3>To be able to use this plug-in, we must first register it with PAS. This is done when the product is loaded, in <i>borg/__init__.py</i>:<br><pre>from Products.PluggableAuthService import registerMultiPlugin<br>...<br>from pas import localrole<br>...<br>registerMultiPlugin(localrole.WorkspaceLocalRoleManager.meta_type)<br><br>def initialize(context):<br>    context.registerClass(localrole.WorkspaceLocalRoleManager,<br>                          permission = AddUserFolders,<br>                          constructors = (localrole.manage_addWorkspaceLocalRoleManagerForm,<br>                                          localrole.manage_addWorkspaceLocalRoleManager),<br>                          visibility = None)<br>    ...<br></pre>This is similar to how CMF content types are initialised with <i>ContentInit().initialize()</i> and <i>context.registerClass().</i> In other words, copy-and-paste and the less you know the happier you will be.<br><br>By registering the plug-in, we could now ask our users to instantiate a <i>Workspace Roles Manager </i>within <i>acl_users</i>....
er... somwhere. Like we said - not necessarily obvious. Better to do it
once, in the setup code for b-org. Please refer to the section on
GenericSetup to learn how b-org is actually installed, but notice that
the relevant code is in <i>setuphandlers.py</i>:<br><pre>from Products.CMFCore.utils import getToolByName<br>from Products.PlonePAS.Extensions.Install import activatePluginInterfaces<br>from config import LOCALROLES_PLUGIN_NAME<br>...<br>def setupPlugins(portal, out):<br>    """Install and prioritize the project local-role PAS plug-in.<br>    """<br>    uf = getToolByName(portal, 'acl_users')<br><br>    borg = uf.manage_addProduct['borg']<br>    existing = uf.objectIds()<br><br>    if LOCALROLES_PLUGIN_NAME not in existing:<br>        borg.manage_addWorkspaceLocalRoleManager(LOCALROLES_PLUGIN_NAME)<br>        print &gt;&gt; out, "Added Local Roles Manager."<br>        activatePluginInterfaces(portal, LOCALROLES_PLUGIN_NAME, out)<br></pre>All we do here is get hold of the factory dispatcher for the user folder (from <i>manage_addProduct</i>, which has something to do with that <i>registerClass</i> call for the <i>WorkspaceLocalRoleManager</i>
seen in the previous code example, but like we said, it's dont-ask,
don't-tell) and if it is not there already, we create an instance of
the plugin using the factory. We then need to activate it so that it
actually takes effect. <i>out</i> is a StringIO output stream used for logging.<br></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-4">

            <h1>
                2.5.5.12.
                Placeful workflow
            </h1>

            <p class="documentDescription">b-org uses CMFPlacefulWorkflow, which ships with Plone 2.5, to manage the workflow of content objects inside a project.</p>
    
            <div>
                
                    <div><p>Placeful
workflows are based on the concept of policies. You can think of a
policy as a mapping of workflows to types, in the same way as you could
control from the <i>portal_workflow</i> tool. Policies are created,
normally by copying an existing policy (possibly the default, global
policy), and then applied to a context. In Plone, this can be done
using the <i>policy </i>option in the <i>state</i> menu.</p><p>Placeful
workflows are used in b-org Projects. Inside a project, project members
should have elevated view and modify permissions over content. This is
achieved using the following technique:</p><ul><li>A new role <i>TeamMember</i> is made available within any Project<i>.</i></li><li>A custom workflow, <i>borg_project_default_workflow</i> is a customisation of the default Plone workflow that has a simplified set of states and actions, and is aware of the <i>TeamMember</i> role.</li><li>A placeful workflow policy sets the default workflow, as well as the workflow for folders, to this one.</li><li>When a Project is created, this placeful workflow policy is enabled for the project.</li></ul><p>The custom workflow is defined using <i>GenericSetup</i>, in <i>profiles/default/workflows/borg_project_default_workflow/definition.xml</i>. You can of course install your own workflow if necessary. The workflow policy is set up in the <i>importVarious</i> setup step, in <i>setuphandlers.py</i>:</p><pre>from Products.CMFCore.utils import getToolByName<br>from config import LOCALROLES_PLUGIN_NAME, PLACEFUL_WORKFLOW_POLICY<br><br>...<br><br>def addProjectPlacefulWorkflowPolicy(portal, out):<br>    """Add the placeful workflow policy used by project spaces.<br>    """<br>    placeful_workflow = getToolByName(portal, 'portal_placeful_workflow')<br>    if PLACEFUL_WORKFLOW_POLICY not in placeful_workflow.objectIds():<br>        placeful_workflow.manage_addWorkflowPolicy(PLACEFUL_WORKFLOW_POLICY, <br>                                                   duplicate_id='portal_workflow')<br>        policy = placeful_workflow.getWorkflowPolicyById(PLACEFUL_WORKFLOW_POLICY)<br>        policy.setTitle('[borg] Project content workflows')<br>        policy.setDefaultChain(('borg_project_default_workflow',))<br>        policy.setChainForPortalTypes(('Folder', 'Large Plone Folder',), <br>                                      ('borg_project_default_workflow',))<br></pre><p>Again, you could add a different policy if you needed different settings.</p><p>Finally,
we apply the policy when a project is created. We will see how this is
set up when events are covered in the next section, but the relevant
code is in <i>events/project.py</i>:<br></p><pre>from zope.interface import implements<br>from zope.component import getUtility<br><br>from Products.CMFCore.utils import getToolByName<br><br>from Products.borg.config import PLACEFUL_WORKFLOW_POLICY<br>from Products.borg.interfaces import ILocalWorkflowSelection<br><br>class DefaultLocalWorkflowSelection(object):<br>    """Select the default local workflow policy.<br><br>    Local adapters or overrides may supercede this.<br>    """<br><br>    implements(ILocalWorkflowSelection)<br><br>    workflowPolicy = PLACEFUL_WORKFLOW_POLICY<br><br><br>def addLocalProjectWorkflow(ob, event):<br>    """Apply the local workflow for project spaces when a project is added.<br>    """<br><br>    # Add the TeamMember role if necessary<br>    if 'TeamMember' not in ob.validRoles():<br>        # Note: API sucks :-(<br>        ob.manage_defined_roles(submit='Add Role',<br>                                REQUEST={'role': 'TeamMember'})<br><br><br>    # Find out which workflow to use - this is looked up as a utility so<br>    # that other components can override it.<br>    workflowSelection = getUtility(ILocalWorkflowSelection, context=ob)<br><br>    # Set the placeful (local) workflow<br>    placeful_workflow = getToolByName(ob, 'portal_placeful_workflow')<br>    ob.manage_addProduct['CMFPlacefulWorkflow'].manage_addWorkflowPolicyConfig()<br>    config = placeful_workflow.getWorkflowPolicyConfig(ob)<br>    config.setPolicyBelow(policy=workflowSelection.workflowPolicy)<br></pre><p>Here,
the local role is added to the newly created project instance (it is
not made global so as not to pollute the global roles list), and the
policy is associated with the contents of the (folderish) project
object.</p><p>Note that we do not hard-code the name of the workflow policy! Instead, we ask a utility called <i>ILocalWorkflowSelection</i>. This could be overridden using a local utility, but the global one references the policy created above, as defined in <i>DefaultLocalWorkflowSelection</i>. This utility is registered in <i>events/configure.zcml</i> as follows:<br></p><pre>  &lt;utility provides="..interfaces.ILocalWorkflowSelection"<br>           factory=".project.DefaultLocalWorkflowSelection" /&gt;<br></pre></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-4">

            <h1>
                2.5.5.13.
                Sending and handling events
            </h1>

            <p class="documentDescription">Events is undoubtedly one of the most useful things that Zope 3 brings to the Zope 2 world. Here's how b-org uses them.</p>
    
            <div>
                
                    <div><p>In
the previous section, you saw how an event handler was used to apply a
placeful workflow policy to newly created projects. This pattern is
quite powerful - instead of needing to subclass <i>Project</i> just to add something to <i>at_post_create_script()</i> or <i>initializeArchetype()</i>,
say, you simply register an appropriate event handler. This pattern can
of course apply to other situations, such as when objects are modified,
deleted, added to a container, or on any other type of event that may
occur in your system. Events are synchronous, so when code emits an
event, it will block until all event handlers are finished.</p><p>Recall the event handler for adding projects. It can be found in <i>events/project.py</i> and has the following signature:</p><pre>def addLocalProjectWorkflow(ob, event):<br>    ...<br></pre><p>The
first argument is the object the event was fired on, the second is an
instance of the event itself. In fact, this two-part event dispatcher
is a special case of events described with <i>IObjectEvent</i> and its sub-interfaces. Internally, Zope 3 catches all <i>IObjectEvent</i>s
and re-dispatches the event based on the object that is passed along
the event instance. The registration for the event handler in <i>events/configure.zcml</i> looks like this:</p><pre>&lt;subscriber for="..interfaces.IProjectContent<br>                   zope.app.container.interfaces.IObjectAddedEvent"<br>              handler=".project.addLocalProjectWorkflow" /&gt;<br></pre><br><p>Note that there are two interfaces the subscriber is registered <i>for</i>
- the object type and the event type. These must be separated by
whitespace, though a newline like above is customary. This is the same
syntax that is used to explicitly define multi-adapters (if you are not
using the <i>adapts()</i> syntax in an adapter class) - in fact, the
events machinery uses the adapter registry internally to map
subscribers to events when they are fired.<br></p><p>A more general-case event can be found in <i>events/employee.py</i>, which takes care of assigning ownership of an <i>Employee</i> object to the user that is tied to that employee. The code is borrowed and adapted from <i>PloneTool</i>, but notice the signature which only includes the event:</p><pre>def modifyEmployeeOwnership(event):<br>    """Let employees own their own objects.<br><br>    Stolen from Plone and CMF core, but made less picky about where users are <br>    found.<br>    """<br></pre><p>The registration in <i>events/onfigure.zcml </i>is similar to the one above, but only uses one <i>for</i> interface:</p><pre> &lt;subscriber for="..interfaces.IEmployeeModifiedEvent"<br>              handler=".employee.modifyEmployeeOwnership" /&gt;<br></pre><h3>Sending custom events</h3><p>You will notice that the <i>IEmployeeModifiedEvent</i>
is a custom event. In Plone 3.0 (or rather, Archetypes 1.5) this won't
be necessary, because Archetypes will take care of sending an event
derived from <i>IObjectModifiedEvent</i>, which in turn derives from <i>IObjectEvent</i> and thus is subject to the same registration as the <i>IObjectAddedEvent</i> that includes the object type and the event type. For now, though, we need to send the event ourselves.</p><p>The event is described by an interface in <i>interfaces/employee.py</i>:</p><pre>from zope.interface import Interface, Attribute<br><br>...<br><br>class IEmployeeModifiedEvent(Interface):<br>    """An event fired when an employee object is saved.<br>    """<br><br>    context = Attribute("The content object that was saved.")<br></pre>The implementation is trivial, and can be found in <i>content/employee.py</i>:<br><pre>from zope.interface import implements<br><br>...<br><br>from Products.borg.interfaces import IEmployeeModifiedEvent<br><br>...<br><br>class EmployeeModifiedEvent(object):<br>    """Event to notify that employees have been saved.<br>    """<br>    implements(IEmployeeModifiedEvent)<br><br>    def __init__(self, context):<br>        self.context = context<br></pre>It is of course the event <i>class</i> that we instantiate and send, whilst we register the event handler for the event <i>interface</i>.
This means that we could provide alternative implementations for the
same event interface, if need be. It also means that event handlers
subscribed for a parent interface will be invoked for events that
provide a sub-interface.<br><br><p>Sending the event is very simple. In the definition of <i>Employee</i> in <i>content/employee.py</i>, we have:</p><pre>from zope.event import notify<br><br>...<br><br>class Employee(ExtensibleSchemaSupport, BaseContent):<br><br>    ...<br>Â&nbsp;<br>    security.declarePrivate(permissions.View, 'at_post_create_script')<br>    def at_post_create_script(self):<br>        """Notify that the employee has been saved.<br>        """<br>        notify(EmployeeModifiedEvent(self))<br><br>    security.declarePrivate(permissions.View, 'at_post_edit_script')<br>    def at_post_edit_script(self):<br>        """Notify that the employee has been saved.<br>        """<br>        notify(EmployeeModifiedEvent(self))<br></pre><p>We construct an event instance and parameterise it with the right object (i.e. self) before sending it with <i>notify()</i>, all on one line.<br></p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-4">

            <h1>
                2.5.5.14.
                Annotations
            </h1>

            <p class="documentDescription">Annotations are an elegant solution to the "where do I store this?" problem, and are used in many Zope 3 applications.</p>
    
            <div>
                
                    <div><p>It
is often useful to be able to attach information to an object even if
you don't have control over that object's type and schema. For example,
a tagging solution may attach a list of tags to an object, or a
notification tool may want to add a list of subscribers on a per-object
basis. This is known in Zope 3 as "annotations".</p><p>Annotations work like this:</p><ul><li>A marker interface, normally <i>IAttributeAnnotatable</i>
is applied to the class or object that is to be annotated. This
particular marker means that annotations are stored in a persistent
dict called <i>__annotations__</i> that is added to the object, though this should be considered an implementation detail.<br></li><li>An adapter exists from <i>IAttributeAnnotable </i>to <i>IAnnotations</i>.
If you need a different annotation regime (e.g. one that stores the
values keyed by object id in some local utility) you could provide a
different adapter to <i>IAnnotations</i>.</li><li>The code that wishes to annotate an object will adapt it to <i>IAnnotations</i>.
The annotations adapter acts like a dict. Conventionally, each package
that uses annotations will store all its (arbitrary) information under
a particular key in that dict. The key name is normally the same as the
name of the package. This is mainly to avoid conflicts between
different packages annotating a particular object.</li></ul><p>In
b-org, we don't have quite the same need for annotating objects from
other parts of Plone, but we use annotations to store users' passwords.
This ensures that they cannot be accessed through-the-web (since Zope 2
won't publish the <i>__annotations__</i> dict, as it begins with an
underscore) and keeps passwords out of the way. Strictly speaking, this
is probably overkill since the password is also hashed using the SHA1
one-way hasing algorithm, but that never stopped anyone before.</p><p>First, look at the definition of the <i>Employee</i> class in <i>content/employee.py</i>:</p><pre>from zope.app.annotation.interfaces import IAttributeAnnotatable, IAnnotations<br><br>...<br><br>class Employee(ExtensibleSchemaSupport, BaseContent):<br><br>    ...<br><br>    implements(IEmployeeContent,<br>               IUserAuthProvider,<br>               IPropertiesProvider,<br>               IGroupsProvider,<br>               IGroupAwareRolesProvider, <br>               IAttributeAnnotatable)<br></pre><p>Here,
we explicitly say that Employee is attribute annotatable. Of course,
this requires control over the class. If you are trying to annotate
another type that isn't already marked as annotatable, you may be able
to add the marker interface using <i>classProvides()</i> or <i>directlyProvides()</i> from <i>zope.interface</i>, or use the ZCML <i>&lt;implements /&gt;</i>
directive. You need to be a bit careful, though, since the thing you
are annotating should probably be persistent. You should also be polite
- you're stuffing your own information onto someone else's object. Try
not to break it.</p><p>Further down in <i>content/employee.py</i>, you will see the annotation being set:</p><pre>    security.declareProtected(permissions.SetPassword, 'setPassword')<br>    def setPassword(self, value):<br>        if value:<br>            annotations = IAnnotations(self)<br>            annotations[PASSWORD_KEY] = sha(value).digest()<br></pre><p>PASSWORD_KEY comes from <i>config.py</i>, and is simply a string. The digest is verified in <i>membership/employee.py</i>, in the <i>IUserAuthentication</i> adapter:</p><pre>class UserAuthentication(object):<br>    """Provide authentication against employees.<br>    """<br>    implements(IUserAuthentication)<br>    adapts(IEmployeeContent)<br><br>    def __init__(self, context):<br>        self.context = context<br><br>    def getUserName(self):<br>        return self.context.getId()<br><br>    def verifyCredentials(self, credentials):<br>        login = credentials.get('login', None)<br>        password = credentials.get('password', None)<br><br>        if login is None or password is None:<br>            return False<br><br>        digest = sha(password).digest()<br><br>        annotations = IAnnotations(self.context)<br>        passwordDigest = annotations.get(PASSWORD_KEY, None)<br><br>        return (login == self.getUserName() and digest == passwordDigest)<br></pre><p>That's all there is to it. We get an <i>IAnnotations</i> adapter, and then look up the <i>PASSWORD_KEY</i> to find the digest. The annotations adapter has the same contract as a Python dict, so we can use functions like <i>get()</i> and <i>setdefault()</i>.<br></p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-4">

            <h1>
                2.5.5.15.
                Zope 3 Views
            </h1>

            <p class="documentDescription">One of the nicest things that Zope 3 brough us is a way to manage view logic.</p>
    
            <div>
                
                    <div><p>In
Zope 2, a view (be that a view of a content object, or a more
standalone template) typically consists of a Zope Page Template that
pulls in data from its context. The problem is that non-trivial
templates usually require some kind of "view logic" or "display logic".
People tend to put these in a few places:</p>

<ul><li>Complex <em>python:</em> expressions in the ZPT. This is bad
because it makes your templates hard to understand, and because there
is a limit to what you can do with one-line Python expressions.<br></li><li>External Python Scripts in a skin layer that get acquired in the page template, e.g. <em>here/calculateDate.</em>
This is bad because it is cumbersome to create a new file for something
which may be quite trivial, because all such scripts are part of a
global namespace (and thus there may be conflicts between two different
scripts with the same name), and also because Python scripts in the
skin layers (and <em>python:</em> expressions) are slower than filesystem Python code and more restricted.<br></li><li>A
custom tool that provides some necessary functionality. This is bad
because a tool is a singleton, so you will probably need to explicitly
pass around a context. Tools are also part of that same global
namespace (by way of acquisition from the portal root), and are a
hassle to create and install.<br></li><li>Methods on the context
content object (where applicable). This is bad because it mixes
presentation logic and the model (the schema) and storage logic. This
often leads to an explosion of methods on each content type that are
highly specific to a particular template. This pattern also requiers
that you have the ability to add new methods to the content type class,
even if you are just adding a new view template for it.</li></ul><p>As
usual, these problems indicate a lack of separation of concerns. Zope
3's answer is a view - a class (typically) which may be associated with
a template.</p>

<h3>Views are multi-adapters</h3>

<p>You will often hear that views are named multi-adapters of a context
and a request. In fact, the concept of a multi-adapter originated in
the need for views. For most practical purposes, you can forget about
this - it is an implementation detail. However, you may sometimes need
to look up views yourself, which can be done using:</p>

<pre>from zope.component import getMultiAdapter
myView = getMultiAdapter((context, request), name='my_view')
</pre>

<p>More importantly, you need to know that to access the context the view is operating on inside that view, you can use <em>self.context</em>, and to access the request (including form variables submitted as part of that request, if applicable), using <em>self.request</em>.</p>

<h3>Explicitly acquiring views</h3>

<p>One of the easiest ways of using views with existing code is to make
page templates in a skin layer as you normally would, and then acquire
a view object that is used for rendering logic. One of the main reasons
for using this approach is that it allows page templates to be
customised using the normal skin layer mechanism. This is approach is
used extensively in Plone 2.5. Here's an example from the "recent"
portlet, starting with <em>portlet_recent.pt</em>:</p>

<pre>...

&lt;tal:recentlist tal:define="view context/@@recent_view;
                            results view/results;"&gt;

    ...

    &lt;tal:items tal:repeat="obj results"&gt;

        ...    

    &lt;/tal:items&gt;

    ...

&lt;/tal:recentlist&gt;
</pre>

<p>The important line here is context<em>/@@recent_view</em>. This will look up a view named <em>recent_view</em> relative to the current context (<em>context</em> in page templates is a now-preferred alias for the <em>here</em> variable that was used before - <em>here</em> still works in Zope 2 templates, but is gone in Zope 3).</p>

<p>This view is defined by a class and a ZCML directive. The ZCML directive looks like this:</p>

<pre>&lt;browser:view
      for="*"
      name="recent_view"
      class=".portlets.recent.RecentPortlet"
      permission="zope.Public"
      allowed_attributes="results"
      /&gt;
</pre>

<p>Actually, this is not exactly what's in the file in Plone, since
Plone is working around a few Zope 2.8 issues, but basically, this says
that the view is available on all types of contexts (<em>for="*"</em> - this could specify a dotted name to an interface if needed, more on that below), has the name <em>recent_view</em>, is public (because of the magic permission <em>zope.Public</em>) and that when acquired, the attribute (method) <em>results</em>
is allowed - more attributes could be specified separated by
whitespace. The class that is referenced contains the view
implementation. Here it is, again slightly modernised:</p>

<pre>from Products.Five.browser import BrowserView
from Products.CMFCore.utils import getToolByName

from Acquisition import aq_inner

class RecentPortlet(BrowserView):
    """The recent portlet
    """

    def results(self):
        """Get the search results
        """
        context = aq_inner(self.context)
        putils = getToolByName(context, 'plone_utils')
        portal_catalog = getToolByName(context, 'portal_catalog')
        typesToShow = putils.getUserFriendlyTypes()
        return self.request.get(
            'items',
            portal_catalog.searchResults(sort_on='modified',
                                         portal_type=typesToShow,
                                         sort_order='reverse',
                                         sort_limit=5)[:5])
</pre>

<p>The use of <em>aq_inner()</em> on self.context is not strictly
necessary always, but is a useful rule of thumb to make acquisition do
what you expect it to do (this is because the <em>BrowserView</em> base class extends <em>Acquisition.Explicit</em>, which causes <em>self.context</em> to gain an acquistion wrapper that can mess with its acqusition chain).</p>

<h3>Views with templates</h3>

<p>Zope 3 does not use views in this way. Instead, you would bind the
template to the browser view explicitly. The main drawback of this
technique is that the template is not present in the <em>portal_skins</em>
tool, and so cannot be customised through-the-web. This may be possible
in future versions of Zope and CMF, but for now the full-blown view
technique is best used when it is not necessary to customise views
through-the-web. Of course, you can still override view registrations
using ZCML on more specific interfaces or an <em>overrides.zcml</em>.</p>

<p>Here is a view for departments in the <em>charity</em> example product, under <em>charity/browser/configure.zcml.</em> Notice how this entire XML file is in the <em>browser</em> namespace, and thus it is unnecessary to prefix each directive with <em>browser:</em></p>

<pre>&lt;configure xmlns="http://namespaces.zope.org/browser"
           i18n_domain="charity"&gt;

  &lt;page
      name="charity_department_view"
      for="Products.borg.interfaces.IDepartmentContent"
      class=".department.DepartmentView"
      template="department.pt"
      permission="zope2.View"
      /&gt;
      
  ...
  
&lt;/configure&gt;
</pre>

<p>Here, we explicitly state that this view is only available for <em>IDepartmentContent</em> objects. This means that if you try to invoke <em>@@charity_department_view</em> on anything that does not provide this interface, you will get a lookup error. The view is protected by the Zope 2<em> View</em> permission. Also note that there is no <em>allowed_attributes</em> (or <em>allowed_interface</em>) attribute here. This is because the view is not intended to be used by other templates (if they tried, they would get an <em>Unauthorized</em> error when trying to access any attribute of the view) - all the logic is in the <em>department.pt</em> template.</p>

<p>The <em>department.pt</em> template is found in <em>charity/browser, </em>the same directory as the <em>configure.zcml</em> file above. You can use relative paths like <em>./templates/...</em> if necessary to point to the template file on the filesystem. Here is the class:</p>

<pre>from Products.Five.browser import BrowserView
from Products.borg.interfaces import IDepartment

class DepartmentView(BrowserView):
    """A view of a charity department"""

    def __init__(self, context, request):
        self.context = context
        self.request = request
    
    def name(self):
        return self.context.Title()
        
    def managers(self):
        return self.context.getManagers()
        
    def details(self):
        return self.context.Description()
</pre>

<p>And here is the template that uses these methods:</p>

<pre>&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
      lang="en"
      metal:use-macro="here/main_template/macros/master"
      i18n:domain="charity"&gt;
&lt;body&gt;

&lt;metal:main fill-slot="main"&gt;
    
    &lt;div metal:use-macro="here/document_actions/macros/document_actions"&gt;
        Document actions (print, rss etc)
    &lt;/div&gt;
    
    &lt;h1 class="documentFirstHeading" tal:content="view/name" /&gt;
    
    &lt;table class="listing vertical" style="float:right" tal:condition="view/managers"&gt;
      &lt;tr&gt;
        &lt;th&gt;Manager(s)&lt;/th&gt;
        &lt;td&gt;
          &lt;div tal:repeat="obj view/managers"&gt;
            &lt;a href="#" tal:attributes="href obj/absolute_url" tal:content="obj/Title" /&gt;
         &lt;/div&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;

    &lt;div tal:content="structure view/details" /&gt;

    &lt;metal:listing use-macro="here/folder_listing/macros/listing" /&gt;
    
    &lt;div class="visualClear"&gt;&lt;!----&gt;&lt;/div&gt;
    
&lt;/metal:main&gt;

&lt;/body&gt;
&lt;/html&gt;
</pre>

<p>Now, you can go to a hypothetical URL <em>/mydept/@@charity_department_view</em> to see this view rendered. In fact, this is set as the <em>view</em> and <em>(Default)</em> aliases for the Department content type when <em>charity</em> is installed, so the user will never see this URL.</p>

<h3>Views without templates</h3>

<p>It is also possible to make views without templates. This is useful
if you need a URL to submit that does some processing. That processing
would normally be done in the <em>__call__()</em> method, as in the hypothetical example below:</p>

<pre>  &lt;browser:view
      name="modify_customer"
      for=".interfaces.ICustomer"
      class=".customer.ModifyCustomerView"
      permission="cmf.ModifyPortalContent"
      /&gt;</pre>

<p>Now, we could write a form that has <em>action="@@modify_customer"</em>, which would result in this being called:</p>

<pre>class ModifyCustomerView(BrowserView):
    """Modify a customer from a form
    """

    def __call__(self):
        name = self.request.form.get('name', None)
        dog = self.request.form.get('dog', None)

        self.context.name = name
        self.context.dog = dog

        self.request.response.redirect('@@customer_view')
</pre>

<p>This is obviously a simplified example, but the important thing to realise is that the view will tend to use <em>self.context</em> and <em>self.request</em> to interact with the rest of the portal.</p>

<p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-1">

            <h1>
                3.
                Using ArchGenXML
            </h1>

            <p class="documentDescription">ArchGenXML
is a code-generator for CMF/Plone applications (Products) based on the
Archetypes framework. It parses UML models in XMI-Format (.xmi, .zargo,
.zuml), created with applications such as ArgoUML, Poseidon or
ObjectDomain. This tutorial will help you get started developing
applications with the aid of ArchGenXML.</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-2">

            <h1>
                3.1.
                Getting Started
            </h1>

            <p class="documentDescription">Introduction, Installation and Hello World.</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.1.1.
                Introduction
            </h1>

            <p class="documentDescription">An introduction to ArchGenXML - what it is, reasons to use it, who made it.</p>
    
            <div>
                
                    <div><h2>What is ArchGenXML</h2>
<p> With ArchGenXML you can create working python code without writing one single 

 line of python.  It is a command-line utility that generates fully functional 

 Zope Products, based on the Archetypes framework, from UML models using XMI 

 (.xmi, .zargo, .zuml) files.  The most common use-case is to generate a set of 

 custom content types and folders, possibly with a few tools, a member

 type and some workflows thrown in.</p>
<p>In practice, you draw your UML diagrams in a tool like ArgoUML or Poseidon which 

has the ability to generate XMI files.  Once you are ready to test your product, 

you run ArchGenXML on the XMI file, which will generate the product directory. 

After generation, you will be able to install your product in Plone and have 

your new content types, tools and workflows available. </p>
<p>At present, round-trip support is not implemented: custom code can't
be converted back into XMI (and thus diagrams). However, you can
re-generate your product over existing code; method bodies and certain
"protected" code sections will be preserved. This means that you can
evolve your product's public interfaces, its methods and its attributes
in the UML model, without fear of losing your hand-written code.</p>
<p>ArchGenXML is hosted at <a href="http://svn.plone.org/archetypes/ArchGenXML">svn.plone.org</a> 

as a subproject of the Archetypes project. It is released under GNU General 

Public Licence 2 or later.</p>
<p><img src="developer-manual_archivos/uml-model-small.png" alt="Eyecatcher: UML Model, small image as an example, from a real life project of BlueDynamics"></p>
<h2>Why should I use ArchGenXML?</h2>
<p> Major reasons:</p>

<ul><li>You want to save time</li>
<li>You are a lazy programmer</li>
<li>You don't like to reinvent the wheel</li>
<li>You don't like copying and pasting code (and bugs)</li>
<li>You make heavy use of references and interfaces</li>
<li>You have big projects with many different custom types</li>
<li>You want or need a well-documented interface to your product</li>
<li>You like structured model- and pattern-driven software development</li>
<li>You want to maintain your project in future without getting a headache</li>

</ul><p>and many other good and odd reasons.</p>
<h2>Contributors</h2>
<p> The project was initially started by Phil Auersperg. Thanks to his laziness :-)</p>
<h3> Authors</h3>
<dl><dt>  Phil Auersperg (Project Leader)</dt>
<dd><a href="http://www.bluedynamics.com/">BlueDynamics Alliance, Auersperg-Castell KEG</a>, <a href="mailto:phil@bluedynamics.com">phil@bluedynamics.com</a>,</dd>
<dt>  Jens Klein (Release Manager, Developer and Doc-Writer)</dt>
<dd><a href="http://www.bluedynamics.com/">BlueDynamics Alliance, Klein &amp; Partner KEG</a>, <a href="mailto:jens@bluedynamics.com">jens@bluedynamics.com</a>,</dd>
<dt>  Reinout van Rees (Co-Release Manager, Developer and Doc-Writer)</dt>
<dd>ZestSoftware</dd>
<dt>  Fabiano Weimar dos Santos (Ideas, Testing, Bugfixing, Workflow)</dt>
<dd><a href="http://www.xiru.org/">Weimar Desenvolvimento e Consultoria em Informatica Ltda.</a>, <a href="mailto:xiru@xiru.org">xiru@xiru.org</a>,</dd>
<dt>  Martin Aspeli (Improvements, bug fixes and documentation)</dt>
<dd><a href="mailto:optilude@gmx.net">Martin Aspeli</a></dd>
<dt>  Robert Niederreiter (Lots of base work on AGX 2.0)</dt>
<dd><a href="mailto:rnix@squarewave.at">Robert Niederreiter</a></dd>
<dt>  and others</dt>
<dd>thanks to everybody who contributed with testing, doc-writing or code-pieces!</dd>
</dl><h3> Sponsors</h3>

<ul><li>Xiru.org, Brazil (Fabiano Weimar dos Santos) sponsors a
valuable amount of money into workflow support (State diagrams -&gt;
DCWorkflow, will go into release 1.2),</li>
<li>PilotSystems, Paris, France (David Sapiro),</li>
<li>OpenSource.ag, Innsbruck, Austria (Georg Pleger).</li>

</ul><p> If you want to contribute ArchGenXML by improving the code,
helping with documentation or sponsoring money to make us improve it,
please contact one of us.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.1.2.
                Installation
            </h1>

            <p class="documentDescription">How to install ArchGenXML and get up and running.</p>
    
            <div>
                
                    <div><h2 class="title">Installation</h2>
<p>ArchGenXML has a dependency on some zope 3 eggs. To not mess up your
global site-packages directory, using buildout or virtualenv is
recommended.</p>
<p>Note: In an older version of AGX, a Zope 3 installation could be configured in a <em>~/.agx_zope_path</em> file. This case is not supported anymore. You can delete this file if you have it.</p>
<p>On Windows, I assume you installed Python 2.4.4 from the <a class="reference external" href="http://www.python.org/download/releases/2.4.4/">msi installer</a>
and installed it in the default location. If you have not already done,
configure the Path environment variable to include your python path and
scripts directory.
For this, got to Control Panel, Advanced, Environment Variables, edit
Path, append <tt class="docutils literal"><span class="pre">;C:\\Python24;C:\\Python24\Scripts</span></tt> to the existing string.</p>
<div class="section" id="installing-stable-version">
<h3>Installing stable version</h3>
<p>Attention: adding archgenxml egg to a Plone buildout is not
supported!
Plone 3.x buildout is shipped with old Zope 3.3. ArchGenXML depends on
latest version of zope 3 eggs. So please create a buildout only for
archgenxml like described below.</p>
<p>If you want to install archgenxml via buildout (recommended), read <em>Using buildout</em> and skip the <em>Using easy_install in a virtualenv</em> part.</p>
<p>It can happen ArchGenXML version on plone.org is older than Pypi
because the release manager forgot to upload it on plone.org or for
another reason. easy_install and buildout will get by default the
latest ArchGenXML version on Pypi, so it's fine.</p>
<div class="section" id="using-buildout">
<h4>Using buildout</h4>
<p>Create a fresh directory and go into it:</p>
<pre class="literal-block">$ mkdir archgenxml_buildout
$ cd archgenxml_buildout
</pre>
<p>Download the normal <a class="reference external" href="http://svn.zope.org/*checkout*/zc.buildout/trunk/bootstrap/bootstrap.py">bootstrap.py</a> and put it in this directory. You can copy an existing bootstrap.py file of one of your buildout, it's the same file.</p>
<p>Then create a <cite>buildout.cfg</cite> file in this directory with the following snippet:</p>
<pre class="literal-block">[buildout]
parts =
    archgenxml

[archgenxml]
recipe = zc.recipe.egg:scripts
eggs = archgenxml
</pre>
<p>Finally bootstrap the buildout and run it:</p>
<pre class="literal-block">$ python bootstrap.py
$ ./bin/buildout
</pre>
<p>On Windows, it's <tt class="docutils literal">bin\buildout</tt>, you have to replace '/' by '\' in all following examples.</p>
<p>archgenxml is now available in <tt class="docutils literal">./bin/archgenxml</tt>.</p>
<p>To update archgenxml later, go in your directory and run buildout again:</p>
<pre class="literal-block">$ ./bin/buildout
</pre>
<p>It will download latest version of archgenxml all all its dependencies.</p>
<p>I call below <em>&lt;path to archgenxml&gt;</em> the archgenxml_buildout directory.</p>
</div>
<div class="section" id="using-easy-install-in-a-virtualenv">
<h4>Using easy_install in a virtualenv</h4>
<p>If you don't want to use buildout, you can use virtualenv to create an isolated environment.
You have to install setuptools egg to have the easy_install command available.
On Ubuntu you can do it with <tt class="docutils literal"><span class="pre">apt-get</span> install <span class="pre">python-setuptools</span></tt>.
On Windows, go to the <a class="reference external" href="http://pypi.python.org/pypi/setuptools">setuptools pypi page</a>, download the exe which match the Python version you are using and execute it to install it.</p>
<p>Install virtualenv with easy_install:</p>
<pre class="literal-block">$ easy_install virtualenv
</pre>
<p>On Windows easy_install.exe is in <tt class="docutils literal"><span class="pre">C:\Python24\Scripts</span></tt>, so you have to invoke it with the full path if you don't have added this directory in your PATH.</p>
<p>Create the virtualenv with --no-site-packages option to not see packages installed globally:</p>
<pre class="literal-block">$ virtualenv --no-site-packages agx
$ cd agx/
$ source bin/activate
$ easy_install archgenxml
</pre>
<p>Everytime you want use archgenxml, you have to go in the <em>agx</em> directory and type <tt class="docutils literal">source bin/activate</tt> to activate the environment. To deactivate the environment, type <tt class="docutils literal">deactivate</tt>.</p>
<p>To update archgenxml, you have to update each egg, the most important one are archgenxml and xmiparser:</p>
<pre class="literal-block">$ easy_install -U archgenxml
$ easy_install -U xmiparser
</pre>
<p>If you have a problem with archgenxml, please be sure to recreate
the virtualenv completly so you have latest versions of all eggs before
asking on the archetypes-users mailing-list.</p>
<p>I call below <em>&lt;path to archgenxml&gt;</em> the path to the virtualenv agx directory.</p>
</div>
</div>
<div class="section" id="installing-development-version">
<h3>Installing development version</h3>
<p>ArchGenXML's svn trunk is for the 2.x development version.</p>
<p>As usual, the goal is to keep trunk workable. Some of the developers
work and develop on the edge: trunk.</p>
<p>If you need stability, use the latest release.</p>
<p>The only supported way to use ArchGenXML trunk is with buildout.
You install it like this:</p>
<pre class="literal-block">$ svn co https://svn.plone.org/svn/archetypes/ArchGenXML/buildout archgenxml_buildout
$ cd archgenxml_buildout
$ python bootstrap.py
$ bin/buildout
</pre>
<p>To update your buildout:</p>
<pre class="literal-block">$ cd archgenxml_buildout
$ svn up
$ bin/buildout
</pre>
<p>If you are intersted in AGX 3 development, see <a class="reference external" href="http://dev.plone.org/archetypes/browser/AGX">http://dev.plone.org/archetypes/browser/AGX</a></p>
<p>I call below <em>&lt;path to archgenxml&gt;</em> the archgenxml_buildout directory.</p>
</div>
<div class="section" id="get-the-archgenxml-profile">
<h3>Get the ArchGenXML profile</h3>
<p>The archgenxml_profile.xmi file contains information about
stereotypes, fields, and other stuff that AGX needs to generate valid
Python code from your model.
You can <a class="reference external" href="http://svn.plone.org/svn/archetypes/ArchGenXML/trunk/umltools/argouml/archgenxml_profile.xmi">get the profile</a> from subversion.</p>
<p>Or you can regenerate it with <cite>&lt;path to archgenxml&gt;/bin/agx_argouml_profile</cite>.
A archgenxml_profile.xmi file is generated in the current directory.</p>
<p>Create a "&lt;path to archgenxml&gt;/profiles" directory and put the file here.</p>
<p>Note: In an older version of AGX, this file was called 'argouml_profile.xmi'. You should not use it with ArgoUML &gt; 0.24.</p>
</div>
<div class="section" id="troubleshooting">
<h3>Troubleshooting</h3>
<p>On Windows, you may have to install and configure the <a class="reference external" href="http://plone.org/documentation/how-to/using-buildout-on-windows">mingw32 compiler</a>
to compile the zope.proxy egg, an indirect dependency of archgenxml.
Now zope.proxy eggs are built for Windows, so you should not have this
problem anymore.</p>
</div>
<div class="section" id="support">
<h3>Support</h3>
<p>For any questions or problems, please ask on the <a class="reference external" href="http://plone.org/support/forums/archetypes">archetypes-users mailing-list</a>.
Please don't use comments on the manual pages. Not everybody is alerted when a comment is added.</p>
<p>If you want to contribute to this documentation, please post on the <a class="reference external" href="http://plone.org/support/forums/docs">plone-docs mailing-list</a>.</p>
</div></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.1.3.
                Configure ArgoUML to use the archgenxml profile
            </h1>

            <p class="documentDescription">ArgoUML
can load a "definition" file with predefined tagged values and
stereotypes. So you have all the custom tagged values and stereotypes
used by ArchGenXML available in dropdown menus.</p>
    
            <div>
                
                    <div><div class="section" id="background-and-notes">
<h3>Background and Notes</h3>
<p>The screenshot below shows ArgoUML with the custom tags from the definition
file. Having many of the possible options available from a menu has the
following benefits:</p>
<ul class="simple"><li>saves time - sometimes clicking is faster  than typing</li>
<li>reduces errors - no more mispelled tags</li>
<li>presents a learning opportunity - seeing new tags and stereotypes provides a
springboard for further investigation</li>
</ul><div class="figure align-center">
<img alt="taggedvalues-argouml.png" src="developer-manual_archivos/taggedvalues-argouml.png"><p class="caption">ArgoUML with ArchGenXML profile</p>
</div>
<p>This walks you through how a setup of ArgoUML on an Ubuntu desktop system.
The methodology should be easily adjusted to other platforms.</p>
</div>
<div class="section" id="assumptions">
<h3>Assumptions</h3>
<p>These are my assumptions:</p>
<ul><li><p class="first">You already have latest sun java JRE installed.
You can get it on Ubuntu with:</p>
<pre class="literal-block">apt-get install sun-java6-jdk
</pre>
<p>If:</p>
<pre class="literal-block">update-alternatives --list java
</pre>
<p>don't give you <em>/usr/lib/jvm/java-6-sun/jre/bin/java</em>, you can set java sun as the default java implementation like this:</p>
<pre class="literal-block">update-alternatives --set java /usr/lib/jvm/java-6-sun/jre/bin/java
</pre>
</li>
<li><p class="first">You have copied archgenxml_profile.xmi in the <em>&lt;path to archgenxml&gt;/profiles</em> directory like described in the previous section.</p>
</li>
</ul></div>
<div class="section" id="install-argouml">
<h3>Install ArgoUML</h3>
<p>Go to <a class="reference external" href="http://argouml.tigris.org/">http://argouml.tigris.org</a> and download the latest stable version of ArgoUML (0.28 when these lines are written).
Download the exe for Windows, the tar.gz archive for Linux.</p>
<p>On Windows, execute the downloaded exe to install it.</p>
<p>On Linux, unpack the archive somewhere, a good location is '/opt':</p>
<pre class="literal-block">$ sudo mkdir /opt
$ cd /opt
$ sudo tar xvf /tmp/ArgoUML-0.28.tar.gz
</pre>
<p>It should create a argouml-0.28 directory.</p>
<p>It is handy to symlink 'argouml.sh' to '/usr/local/bin/argouml':</p>
<pre class="literal-block">$ sudo ln -s /opt/argouml-0.28/argouml.sh /usr/local/bin/argouml
</pre>
</div>
<div class="section" id="configure-argouml-to-use-the-definition-file">
<h3>Configure ArgoUML to use the definition file</h3>
<p>Note: ArgoUML 0.24 used to use the argo.defaultModel option to specify a profile to use like this:</p>
<pre class="literal-block">java -Dargo.defaultModel=&lt;path to archgenxml&gt;/profiles/archgenxml_profile.xmi -jar /opt/ArgoUML/argouml.jar
</pre>
<p>It's not the case anymore with latest ArgoUML version. Please read on.</p>
<ul><li><p class="first">Launch ArgoUML and go to Edit -&gt; Settings... -&gt; Profiles</p>
</li>
<li><p class="first">Click on Add and specify your <em>&lt;path to archgenxml&gt;/profiles</em> directory.</p>
<p>Note: archgenxml will use the list of profiles directories configured on ArgoUML.</p>
</li>
<li><p class="first">Close ArgoUML and launch it again.</p>
</li>
<li><p class="first">Go again in Edit -&gt; Settings... -&gt; Profiles
AGXProfile should be visible now in "Available Profiles".</p>
</li>
<li><p class="first">Click on "&gt;&gt;" to add it to "Default profiles".</p>
</li>
<li><p class="first">You should remove the Java profile from the
"Default profiles" list to be sure to not use stereotypes and tag
definitions from this one.
You should only have AGXProfile and UML 1.4 in this list. You can't
remove the UML 1.4 here, but you remove it by project.</p>
</li>
</ul><p>The global configuration is now done.</p>
<p>Now for every new project you create:</p>
<ul class="simple"><li>Click on the fourth icon in the toolbar to configure Profiles for this project.
Delete UML 1.4. You should really only have AGXProfile is this list.</li>
</ul><p>Note: if you want to generate Plone 2.5 compatible code, set on
the model root the plone_target_version tag definition with value <em>2.5</em>.</p>
</div>
<div class="section" id="why-argouml">
<h3>Why ArgoUML?</h3>
<p>Just a few notes on why using ArgoUML.</p>
<ul class="simple"><li>Mature - it supports the important stuff (at least as far as ArchGenXML
goes), state diagrams, tagged-values, stereotypes.</li>
<li>It is pretty lightweight, which is important when your laptop only has
256 MB of RAM and a PIII 700 Mhz processor. Poseidon Community Edition,
though nice, is just too memory hungry.</li>
<li>Price is good (free and open source)</li>
</ul></div></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.1.4.
                UML
            </h1>

            <p class="documentDescription">A brief introduction to UML and pointers to further readings.</p>
    
            <div>
                
                    <p>UML - the Unified Modeling Language - is a graphical language designed to 
<br>describe software through diagrams. There are several different types of 
<br>diagrams available, but the ones most relevant to ArchGenXML are:
<br><br>* The class diagram
<br><br>* The state diagram
<br><br>Class diagrams are used to draw interfaces, content types (represented as 
<br>classes) and tools (represented as classes with the 'portal_tool' stereotype),
<br>as well as the attributes and public operations on these. In addition, 
<br>associations in the diagram show how objects are aggregated within or referenced 
<br>from one another.
<br><br>The goal of model-driven development is to create the "blueprints" for your 
<br>software in a well-defined, easily-communicated format: the UML model and 
<br>diagram thereof. You can design your model using visual tools until you have a 
<br>structure which adequately represents your needs, and ArchGenXML will generate 
<br>the necessary code. 
<br><br>You probably have to customise that code somewhat, filling in method bodies, 
<br>creating new page templates etc., but ArchGenXML takes care of all the 
<br>boilerplate for you. With tagged values and stereotypes you can customise the 
<br>generated code with a surprising degree of flexibility and control, and when 
<br>you need to hand-code something, ArchGenXML won't overwrite your changes 
<br>(provided you stick to the protected code sections, clearly marked in the 
<br>source code).
<br><br>This manual does not aim to teach you UML and object-oriented, model-driven 
<br>software development. There are several other fine manuals about that on the 
<br>web. A very good starting point is the "OMG UML Resource Page":http://www.uml.org/ 
<br>including its web-links to tutorials.
<br><br>For a quick-start read "Practical-UML":http://bdn.borland.com/article/0,1410,31863,00.html 
<br>chapters 'class-diagram' and 'state-chart-diagram'.</p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.1.5.
                Hello World
            </h1>

            <p class="documentDescription">Create your first minimal content type with ArchGenXML</p>
    
            <div>
                
                    <p>Open the UML tool of your choice. Make a new UML model and give it a name 
<br>'HelloWorld'. Then add a class diagram (most UML tools do this automatically). 
<br><br>Choose the tool for class creation and add a class to the diagram. Give it a 
<br>name such as "HelloType" and add an attribute 'HelloText' with type 
<br>'string'. The "helloworld3.zargo":helloworld3.zargo (Plone 3.0) /
"helloworld25.zargo":helloworld25.zargo (Plone 2.5) was created with
ArgoUML <br>and contains the type as described above.
<br><br>"Example: HelloWorld with HelloType in UML":img:helloworld.png
<br><br><br><br>Generating the product
<br><br> Save your model as helloworld.zargo (ArgoUML) or
helloworld.zuml (Poseidon), or export it as an XMI file with the name
helloworld.xmi. Then go to the command line <br> and execute::
<br><br>  $ archgenxml helloworld.zargo
<br><br> ArchGenXML will begin code generation. When it completes, you will have a new 
<br> folder 'HelloWorld' on your file system. Its contents looks like::
<br><br>  HelloWorld/
<br>  |-- Extensions (only with plone_target_version=2.5)
<br>  |   |-- Install.py
<br>  |   `-- __init__.py
<br>  |-- HelloType.py
<br>  |-- __init__.py
<br>  |-- config.py
<br>  |-- configure.zcml
<br>  |-- i18n
<br>  |   `-- generated.pot
<br>  |-- interfaces.py
<br>  |-- locales
<br>  |-- profiles
<br>  |   `-- default
<br>  |       |-- HelloWorld_marker.txt
<br>  |       |-- cssregistry.xml
<br>  |       |-- factorytool.xml
<br>  |       |-- import_steps.xml
<br>  |       |-- jsregistry.xml
<br>  |       |-- metadata.xml
<br>  |       |-- skins.xml
<br>  |       |-- types
<br>  |       |   `-- HelloType.xml
<br>  |       `-- types.xml
<br>  |-- profiles.zcml
<br>  |-- refresh.txt
<br>  |-- setuphandlers.py
<br>  `-- skins
<br>      |-- helloworld_images
<br>      |   `-- HelloType.gif
<br>      |-- helloworld_styles
<br>      `-- helloworld_templates
<br><br><br>Installing and using the generated product
<br><br> Move the whole folder 'HelloWorld' to your Zope/Plone 3 instance's 'Products' 
<br> folder. Restart  Zope, open Plone in a browser and log in as Manager. Choose 
<br> 'Plone Setup' from the personal bar and choose 'Add/Remove Products'. A new 
<br> product 'HelloWorld' should now appear in the list of products
<br> available for install. Choose it and click 'install'. Go to your personal 
<br> folder. In the list of addable items you'll find the new product as an 
<br> addable content type. Add a test instance to see if it works.
<br><br> "Plone: HelloType in action":img:helloworld-plone-shot.png
<br><br> Thats the trick. By the way: the title is always part of the schema. But don't worry: you can hide or recycle it later.</p>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                3.2.
                Basic Features
            </h1>

            <p class="documentDescription">Content Types, Fields, Widgets, References and Workflow</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.2.1.
                Classes / Content Types
            </h1>

            <p class="documentDescription">Use classes to generate content types and portal tools.</p>
    
            <div>
                
                    <p>Overview
<br><br> By default, when you create a class in your class diagram, it represents an 
<br> Archetypes content type. You can add operations in your model to generate 
<br> methods on the class, and attributes to generate fields in the schema. The 
<br> quick reference at the end of this tutorial will tell you which field types 
<br> you can use. You should also browse the "Archetypes quick reference 
<br> documentation":/documentation/manual/archetypes-developer-manual/fields to 
<br> see what properties are available for each field and widget type. You may set 
<br> these using tagged values (see below).
<br><br>There are three basic ways in which you can alter the way your content types 
<br>are generated:
<br><br>* You may set one or more stereotypes on your class, which alters the "type" of 
<br>  class. A stereotype '&lt;&lt;portal_tool&gt;&gt;', for example means you are generating a 
<br>  portal tool rather than just a simple content type.
<br><br>* You can use tagged values in your model to configure many aspects of your 
<br>  classes, their attributes and their methods. A list of recognised tagged 
<br>  values acting on classes, fields and methods are found in the "quick 
<br>  reference":archgenxmlquickref at the end of this tutorial.
<br><br> When reading tagged values, ArchGenXML will generally treat them as strings, 
<br> with a few exceptions where only non-string values are permitted, such as the 
<br> 'required' tagged value. If you do not wish your value to be quoted as a 
<br> string, prefix it with 'python:'. For example, if you set the tagged value 
<br> 'default' to 'python:["high", "low"]' on a 'lines' attribute, you will get 
<br> 'default=["high", "low"]' in a LinesField in your schema.
<br><br>* ArchGenXML is clever about aggregation and composition. If your class 
<br>  aggregates other classes, it will be automatically made into a folder with 
<br>  those classes as the allowed content types. If you use composition (signified 
<br>  by a filled diamond in the diagram) rather than aggregation, the contained 
<br>  class will only be addable inside the container, otherwise it will be addable 
<br>  globally in your portal by default.
<br><br>Variants of Content Types
<br><br> Simple Classes
<br><br>  A simple class is what we had in HelloWorld in the previous chapter. 
<br>  A simple class is based on 'BaseContent' and BrowserDefault'. This is the 
<br>  default if no other options override.
<br><br> Folderish Classes
<br><br>  The easiest way to make a content type folderish is to introduce composition 
<br>  or aggregation in your model - the parent class will become folderish and will 
<br>  be permitted to hold objects of the child classes. You can also make a class 
<br>  folderish just by giving it the '&lt;&lt;folder&gt;&gt;' stereotype. Both of these 
<br>  approaches will result in an object derived from 'BaseFolder'.
<br><br>  You can also give a class the '&lt;&lt;ordered&gt;&gt;' stereotype (possibly in addition 
<br>  to '&lt;&lt;folder&gt;&gt;') in order to make it derive from 'OrderedBaseFolder' and thus 
<br>  have ordering support. Alternatively, you can set the 'base_class' tagged 
<br>  value on the class to 'OrderedBaseFolder'. This is a general technique which 
<br>  you can use to override the base folder should you need to. As an aside, the 
<br>  'additional_parents' tagged value permits you to derive from multiple parents.
<br><br>  Another option is to derive from ATFolder (from ATContentTypes) by giving the
<br>  class the stereotype '&lt;&lt;atfolder&gt;&gt;'.
<br><br>  Other tagged values which may be useful when generating folders are:
<br><br>  filter_content_types -- Set this to '0' or '1' to turn on/off filtering of 
<br>  content types. If content types are not filtered, the class will act as a 
<br>  general folder for all globally addable content.
<br><br>  allowed_content_types -- To explicitly set the allowable content types, for 
<br>  example to only allow images and documents, set this to: 'Image, Document'. 
<br>  Note that if you use aggregation or composition to create folderish types as 
<br>  described above, setting the allowed content types manually is not necessary.
<br><br> Portal tools
<br><br>  A portal tool is a unique singleton which other objects may find via 
<br>  'getToolByName' and utilise. There are many tools which ship with Plone, 
<br>  such as portal_actions or portal_skins. To create a portal tool instead of 
<br>  a regular content type, give your class the '&lt;&lt;portal_tool&gt;&gt;' stereotype. 
<br>  Tools can hold attributes and provide methods just like a regular content 
<br>  type. Typically, these hold configuration data and utility methods for the 
<br>  rest of your product to use. Tools may also have configlets - configuration 
<br>  pages in the Plone control panel. See the quick reference at the end of this 
<br>  document for details on the tagged values you must set to generate configlets.
<br><br> Abstract mixin classes
<br><br>  By marking your class as 'abstract' in your model (usually a separate 
<br>  tick-box), you are signifying that it will not be added as a content type. 
<br>  Such classes are useful as mixin parents and as abstract base classes for more 
<br>  complex content types, and will not have the standard Archetypes registration 
<br>  machinery, factory type information or derive from BaseClass.
<br><br> Stub classes
<br><br>  By giving your class the '&lt;&lt;stub&gt;&gt;' stereotype, you can prevent it from being 
<br>  generated at all. This is useful if you wish to show content types which are 
<br>  logically part of your model, but which do not belong to your product. For 
<br>  instance, you could create a stub for Plone's standard Image type if you wish 
<br>  to include this as an aggregated object inside your content type - that is, 
<br>  your content type will become folderish, with Image as an allowable contained 
<br>  type. 
<br><br> Deriving/Subclassing Classes
<br><br>  Deriving or subclassing a class is used to extend existing classes, or change 
<br>  their behavior. Using generalisation arrows in your model, you can inherit 
<br>  the methods and schema from another content type or mixin class in your class.
<br><br>  Simple Derivation
<br><br>   All content types in Archetypes are derived from one of the base classes - 
<br>   BaseContent, BaseFolder, OrderedBaseFolder and so on. If you wish to turn 
<br>   this off, for example because the base class is being inherited from a 
<br>   parent class, you can set the 'base_class' tagged value to '0'.
<br><br>  Multiple Derivation
<br><br>   You can of course use multiple inheritance via multiple generalisation 
<br>   arrows in your model. However, if you need to use a base class that is not 
<br>   on your model, you can set the 'additional_parents' tagged value on your 
<br>   class to a comma-separated list of parent classes.
<br><br>  Deriving from other Products
<br><br>   If you want to derive from a class of an other product create a stub class 
<br>   with a tagged value 'import_from': This will generate a import line 
<br>   'from VALUE import CLASSNAME' in classes derived from this class.
<br><br>  Deriving form ATContentTypes
<br><br>   To derive from ATDocument just use a stereotype '&lt;&lt;atdocument&gt;&gt;'. Also 
<br>   possible with '&lt;&lt;atfile&gt;&gt;', '&lt;&lt;atevent&gt;&gt;' and '&lt;&lt;atfolder&gt;&gt;'.
<br><br>Packages - bring order to your code
<br><br>  Packages are both a UML concept and a Python concept. In Python, packages are 
<br>  directories under your product containing a set of modules (.py files). In 
<br>  UML, a package is a logical grouping of classes, drawn as a large "folder" 
<br>  with classes inside it. To modularise complex products, you should use 
<br>  packages to group classes together.</p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.2.2.
                Attributes / Fields / Indexing 
            </h1>

            <p class="documentDescription">How to control the fields of your schema.</p>
    
            <div>
                
                    <p>Archetypes
are using 'schemas' (also called 'schemata') with 'fields' to define
the form-fields on your content. The schema and its fields of your
content types is generated from the 'attributes' of your classes in
your model and their tagged values. Each field has a type and a widget.
<br><br>The "Archetypes
documentation":/documentation/manual/archetypes-developer-manual/ and
the quick reference at the end of this document describes which fields
are available and what parameters they take as configuration.
<br><br>Usage of tagged values 
<br><br> If you set a tagged value on an attribute of your class, in
general that tagged value will be passed through as a parameter to the
generated Archetypes field. Hence, if you set a tagged value
'enforceVocabulary' to the value '1' on an attribute, you will get
'enforceVocabulary=1' for that field in the generated schema.
Similarly, you can set a field's widget properties by prefixing the
tagged value with 'widget:'. 'widget:label' sets the label of a widget,
for instance.
<br><br>Non-string tagged values
<br><br> As before, when reading tagged values, ArchGenXML will
generally treat them as strings, with a few exceptions where only
non-string values are permitted, such as the 'required' tagged value.
If you do not wish your value to be quoted as a string, prefix it with
'python:'. For example, if you set the tagged value 'default' to
'python:["high", "low"]' on a 'lines' attribute, you will get
'default=["high", "low"]' in a LinesField in your schema.
<br><br>field recycling - copy from parents schema or another source schema and modify
<br><br> This feature alows you to copy a field from another source schema and rename the field.
<br><br> Rather than subclass an entire class then delete unwanted
fields, you can explicitly copy just the fields you need. You can keep
the copied field "as-is" or modify it by overriding properties with tag
values as needed.
<br><br> For example you may need a 'Description' field that is
usually defined in your parent classes (BaseContent, BaseFolder)
Schema. You would create a new attribute in your class named
'description' with a type of 'copy.' If you want it to appear in your
base_edit form rather then the default of properties/metadata page you
just need to change one property of the field by adding the tag
'schemata = "default"'.
<br><br> You may also copy from any other schema or from within the
same schema. You need to specify the source schema using the tag
'copy_from' and if you need to rename the field use the 'source_name'
tag to indicate the source field Id, otherwise the Id of the field in
you schema is used.
<br><br>Index and metadata in catalogs and Collection
<br><br> ArchgenXML can create configuration files to create an index and/or metadata entries in the catalog such as portal_catalog. 
<br><br> Available are the following tagged values: 
<br><br> 'catalog:index' -- add the field to the index. Boolean, 1 or
0. Default is 0. If set, you may need to provide 'index:*' tagged
values too.
<br><br> 'catalog:metadata' -- add the field to the metadata record on
the query result? Boolean, 1 or 0. If you do not provide
'index:attributes', the name of the accessor of the field is the
default. If 'catalog:metadata_accessor' is given it will be used
instead.
<br><br> 'catalog:metadata_accessor' -- the accessor used for the metadata (string).
<br><br> 'catalog:name' -- sometimes you need to add an index to a
other catalog than 'portal_catalog' and its XML-File 'catalog.xml'.
Provide a tuple of comma separated strings, id of the catalog and the
filename of its configuration file. default is "portal_catalog, Plone
Catalog Tool'.
<br><br> 'index:type' -- the type of index used as (string), for
example 'FieldIndex', 'KeywordIndex', 'DateIndex' or any available
index in your portal. For known types a default is guessed, such as
FieldIndex for StringFields or DateIndex for DateFields. If no guess is
possible, we assume a FieldIndex.
<br><br> 'index:attributes' -- the attributes to use for index (string
or comma separated list of strings). This are the methods called at
indexing time. Normally it is enough to provide one index method, but
for some specific use cases you might need to provide alternatives. If
you do not provide this tagged value, the name of the accessor of the
field is the default.
<br><br> 'index:name' -- the name of the index used (string). Use this
name in your queries. If you do not provide a name, the name of the
accessor of the field is the default.
<br><br> 'index:extras' -- some indexes are using so called 'extras'
on installation as configuration. If the index need extras you'll need
to declare them here. provide a comma separated list.
<br><br> 'index:properties' -- some indexes are using 'properties' on
installation as configuration. If the index need properties you'll need
to declare them here. Provide a comma separated list.
<br><br> 'collection:criteria' -- add the index to the Collection (aka
Smart Folder) Indexes available for defining Criteria. Provide a comma
seprated list of criteria that will be available by default. Available
criterias are: ATBooleanCriterion, ATDateCriteria,
ATDateRangeCriterion, ATListCriterion, ATPortalTypeCriterion,
ATReferenceCriterion, ATSelectionCriterion, ATSimpleIntCriterion,
ATSimpleStringCriterion, ATSortCriterion, ATCurrentAuthorCriterion,
ATPathCriterion, ATRelativePathCriterion. You must provide an
'index:type' as well.
<br><br> 'collection:criteria_label' -- the display name of the
'collection:criteria', called 'friendly name' (string). Its added to
the 'generated.pot' as a literal. If not given the 'widget:label' is
taken if provided.
<br><br> 'collection:criteria_description' -- a help text (string),
used for 'collection:criteria'. Its added to the 'generated.pot' as a
literal. if not provided the 'widget:description' is used. <br><br> 'collection:metadata' -- register the 'catalog:metadata' as
an available column in a Collection. Can be used as an alternative for
'catalog:metadata'. 'catalog:metadata_accessor' is used if given.
<br><br> 'collection:metadata_label' -- the display name of the
'collection:metadata', called 'friendly name' (string), used for
index:criteria. Its added to the 'generated.pot' as a literal. If not
given the 'widget:label' is taken if provided.
<br><br> 'collection:metadata_description' -- a help text (string),
used for 'collection:criteria'. Its added to the 'generated.pot' as a
literal. If not provided the 'collection:criteria_help' or - if not
provided - 'widget:description' is used.
<br><br> *DEPRECATED* For backward compatibility reasons we support a
sub part of the old style in ArchGenxML Version 1.6 and earlier using
the tagged value 'index'. This is deprecated and will be removed in one
of the next version of ArchGenXML. A tagged value 'index' with value
like 'index:type' above creates an index with the accessor. To include
the index in catalog metadata (and have the attribute ready to use in
the brain objects), append ':brains' (same as older ':schema'), (e.g.
'FieldIndex:brains'). ArchGenXML does longer provides the ability to
define multiple indexes using the old declaration style.</p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.2.3.
                Widgets
            </h1>

            <p class="documentDescription">Setting up the Widgets for each field.</p>
    
            <div>
                
                    <p>ArchGenXML
will pick a default widget for your fields and fill in default labels
and descriptions. For example, a 'string' field gets a 'StringWidget'
by default, but a 'selection' field type gets 'SelectionWidget' on a
StringField! You can override this in two ways. So ArchGenXML mixes up
fields and widgets slightly for convinience reasons. Anyway, you can
override all predefined definitions using widget options.
<br><br>Widget options are specified with the prefix 'widget:'. As
with normal field tagged values, unrecognised options will be passed
straight through to the widget definition.
<br><br>The most common widget options are:
<br><br>widget:type -- sets the widget type used. Its the name of the
widget class. You can use all widgets shipped within the
Archetypes-Framework by just providing this tagged value. To use
3rd-Party widgets you additionally need to import the class using the
*imports* tagged value on class level.
<br><br>widget:label -- sets the widget's label
<br><br>widget:description -- sets the widget's description
<br><br>widget:label_msgid -- overrides the default label message id (i18n)
<br><br>widget:description_msgid --  overrides the default description message id (i18n)
<br><br>widget:i18n_domain -- sets the i18n domain (defaults to the product name)
<br><br>You may also use widget-specific options, such as 'widget:size'
where they apply. Look up possible widget-specific options at the
documentation of the widget you want to use.
<br><br><br>Changing the default widgets
<br><br> To change the widget used for one field-type for a whole
model, a product, a package or just for all fields in one class you can
set on the product, package or class level the tagged value
'default:widget:FIELDNAMEABBREVIATION' to 'WIDGETNAME'. For example use
the tagged value 'default:widget:Reference' set it to
'ReferenceBrowserWidget' to use the ReferenceBrowserWidget instead of
the ReferenceWidget. You might also want to also use the 'imports'
tagged value and set it to 'from
ATReferenceBrowserWidget.ATReferenceBrowserWidget import
ReferenceBrowserWidget' on your class to ensure that you get the widget
definition imported into your class.
<br><br>Creating new widgets
<br><br> To define a new widget add a class to your model with the '&lt;&lt;widget&gt;&gt;' stereotype.</p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.2.4.
                Methods and Actions
            </h1>

            <p class="documentDescription">Defining Methods and Actions</p>
    
            <div>
                
                    <p>To
create a method in your class, add a method to the UML diagram, with
the desired parameters. The types of the parameters and the type of the
return value are ignored, since Python does not support this.
<br><br>Methods can different access specifiers (also called visibilities) These are:
<br><br>public (shown by a + before the method name) -- The method is
part of the class' public interface. It will be declared public
(accessible from unsafe/through-the-web code) by default. If you add a
tagged value 'permission' (see below), it will be declared as protected
by this permission.
<br><br>protected (#) -- The method is not part of the class' public
interface, but is meant for use by sub-classes. It will be declared
private to prevent unsafe code from accessing it.
<br><br>private (-) -- The method is internal to the class. It will be declared private to prevent unsafe code from accessing it.
<br><br>package (~) -- The method is intended to be accessed by other
code in the same module as the class. It will not gain any Zope
security assertions, relying instead on the class/module defaults.
<br><br>There are a few tagged values you can use to alter how the code is generated:
<br><br>code -- Sets the python code body of the method. Only use this
for short one-liners. If you fill in code manually in the generated
files, method bodies will be preserved when you re-generate the product
from the UML model.
<br><br>documentation -- Content of the python doc-string of the
method. You can also use the documentation feature of most UML
modellers to set documentation strings.
<br><br>permission -- Applies to methods with 'public' visiblity only.
If you set the permission tagged value to 'My custom permission'
results in security.declareProtected("""My custom
permission""",'methodname') - that is, access to your method is
protected by the permission with the name 'My custom permission'. <br><br> If you want to use the CMF core permissions, add an
'imports' tagged value to the method's class containing 'from
Products.CMFCore import permissions', and then set the permission
tagged value of your method to 'python:permissions.View',
'python:permissions.ModifyPortalContent' or any other core permission.
You can also use the common paradigm of defining permissions in
config.py as constants with names like EDIT_PERMISSION. A config.py is
automatically generated and its contents imported, so you can just set
the permission tagged value to, for example, 'python:EDIT_PERMISSION'.
<br><br>Archetypes uses actions for generating custom tabs to access
some view of an Archetype object. ArchGenXML can generate actions for
you: Just define a method without any parameters and set its stereotype
to &amp;lt;&amp;lt;action&amp;gt;&amp;gt;.
<br><br>Once again tagged values can be set on the sterotyped methods in order to set some properties of the action:
<br><br>action -- The TAL expression representing the action to be
executed when the user invokes the action. Defaults to the methodname.
<br><br>category -- The category of an action, view or form. Defaults to 'object'.
<br><br>id -- The id of an action, view or form. Defaults to the methodname.
<br><br>label -- The label of an action, view or form. Defaults to the methodname.
<br><br>permission -- 'permission=My permission' results in
'permissions': ('''My Permission''',). See the description of the
general 'permission' tagged value above for more.
<br><br>condition -- A TALES expression giving a condition to control when the action is to be made available.
<br><br>You can override the default Archetypes actions by using special names for the id. These are:
<br><br>view -- for overriding the default view action.
<br><br>edit -- for overriding the default edit action.
<br><br>contents -- for overriding the default contents action.</p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.2.5.
                Relationships between classes and objects
            </h1>

            <p class="documentDescription">How to use references, associations, aggregations and compositions</p>
    
            <div>
                
                    <p>With
aggregations, compositions and associations you define where your new
type will show up, what it might contain and to which content it can
point to.
<br><br>There is virtually no limit on how many aggregations, compositions and associations you can attach to a class.
<br><br>Aggregations: Global Containment "Aggrigation Img":img:aggregation.png
<br><br> Aggregation means: This content can exist global and in this
container. The container class that gets the empty rhomb (diamond)
attached is derived from BaseFolder and it's allowed_content_types is
set to the class that is attached to it.If more than class is attached
to one class by aggregations the allowed_content_types is extended
accordingly. The attached class keeps the default ``global_allow=1``.
<br><br>Compositions: Strict Containment "Composition Img":img:composition.png
<br><br> Compositions are used to model parts that exist or live and
die with their associated owner. So the code generated is similair to
the one generated by aggregations, but with one major difference: The
attached classes are only allowed to be generated in the folderish type
of the class they're attached to (this is done by setting
``global_allow=0`` in the factory type information of the class).
<br><br>Directed Associations: References "Directed Association Img":img:directedassociation.png
<br><br> References are used to store the relation of an object to other objects.
<br><br> Each content type that derives from ``IReferenceable`` is
capable of being referenced. Objects from such a content type have an
UID (Unique Identification) that's unique throughout the whole Plone
site. Therefore References don't break if you move referenced objects
around in the site.
<br><br> To use ``ReferenceFields`` there are two possible ways. The
by models-design clean way is to use directed associations. Another
possibility is to define References as class-attributes.
<br><br> Directed Associations
<br><br>  An directed association between two classes generates a ``ReferenceField`` in the class where the association starts. 
<br><br>  The ``relationship`` itself is named after the association's name. 
<br><br> The multiplicity defines if the allows a 1:1 or 1:n relation.
Attention: This only results in validation on the field. References at
all don't know anything about multiplicity, so this is only a check on
userinterface-level.
<br><br> All other field settings are taken from the association's
end, including information how to generate the widget. By default a
ReferenceWidget is used. You can use tagged values on the association's
end to define label, description, a different widget-type, schemata,
etc. like you do it on a field (on a class attribute).
<br><br> The big drawback of using associations to create
ReferenceFields is that they always get attached to the end of the
schema and there is no way to change that in the UML diagram. So if you
need order in your fields read the next section.
<br><br><br> References as class attributes
<br><br>  You can define an attribute with the type reference. Then you can apply any needed tagged values to it.
<br><br>  keys of interest are::
<br><br>    allowed_types : needs a list of allowed types
<br><br>    multiValued   : set to 0 to only be able to select one object to reference to
<br><br>    relationship  : name of the relationship in the reference_catalog
<br><br> The benefit of using an attribute to define the reference is
that you can define the place in the schema where the ReferenceField
will show up.
<br><br>Reference classes (advanced)
<br><br> Sometimes it's needed to store information not in the origin or 
<br>destination class, but in the reference itself. UML has a notation to 
<br>model this: "association
classes":http://argouml.tigris.org/documentation/defaulthtml/manual/ch17s11.html#s2.ref.association_multiway
<br><br> ArchGenXML support them automatically. When a model includes an 
<br>association class, two things occur:
<br><br>  a) A new content type is created, named like the association name
<br><br> b) The generated ReferenceField has a new attribute defined
like this: ``referenceClass =
ContentReferenceCreator('My_Association_Name')``
<br><br> This causes that the class of the reference instances is now
not "Archetypes.ReferenceEngine.Reference", but
"Archetypes.ReferenceEngine.ContentReference", a subclass of it that
has a new method: getContentObject(), that return the content inside
the <br>reference.
<br><br> The same effect can be reached without association classes, by defining 
<br>a content type and then adding the "association_class" tagged value to 
<br>the association (although I haven't been able to make this work).
<br><br> To create the reference via code, use a special form of the addReference method::
<br><br>    origin = &lt;the origin content&gt;
<br>    destination = &lt;the destination content&gt;
<br>    assocName = &lt;the association name&gt;
<br><br>    origin.addReference(destination,
<br>                        assocName,
<br>                 referenceClass=ContentReferenceCreator(assocName),
<br>                 attr1=value1,
<br>                 attr2=value2...)
<br><br>    (where attr1, attr2... are the attributes of the association)
<br><br> To read the data, we can't use the origin.getRefs(assocName)
method, as usual, because it returns only the destination objects. One
way to read it is by using the reference_catalog tool::
<br><br>    from Products.CMFCore.utils import getToolByName
<br>    tool = getToolByName(origin, 'reference_catalog')
<br>    refs = tool.getReferences(origin, assocName)
<br>    if not refs:
<br>        return []
<br>    else:
<br>        return [(ref.getContentObject(), ref.getTargetObject()) for ref in refs]</p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.2.6.
                Workflows
            </h1>

            <p class="documentDescription">Usage of state diagrams to create custom workflows.</p>
    
            <div>
                
                    <div><p>ArchGenXML
can use state diagrams to generate workflows for a portal type.
Workflows are used to set the various states an object can be in, and
the transitions between them. </p>
<p>Importantly, workflows control permissions of objects. By
convention, and for convenience and consistency, most content types
will use the permissions found in the <code>CMFCorePermissions</code>
class in the CMFCore product to control access to their methods. The
methods generated by and inherited from the CMF and Archetypes
frameworks adhere to this principle. Although many different content
types use the same basic permissions to control access, workflows are
the means by which you can control permissions for an object in detail.
For instance, you may wish to specify that in the <code>testing</code> state, Manager and Reviewer has <code>Modify portal content</code> permissions, and Owner, Manager and Reviewer has <code>View</code> permissions. For the <code>completed</code>
state, you could have a different set of permissions. See the
DCWorkflow documentation for more details about how to use workflows.</p>
<h2>Problems with UML-Software</h2>
<p> The workflow implementation of ArchGenXML has to date only been
tested with ArgoUML and Poseidon (tested Version is 3.1 and 3.2 CE).</p>
<p> ObjectDomain is known not to work at this time, because it does not
appear to correctly export the XMI for state diagrams. If you have
different experiences, please add a comment to this document or contact
us.</p>
<h2>Creating a workflow</h2>
<p> In your UML modeller, add a state diagram for the class you wish to
create a custom workflow for. If you don't want to assign the workflow
to a class use an class with stereotype <code>stub</code>. In
Poseidon, this is done by right-clicking on the object in the tree on
the left hand side, and selecting to add a new state diagram. The name
of the state diagram becomes the name of the workflow. </p>
<h2>States</h2>
<p> On the state diagram, add a state item (a rounded-corner box) for
each state. You must have an initial state of your workflow for it to
work correctly. Use a "initial state" symbol (filled cirlce) for the
state your object defaults to after creation. Optional you can use a
normal state item and set a tagged value <code>initial_state</code> with value 1 to it. </p>
<p> At present, ArchGenXML does not support the "final state" UML
symbols to represent final states, so you should stick to the standard
state symbols. </p>
<p> The names of your states in UML become the names of the states in your workflow. The user-visible label can be set with the <code>label</code> tagged value; it defaults to the state name.</p>
<p> <img src="developer-manual_archivos/workflow.jpg" alt="Workflow in UML"></p>
<h2>Transitions</h2>
<p> For each possible transition between states, add a transition arrow
to your UML model. The name of the transition becomes the name of the
workflow action. You can set the <code>label</code> tagged value on the transition to set a custom label to display to the user. </p>
<p>  If a transition with the same name/target is used more than one time, you can use the stereotype <code>&lt;&lt;primary&gt;&gt;</code> to define its settings once and use it by name on all similar transitions.</p>
<h3>  Transition guards</h3>
<p>    You can add a guard to a transition to restrict to whom and when it is made available. Set the <code>expression</code> field of a transition to a |-separated list of the following pairs:</p>
<dl><dt>    guard_roles</dt>
<dd>Set <code>guard_roles:Owner; Manager</code> to restrict the transition to users posessing the Owner or Manager role in the current context.</dd>
<dt>    guard_permissions</dt>
<dd>Set <code>guard_permissions:My custom permission;View</code> to ensure that only those users with <code>My custom permission</code> or <code>View</code> permissions in the current context are allowed to access the transition.</dd>
<dt>    guard_expr</dt>
<dd>Set 'guard_expr:expression", where <code>expression</code> is a
TALES expression, to have the expression be evaluated in order to
determine whether the transition should be made available.</dd>
</dl><p>    Thus, to restrict access to roles Reviewer and Manager, and only those users with permission <code>My custom permission</code> and <code>View</code> in the current context, you can set the expression of the transition to <code>guard_roles:Reviewer;Manager|guard_permissions:My custom permission, View</code>.</p>
<p>    If you are using Poseidon, transition guards are located in the property of the transition arrow with the name <code>[A] Guard</code>. You can add an expression like the one outlined above to this field.</p>
<h2>Permissions</h2>
<p> ArchGenXML uses tagged values on states in a somewhat
unconventional, though convenient, way to control permissions. With the
exception of the special-case <code>initial_state</code> and <code>label</code>
tagged values, you give the name of the permission as the tagged value
key, and a comma-separated list of roles the permission should be
enabled for as the value.</p>
<p>  There are three shorthand permission names available:</p>
<dl><dt>  access</dt>
<dd>referes to the <code>Access contents information</code> permission,</dd>
<dt>  view</dt>
<dd>refers to the <code>View</code> permission,</dd>
<dt>  modify</dt>
<dd>refers to the <code>Modify portal content</code> permission,</dd>
<dt>  list</dt>
<dd>refers to the <code>List folder contents</code> permission.</dd>
<dt>  delete</dt>
<dd>refers to the <code>Delete objects</code> permission.</dd>
</dl><p> Hence, if you want your state to permit anonymous users and
members to view your content, only permit managers to modify, and
permit both the owner and managers to add new objects controlled by the
<code>Add MySubTypes</code> permission, you can add tagged values to the workflow state:
</p><pre>    view           ==&gt; Anonymous, Member
    modify         ==&gt; Manager
    Add MySubTypes ==&gt; Owner, Manager
</pre>

<p>  If you want to aquire the permissions and add new ones you can use the value 'aquire':
</p><pre>    view           ==&gt; acquire, Anonymous, Member
</pre>

<p> (One special case: if you leave the value empty, no one gets that
permission (which is logical), but it also explicitly unsets
acquisition of the permission).</p>
<h2>Workflow actions</h2>
<p>  The <code>portal_workflow</code> tool allows a script to be
executed before and/or after a transition is completed. This is no
longer supported. Instead subscribers to the Workflow events are used.
Event-subsribers are more flexible.</p>
<p>  Actions are set using the <code>effect</code> field of a
transition. The value given here gives the name of the subscriber to
execute (and thus must be valid python method name). ArchGenXML will
create or modify a subscriber for each workflow-action in a file <code>wfsubsribers.py</code>
in your product. You must fill in the method bodies for the actions in
this file. Method bodies will be preserved upon re-generation of your
product from the UML model. In Plone 2.5 compatible mode DCWorkflow
needs a patch with a backport. This patch is generated, if <code>2.5</code> is selected as <code>plone_target_version</code> (tagged value on model).</p>
<p>  By default, actions specified in this way are post-transition actions, meaning that they are executed <em>after</em>
the transition has taken place. If you wish to specify a pre-transition
action, executed before the transition takes place, separate action
names by semicolons: <code>preActionName;postActionName</code>. If you want only a pre-transition action, use <code>preActionName;</code> to specify that there is an empty post-transition action.</p>
<h2>Attach workflow to more than one class</h2>
<p>  In UML there is no semantic to use a workflow for more than one class. We introduced the tagged value <code>use_workflow</code> for classes. Value is the workflow name.</p>
<h2>Worklist support</h2>
<p> You can attach objects in a certain state to a worklist. A worklist
is something like the "documents to review" list you get when you're a
reviewer in a Plone site. This is done by adding a tag <code>worklist</code> to the state with the name of the worklist as value (like <code>review_list</code>).</p>
<p>  You can add more than one state to a worklist, just by specifying the same name for the <code>worklist</code> tagged value. Likewise, you can have more than one worklist (just not on the same state). The tagged value <code>worklist:guard_permissions</code> allows you to specify the permission you need to have to view the worklist. The default value is <code>Review portal content</code>.
</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.2.7.
                Tests
            </h1>

            <p class="documentDescription">Generation of tests from UML.</p>
    
            <div>
                
                    <p>Overview
<br><br> We hope there is no need for us to emphasize how important
testing is for even the most simple products you may be developing.
This makes it especially useful to include the creation of both your
testing framework and individual tests within your UML model.
<br><br> Within a new package with a stereotype of
'&lt;&lt;tests&gt;&gt;' you can create your base test case class with a
stereotype of '&lt;&lt;plone_testcase&gt;&gt;' and a test setup class
with a stereotype of '&lt;&lt;setup_testcase&gt;&gt;'. You can then add
additional test classes as needed with a stereotype of either
'&lt;&lt;testcase&gt;' or '&lt;&lt;doc_testcase&gt;&gt;'.
<br><br> "sample UML":img:uml-testcase.png
<br><br>Base Test Case
<br><br> Creating a class in your tests package with a stereotype of
'&lt;&lt;plone_testcase&gt;&gt;' generates the needed base test case
for all other test cases.
<br><br>Test Setup
<br><br> Creating a class in your tests package with a stereotype of
'&lt;&lt;setup_testcase&gt;&gt;' generates a testcase for the setup,
with pre-defined common checks.
<br><br>Test Cases
<br><br> Test Case
<br><br>  Creating a class in your tests package with a stereotype of '&lt;&lt;testcase&gt;&gt;' generates a standard test case class.
<br><br> Doc Tests
<br><br> Creating a class in your tests package with a stereotype of
'&lt;&lt;doc_testcase&gt;&gt;' generates a doc test file in the 'doc'
folder of your product with a name of 'class + .txt'. You can use the
tag of 'doctest_name' on your class (excluding any extension as '.txt'
is appended automatically) to indicate a different name for your
generated doc test.
<br><br> Functional Tests
<br><br>  Generate browser functional tests using the '&lt;&lt;plonefunctional_testcase&gt;' stereotype.
<br><br> Interface Tests
<br><br>  Generate interface tests using the '&lt;&lt;interface_testcase&gt;&gt;' stereotype.
<br><br>  It is unverified whether these generated test cases will verify Z3 style interfaces but stay tuned!</p>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                3.3.
                Third Party Product Integration
            </h1>

            <p class="documentDescription">The usage of add on products.</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.3.1.
                ATVocabularyManager
            </h1>

            <p class="documentDescription">ATVocabularyManager
is a product for letting site managers define vocabularies for fields
through-the-web or by import from XML files. ArchGenXML can generate
the necessary code to use this product.</p>
    
            <div>
                
                    <p>ATVM
manages dynamic vocabularies. It installs a tool, where a site Manager
can add, change and delete vocabularies. These vocabularies can then be
used anywhere on the site.
<br><br>You can download ATVocabularyManager from the Plone.org
products area:
"http://plone.org/products/atvocabularymanager":/products/atvocabularymanager
<br><br>Using simple flat vocabularies
<br><br> Adding ATVM-vocabs to your UML model is quite easy. 
<br><br> 1. Add a selection or multiselection field to your type.
<br><br> 2. Add a tag 'vocabulary:name' and give it a name, let's say 'countries'
<br><br> 3. Add a tag 'vocabulary:type' with the value 'ATVocabularyManager'
<br><br> We are now finished with the UML. Save it and let AGX do the
work. What still is missing, is to install the countries vocabulary.
Therefore:
<br><br> * Add a function called 'setupVocabularies' to the protected
code section in 'setuphandlers.py' in your product and register it as
an import step in '/profiles/default/import_steps.xml' in a code
section (make it dependend from you '*QI-Dependencies' step.
<br><br> * Add the following code to your setuphandler.yp (this sets
up a vocabulary 'countries' with the given values, and registers it
with ATVocabularyManager)::
<br><br><br>   from Products.ATVocabularyManager.config import TOOL_NAME as ATVOCABULARYTOOL
<br>   from Products.CMFCore.utils import getToolByName
<br>   from Products.ATVocabularyManager.utils.vocabs import createSimpleVocabs
<br><br>   def setupVocabularies(context):
<br>     """let's install the countries vocab"""
<br><br>     vocabs = {}
<br>     vocabs['countries'] = (
<br>            ('ice', u'Iceland'),
<br>            ('nor', u'Norway'),
<br>            ('fin', u'Finland'),
<br>            ('tyr', u'Tyrol'),
<br>            ('auf', u'Ausserfern'),
<br>        )
<br>     site = context.getSite()
<br>     atvm = getToolByName(site, ATVOCABULARYTOOL)
<br>     createSimpleVocabs(atvm, vocabs)
<br><br>Using simple tree vocabularies
<br><br> If youre interested in using and creating hierachical vocab:
<br><br> * use additional tag 'vocabulary:vocabulary_type' with value 'TreeVocabulary',
<br><br> * have a look at the doc-string of 'Products.ATVocabularyManager.utils.createHierarchicalVocabs'.
<br><br>Using vocabularies based on the **IMS Vocabulary Definition Exchange** (VDEX) format.
<br><br> "VDEX":http://www.imsglobal.org/vdex/index.html is a simple
XML based format to define flat or hierachical multilingual
vocabularies. ATVocabularyManager supports VDEX in most of its
dialects. <br><br> To tell Archetypes to use them in your UML first take Steps
1 to 3 of the first section and skip the import part. Then add a tag
'vocabulary:vocabulary_type' and give it the value 'VdexVocabulary'.
<br><br> Now add a folder called 'data' in your products folder.
Inside the '/data' folder create a new file called 'countries.vdex'
("example":countries.vdex). It will be imported automatically on
install or reinstall, but only if a vocabulary named countries does not
exist.</p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.3.2.
                Relations
            </h1>

            <p class="documentDescription">Create
relations between portal-types model-driven. Support for Relations
Product (complex references). Define sets of rules for validation,
creation and lifetime of Archetypes references. ArchGenXML can generate
the necessary code and XML-configuration data to use this product.</p>
    
            <div>
                
                    <p>Prerequisites
<br><br> To enable Relations install the Product ("code-location":http://plone.org/products/relations/).
<br><br>Basics
<br><br> As an option on command line,  up to a tagged-value on model-level or on a single UML-Association you just define the 
<br>'relation_implementation' and set it to 'relations'. A directed Assoziation results in one Relation. 
<br><br> **Give the association and its assoziation ends names.**
They'll be used as the names for the RelationField. If you dont want a
field turn it off by setting a tagged value 'generate_reference_fields'
on class (or package, model) level to '0'.
<br><br>Inverse Relation
<br><br> If the association is not directed (navigable on both association ends) an inverse relation will be created. 
<br><br> The tagged-value 'inverse_relation_name' will be used for the
back-relation on undirected associations. It defaults to a relation
named 'toend_fromend', where these are the lowercased versions of the
association ends. If the two ends are named the same, then the relation
will be named 'association_inv', where 'association' is the name of the
association. (Finally, if the option 'old_inverse_relation_name' is
set, then it defaults to the association name postfixed by '_inverse'.)
<br><br>Cardinality
<br><br> You can use the Multiplicity on in UML to  define the cardinality of an Relation. 
<br>You can use the minimum and maximun value here using the syntax
'1..5' which means at least one relationrelated objects but not more
than five.
<br><br>Constraints
<br><br> type-constraint -- as described above an association between two portal-types will be created.
<br><br> interface-constraint -- an association between an archetypes
class and an interface will create an interface-constraint. the
relation is allowed to all classes implementing this interface.
<br><br>Association classes
<br><br> Association classes can be used to store data on the relation
as an object. You can model it using the UML association class or using
a tagged value 'association_class' on the association.</p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.3.3.
                Remember
            </h1>

            <p class="documentDescription">Generate 'Remember' based Member-Types. Its the successor of CMFMember.</p>
    
            <div>
                
                    <p>Prerequisites
<br><br> You must install to additional Products:
<br><br> * "membrane":http://plone.org/products/membrane
<br><br> * "remember":http://plone.org/products/remember
<br>   (using "Five 1.4.3+":http://codespeak.net/z3/five/)
<br><br> You should also read the documentation of both and understand how they work!
<br><br>A Content-Type based on remember
<br><br> * Create a class in your class diagram and give it a a stereotype '&lt;&lt;remember&gt;&gt;'
<br><br> * add the tagged value 'use_workflow' and set it to one of 
<br>   'member_approval_workflow' or 'member_auto_workflow'. You can create also your 
<br>   own workflow if you know what remember needs (look at the workflows shipped 
<br>   with remember).
<br><br> * set the 'active_workflow_states' tagged value to the class and declare which
<br>   states of the used workflow are the ones, where the user can log in with. 
<br>   It expects a list of values, e.g. 'python:["private", "public"]'
<br><br> * Add attributes (fields) as you need. Attention here, only override fields
<br>   of remembers BaseMember schema if you know what youre doing.
<br><br> * Generate &amp;amp; Done</p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.3.4.
                CompoundField and ArrayField
            </h1>

            <p class="documentDescription">How to make custom fields: a list of some default field type, a compound of a two or more default fields.</p>
    
            <div>
                
                    <p>Prerequisites
<br><br> Install the "CompoundField":http://plone.org/products/compoundfield extension 
<br> into you Products folder.
<br><br>List of fields - ArrayField
<br><br> Assume you want to have content type where the user can provide one or more files. 
<br> Its easy by making the type folderish. But for some use-cases this is to heavy or to 
<br> difficult, you want the user to use a form for those files.
<br><br> You could say, ok, up to 5 files is enough and model 5 file fields into your class. 
<br> Not very elegant, huh?
<br><br> The easiest way is to to use the UML 'multiplicity' feature on your attribute aka field of the 
<br> class. If you want to enable unlimited attachments use multiplicity '*'. 
<br> Or choose a number like '5', as in our above example.
<br><br> You can set the initial size of the array by using the tagged value 'array:size' to 'python:10' for example. 
<br> Prefixed with 'array:' you can access also the label 'array:widget:label' of it and so on. 
<br> If you prefer the EnhancedArrayWidget you need to add an tagged value 'imports' 
<br> 'from Products.Compoundfield.EnhancedArrayWidget import EnhancedArrayWidget' to your class 
<br> and set on the attribute the tagged value 'array:widget:type' to 'EnhanceArrayWidget'.
<br><br>Custom Fields compounds - CompoundField
<br><br> With ArchGenXML you can create compounds of fields from existing fields. 
<br> Such a set of fields behaves almost like a normal field. 
<br> To create such a compounded field create a new class and give it the 
<br> stereotype '&amp;lt;&amp;lt;field&amp;gt;&amp;gt'
<br><br> Now add attributes to it like you would do on a content type class. 
<br> You can use almost every field type, just some special fields, mostyl those 
<br> acting as a proxy without own storage, wont work (such as ReferenceField or AttachementField). 
<br><br> For example we create a 'PointField' consisting out of two 'FloatFields' by 
<br> just adding a 'x' and 'y' attribute of type 'float'.
<br><br> To use the new field create a fresh content class and name it 'Polygon'. 
<br> Take a dependency arrow pointing from your Polygon class to the field class. 
<br> This ensures it gets imported! 
<br><br> Next add an attribute 'points' to the class. The type of the new points attribute 
<br> is 'PointsField'. Now to make it a polygon give it a multiplicity of *and 
<br> your done: You have a list of Points as one field.</p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.3.5.
                Content Flavors
            </h1>

            <p class="documentDescription">When
you want to add a couple of fields to an existing content type
(including reference fields), you may decide to create a whole new
product that subclasses that type. You then have a whole bunch of code
to maintain and you are dependent on changes that may occur in your
parent class. Or you let ArchGenXML use the Content Flavors product and
your day gets brighter.
Note that the use of the experimental content flavors product is now
deprecated in favor of the more reliable and feature-rich
archetypes.schemaextender.</p>
    
            <div>
                
                    <div><h2>Prerequisites</h2>

<p>You must install the <a href="http://plone.org/products/contentflavors">Content Flavors</a> product.</p>

<h2>Adding a field to an existing content typ</h2>

<ol><li>Let an existing content type, e.g. <em>"ExistingType"</em>, be present in your diagram (as a&nbsp;<strong>class</strong> with stereotypes <span class="visualHighlight">&lt;&lt;archetype&gt;&gt;</span> and <span class="visualHighlight">&lt;&lt;stub&gt;&gt;</span>)</li><li>Create a <strong>class</strong>, e.g. <em>"MyCoolFlavor"</em>, in your diagram and give it the <span class="visualHighlight">&lt;&lt;flavor&gt;&gt;</span> stereotype</li><li>Add any field(s), e.g. <em>"MyAdditionalField",</em> to this flavor class</li><li>Create a <strong>realization</strong> arrow from <em>"ExistingType"</em> to <em>"MyCoolFlavor"</em></li><li>Generate &amp; Done</li></ol><p>Now every new instance of <em>ExistingType</em> will have the <em>MyAdditionalField</em> field in its schema, default view and default edit form.</p>

<h2>Limits</h2>

<ul><li>

<blockquote class="pullquote"><strong>The use of the experimental
content flavors product is now deprecated in favor of the more reliable
and feature-rich archetypes.schemaextender.</strong></blockquote>

</li><li>Content Flavors also allows <strong>custom views</strong> to be used by existing types but this feature is not supported by ArchGenXML yet.</li><li>You
may not be able to see the additional field(s) if the ExistingType uses
some non-default view. You then have to manually manage this by <strong>overriding these existing views</strong> with some of your own, with or without the help of the Content Flavors product.</li><li>The existing content type may have to be based on ATCT (to be tested)?<br></li><li>Several
flavors can be applied to a given type. The order of precedence can be
managed through the web if the existing type follows some requirements
detailed in the <a href="http://plone.org/products/contentflavors/documentation">Content Flavors documentation</a>.</li><li>There are possible issues with indexing the additional fields, see <a href="http://plone.org/products/contentflavors/documentation">CF documentation for details</a>.</li><li>Content Flavors was an experiment and is now deprecated in favour of the <a href="http://plone.org/products/realestatebroker/documentation/how-to/customize-the-fields-of-the-content-types">archetypes.schemaextender</a>, which is also supported by AGX.</li></ul></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.3.6.
                archetypes.schemaextender
            </h1>

            <p class="documentDescription">When
you want to add a couple of fields to an existing content type
(including reference fields), you may decide to create a whole new
product that subclasses that type. You then have a whole bunch of code
to maintain and you are dependent on changes that may occur in your
parent class. Or you let ArchGenXML make your product use
archetypes.schemaextender and your day gets brighter.</p>
    
            <div>
                
                    <div><h2>Prerequisites</h2>

<p>You must install the <a class="external-link" href="http://pypi.python.org/pypi/archetypes.schemaextender">archetypes.schemaextender</a> product.</p>

<h2>Adding a field to an existing content type<br></h2>

Let's say you want to add <em>superPower</em> (a field) to <em>HumanBeing</em>

<p> (a class).</p>

<ol><li>Let the content type to extend, e.g. <em>"HumanBeing"</em>, be present in your diagram (as a&nbsp;<strong>class</strong>, possibly with the <span class="visualHighlight">&lt;&lt;stub&gt;&gt;</span> stereotype)</li><li>Create an <strong>interface</strong>, e.g. "<em>ISuperHero</em>" (the "I" helps remembering this is an interface), in your diagram ; it has the <span class="visualHighlight">&lt;&lt;interface&gt;&gt;</span> stereotype</li><li>Draw a <strong>realization</strong> arrow from "<em>HumanBeing</em>" to "<em>ISuperHero</em>"<br></li><li>Create a <strong>class</strong>, e.g. <em>"SuperHero"</em>, in your diagram and give it the <span class="visualHighlight">&lt;&lt;extender&gt;&gt;</span> stereotype</li><li>Add any <strong>field</strong>(s), e.g. <em>"superPower"</em><em>,</em> to this extender</li><li>Create a <strong>realization</strong> arrow from the extender class to the interface, e.g. from <em>"SuperHero</em><em>"</em> to <em>"ISuperHero</em><em>"</em>, remove its  <span class="visualHighlight">&lt;&lt;realize&gt;&gt;</span> stereotype and replace it with a  <span class="visualHighlight">&lt;&lt;adapts&gt;&gt;</span> stereotype</li><li>Generate &amp; Done</li></ol><p>Now every new instance of <em>HumanBeing</em> will have the <em>superPower</em> field in its schema, default view and default edit form. And even if the developer of the <em>HumanBeing</em>
content type decides to remove its arms or legs, human beings (all of
them) will still have super powers because you declared they are super
heros (they implement <em>ISuperHero</em>).</p>

<p>Note that, in order to add these stereotypes (<span class="visualHighlight">&lt;&lt;extender&gt;&gt;</span>, <span class="visualHighlight">&lt;&lt;adapts&gt;&gt;</span>)
to your (Argo)UML model, you have to create a
stereotype, give it the proper name (extender, adapts) and select its
proper "Super-class" in the properties tab (you either select
class for class stereotypes, or abstraction for the "adapts"
stereotype).</p>

<h2>Example model and additional features<br></h2>

<p>AGX support of archetypes schemaextender is illustrated by the example model in the screenshot below :</p>

<p><img src="developer-manual_archivos/Capture.png" alt="screenshot of a model showing how to use AGX with schemaextender"></p>

<p>You may note from this example model that AGX support of archetypes.schemaextender comes with a bunch of funny features :</p>

<ul><li>support for <a class="external-link" href="http://plone.org/documentation/tutorial/borg/a-whirlwind-tour-of-zope-3/">adapters and named adapters</a></li><li>adapted interfaces (or classes) can be external to your model

(using the   <span class="visualHighlight">&lt;&lt;stub&gt;&gt;</span> stereotype)</li><li>you can even let a stub class implement a

stub interface : in the example above, the <em>HumanBeing </em>stub class has a realization arrow to <em>IAStubInterfaceFromYetAnotherProduct</em>,
which will be turned by AGX into a
five:implement ZCML declaration. This is useful when you want to
integrate 2 distinct third party products via your own product. Your
model is then nothing more than a "glue" model, which is a good thing
in many cases.<br></li></ul></div>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                3.4.
                Reference
            </h1>

            <p class="documentDescription">Reference of Stereotypes, Tagged Values and more.</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.4.1.
                Quick Reference
            </h1>

            <p class="documentDescription">A quick reference sheet.</p>
    
            <div>
                
                    <p>**TODO: UPDATE!**
<br><br>Complete list of the field types including their default settings:
<br><br> string -- StringField
<br><br>  - StringField
<br><br>  - searchable=1
<br><br> text -- TextField
<br><br>  - StringField
<br><br>  - searchable=1
<br><br>  - TextAreaWidget()
<br><br> richtext -- TextField
<br><br>  - TextField
<br><br>  - default_output_type=text/html
<br><br>  - allowed_content_types=('text/plain','text/structured','text/html','application/msword',)
<br><br> selection -- StringField with SelectionWidget
<br><br>  - StringField
<br><br> multiselection -- LinesField with SelctionWidget
<br><br>  - LinesField
<br><br>  - multiValued=1
<br><br> integer -- IntegerField
<br><br>  - IntegerField
<br><br>  - searchable=1
<br><br> float -- Floatfield
<br><br>  - FloatField
<br><br>  - searchable=1
<br><br>  - DecimalWidget()
<br><br> boolean -- BoleanField
<br><br>  - BooleanField
<br><br>  - searchable=1
<br><br> lines -- LinesField
<br><br>  - LinesField
<br><br>  - searchable=1
<br><br> date -- DateTimeField
<br><br>  - DateTimeField
<br><br>  - searchable=1
<br><br> image -- ImageField
<br><br>  - ImageField
<br><br>  - sizes ={'small':(100,100),'medium':(200,200),'large':(600,600)}
<br><br>  - AttributeStorage()
<br><br> file -- FileField
<br><br>  - FileField
<br><br>  - AttributeStorage()
<br><br>  - FileWidget()
<br><br> lines -- LinesField
<br><br>  - LinesField
<br><br>  - searchable=1     
<br><br> fixedpoint -- FixedPointField
<br><br>  - FixedPointField
<br><br> reference -- ReferenceField
<br><br>  - ReferenceField
<br><br> backreference -- BackReferenceField
<br><br>  - BackReferenceField
<br><br> computed -- ComputedField
<br><br>  - ComputedField
<br><br> color -- StringField w/Color picker
<br><br>  - StringField
<br><br> country -- StringField
<br><br>  - StringField
<br><br>  - CountryWidget
<br><br> datagrid -- DataGridField
<br><br>  - DataGridField
<br><br>  - DataGridWidget
<br><br> photo -- PhotoField
<br><br>  - PhotoField
<br><br>Tagged values for fields:
<br><br> searchable -- register and index the field in the catalog, 
<br><br>  * 1 .. register and index 
<br><br>  * 0 .. don't register and index
<br><br> storage -- AttributeStorage(), SQLStorage(), ....
<br><br> sizes --  defines the sizes of the images in a ImageField
<br>  example: python:{'small':(80,80),'medium':(200,2000),'large':(600,600)}
<br><br> default_method -- no idea what that does 
<br><br> required -- defines whether a field should be rendered required, or not. 
<br><br>  - 1 .. field is required
<br><br>  - 0 .. field is not required
<br><br> accessor -- defines the accessor of a field
<br><br> vocabulary -- defines the vocabulary or the method generating a vocabulary
<br><br> allowed_types -- defines the allowed types in a ReferenceField
<br><br> relationship -- defines the relationship, used in a ReferenceField
<br><br> multiValued -- defines whether a SelectionField accepts one or more values, 
<br><br>   - 1 .. multivalued
<br><br>   - 0 .. singlevalued
<br><br><br> These tagged values are just the ones handy for fields, the full lists of tagged values
<br>and stereotypes are shown on the next two pages.</p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.4.2.
                Tagged Values
            </h1>

            <p class="documentDescription">All tagged values available in its context. </p>
    
            <div>
                
                    <p>*This
file was generated 2009-05-12 with bin/agx_taggedvalues 2.4.1. Don't
forget to replace &amp;lt;&amp;lt; by &amp;amp;lt;&amp;amp;lt; and
&amp;gt;&amp;gt; by &amp;amp;gt;&amp;amp;gt; on this page.*
<br><br>action
<br><br> action -- For a stereotype 'action', this tagged value can be used to
<br>    overwrite the default URL ('..../name_of_method') into
<br>    '..../tagged_value'.
<br><br> category -- The category for the action. Defaults to 'object'.
<br><br> condition -- A TALES expression defining a condition which will be
<br>    evaluated to determine whether the action should be displayed.
<br><br> id -- The id of the action. Use 'id',
<br><br> label -- The label of the action - displayed to the user.
<br><br> permission -- The permission used for the action, a string or comma
<br>    separated list of strings, default to 'View'.
<br><br> visible -- Sets the visible property, default to 'True'
<br><br><br>association
<br><br> association_class -- You can use associations classes to store content
<br>    on the association itself. The class used is specified by this
<br>    setting. Don't forget to import the used class properly.
<br><br> association_vocabulary -- Switch, defaults to False. Needs Product
<br>    'ATVocabularyManager'. Generates an empty vocabulary with the name
<br>    of the relation.
<br><br> back_reference_field -- Use a custom field instead of ReferenceField.
<br><br> field -- Synonymous with either reference_field or relation_field,
<br>    depending on whether you use it on the *from* end or the *to* end of
<br>    a relation. Works only together with 'Relations' Product and
<br>    relation_implementation set to 'relations'.
<br><br> inverse_relation_name -- Together with 'Relations' Product you have
<br>    inverse relations. the name default to
<br>    'name_of_your_relation_inverse', but you can overrrule it using this
<br>    tagged value.
<br><br> label -- Sets the readable name.
<br><br> reference_field -- Use a custom field instead of ReferenceField.
<br><br> relation_field -- Use a custom field instead of RelationField. Works
<br>    only together with 'Relations' Product and relation_implementation
<br>    set to 'relations'.
<br><br> relation_implementation -- Sets the type of implementation is used for
<br>    an association: 'basic' (used as default) for classic style
<br>    archetypes references or 'relations' for use of the 'Relations'
<br>    Product.
<br><br> relationship -- Standard relationship for ReferenceField
<br><br><br>attribute
<br><br> accessor -- Set the name of the accessor (getter) method. If you are
<br>    overriding one of the DC metadata fields such as 'title' or
<br>    'description' be sure to set the correct accessor names such as
<br>    'Title' and 'Description'; by default these accessors would be
<br>    generated as getTitle() or getDescription().
<br><br> allowed_types -- Sets the types allowed for a ReferenceField. Default
<br>    is []
<br><br> array:widget -- specify which custom ArrayWidget should be used for a
<br>    field (only applies if the field has cardinality &gt;1.
<br><br> catalog:index -- Add the field (or all fields of a class, package,
<br>    model) to the index. Boolean, 1 or 0. Default is 0. If set, you may
<br>    need to provide 'index:*' tagged values too.
<br><br> catalog:metadata -- Adds the field to the metadata record on the query
<br>    result. Boolean, 1 or 0. If you do not provide 'index:attributes',
<br>    the name of the accessor of the field is the default. If
<br>    'catalog:attributes' is given for each attribute one field at the
<br>    record will be created.
<br><br> catalog:name -- Sometimes you need to add an index to a other catalog
<br>    than 'portal_catalog' and its XML-File 'catalog.xml'. Provide a
<br>    tuple of comma separated strings, id of the catalog and the filename
<br>    of its configuration file. default is "portal_catalog, Plone Catalog
<br>    Tool'.
<br><br> collection:criteria -- Add the index to the Collection (aka Smart
<br>    Folder) Indexes available for defining Criteria. Provide a comma
<br>    separated list of criteria that will be available by default.
<br>    Available criterias are: ATBooleanCriterion, ATDateCriteria,
<br>    ATDateRangeCriterion, ATListCriterion, ATPortalTypeCriterion,
<br>    ATReferenceCriterion, ATSelectionCriterion, ATSimpleIntCriterion,
<br>    ATSimpleStringCriterion, ATSortCriterion, ATCurrentAuthorCriterion,
<br>    ATPathCriterion, ATRelativePathCriterion. You must provide an
<br>    index:type as well.
<br><br> collection:criteria_description -- A help text (string), used for
<br>    collection:criteria. Its added to the generated.pot as a literal. If
<br>    not provided the widget:description is used.
<br><br> collection:criteria_label -- The display name of the
<br>    collection:criteria, called friendly name (string). Its added to the
<br>    generated.pot as a literal. If not given the widget:label is taken
<br>    if provided.
<br><br> collection:metadata -- register the catalog:metadata as an available
<br>    column in a Collection. Can be used as an alternative for
<br>    catalog:metadata. catalog:metadata_accessor is used if given.
<br><br> collection:metadata_description -- A help text (string), used for
<br>    collection:criteria. Its added to the generated.pot as a literal. If
<br>    not provided the collection:criteria_help or - if not provided -
<br>    widget:description is used.
<br><br> collection:metadata_label -- the display name of the
<br>    collection:metadata, called friendly name (string), used for
<br>    index:criteria. Its added to the generated.pot as a literal. If not
<br>    given the widget:label is taken if provided.
<br><br> copy_from -- To copy an attribute from another schema, give it the type
<br>    'copy'. The tagged value 'copy_from' is then used to specify which
<br>    schema to copy it from (for instance, 'BaseSchema' when copying
<br>    Description from the base schema). For copying your own schemas, add
<br>    an 'imports' tagged value to import your class (say 'MyClass') and
<br>    then put 'MyClass.schema' in your 'copy_from' value.
<br><br> default -- Set a value to use as the default value of the field.
<br><br> default_method -- Set the name of a method on the object which will be
<br>    called to determine the default value of the field.
<br><br> enforceVocabulary -- Set to true (1) to ensure that only items from the
<br>    vocabulary are permitted.
<br><br> expression -- evaluation expression for computed fields.
<br><br> i18ncontent -- Enables the content type(s) for LinguaPlone. Only
<br>    allowed value is 'linguaplone'.
<br><br> index -- DEPRECATED: Add an index to the attribute. Use catalog:index
<br>    and the index:* tagged value instead.
<br><br> index:attributes -- The attributes to use for index or metadata (string
<br>    or comma separated list of strings). This are the methods called at
<br>    indexing time. Normally it is enough to provide one index method,
<br>    but for some specific use cases you might need to provide
<br>    alternatives. If you don not provide this tagged value, the name of
<br>    the accessor of the field is the default.
<br><br> index:extras -- Some indexes are using so called 'extras' on
<br>    installation as configuration. If the index need extras you'll need
<br>    to declare them here. Provide a comma separated list.
<br><br> index:name -- the name of the index used (string). Use this name in
<br>    your queries. If you do not provide a name, the name of the accessor
<br>    of the field is the default.
<br><br> index:properties -- Some indexes are using 'properties' on installation
<br>    as configuration. If the index need properties you'll need to
<br>    declare them here. Provide a comma separated list.
<br><br> index:type -- the type of index used as (string), for example
<br>    'FieldIndex', 'KeywordIndex', 'DateIndex' or any available index in
<br>    your portal. For known types a default is guessed, such as
<br>    FieldIndex for StringFields or DateIndex for DateFields. If no guess
<br>    is possible, we assume a FieldIndex.
<br><br> indexMethod -- DEPRECATED: Declares method used for indexing.
<br><br> label -- Sets the readable name.
<br><br> move:after -- Move the current field after the given field (put the
<br>    field name between quote).
<br><br> move:before -- Move the current field before the given field (put the
<br>    field name between quote).
<br><br> move:bottom -- Move the current field to the bottom (put 1 for the
<br>    value).
<br><br> move:pos -- Move the current field at the given position (an int).
<br><br> move:top -- Move the current field to the top (put 1 for the value).
<br><br> multiValued -- Certain fields, such as reference fields, can optionally
<br>    accept more than one value if multiValued is set to true (1)
<br><br> mutator -- Similarly, set the name of the mutator (setter) method.
<br><br> original_size -- Sets the maximum size for the original for an
<br>    ImageField widget.
<br><br> read_permission -- Defines archetypes fields read-permission. Use it
<br>    together with workflow to control ability to view fields based on
<br>    roles/permissions.
<br><br> required -- Set to true (1) to make the field required
<br><br> schemata -- If you want to split your form with many, many attibutes in
<br>    multiple schemata ("sub-forms"), add a tagged value 'schemata' to
<br>    the attributes you want in a different schemata with the name of
<br>    that schemata (for instance "personal data"). The default schemata
<br>    is called "default", btw.
<br><br> searchable -- Whether or not the field should be searchable when
<br>    performing a search in the portal.
<br><br> sizes -- Sets the allowed sizes for an ImageField widget.
<br><br> source_name -- With attribute type 'copy' sometimes schema-recycling is
<br>    fun, together with copy_from you can specify the source name of the
<br>    field in the schema given by copy_from.
<br><br> validation_expression -- Use an ExpressionValidator and sets the by
<br>    value given expression.
<br><br> validation_expression_errormsg -- Sets the error message to the
<br>    ExpressionValidator (use with validation_expression to define the
<br>    validation expression to which this error message applies).
<br><br> validators -- TODO. Not supported for now.
<br><br> vocabulary -- Set to a python list, a DisplayList or a method name
<br>    (quoted) which provides the vocabulary for a selection widget.
<br><br> vocabulary:name -- Togther with Products 'ATVocabularyManager' this
<br>    sets the name of the vocabulary.
<br><br> vocabulary:term_type -- For use with 'ATVocabularyManager'. Defaults to
<br>    'SimplevocabularyTerm'. Let you define the portal_type of the
<br>    vocabularyterm used for the default term that is created in
<br>    Install.py.
<br><br> vocabulary:type -- Enables support for Products 'ATVocabularyManager'
<br>    by setting value to 'ATVocabularyManager'.
<br><br> widget -- Allows you to set the widget to be used for this attribute.
<br><br> widget:description -- Set the widget's description.
<br><br> widget:description_msgid -- Set the description i18n message id.
<br>    Defaults to a name generated from the field name.
<br><br> widget:i18n_domain -- Set the i18n domain. Defaults to the product
<br>    name.
<br><br> widget:label -- Set the widget's label.
<br><br> widget:label_msgid -- Set the label i18n message id. Defaults to a name
<br>    generated from the field name.
<br><br> widget:type -- Set the name of the widget to use. Each field has an
<br>    associated default widget, but if you need a different one (e.g. a
<br>    SelectionWidget for a string field), use this value to override.
<br><br> write_permission -- Defines archetypes fields write-permission. Use it
<br>    together with workflow to control ability to write data to a field
<br>    based on roles/permissions.
<br><br><br>class
<br><br> active_workflow_states -- The active workflow states for a remember
<br>    type. MUST be set on &amp;lt;&amp;lt;remember&amp;gt;&amp;gt; types. Format is ['state',
<br>    'anotherstate'].
<br><br> additional_parents -- A comma-separated list of the names of classes
<br>    which should be used as additional parents to this class, in
<br>    addition to the Archetypes BaseContent, BaseFolder or
<br>    OrderedBaseFolder. Usually used in conjunction with 'imports' to
<br>    import the class before it is referenced.
<br><br> alias -- FTI Alias definition in the form alias=fromvalue,tovalue
<br><br> allow_discussion -- Whether or not the content type should be
<br>    discussable in the portal by default.
<br><br> allowable_content_types -- A comma-separated list of allowed test
<br>    format for a textarea widget.
<br><br> allowed_content_types -- A comma-separated list of allowed sub-types
<br>    for a (folderish) content type. Note that allowed content types are
<br>    automatically set when using aggregation and composition between
<br>    classes to specify containment.
<br><br> archetype_name -- The name which will be shown in the "add new item"
<br>    drop-down and other user-interface elements. Defaults to the class
<br>    name, but whilst the class name must be valid and unique python
<br>    identifier, the archetype_name can be any string.
<br><br> author -- You can set the author project-wide with the '--author'
<br>    commandline parameter (or in the config file). This TGV allows you
<br>    to use/ overwrite it on a class level.
<br><br> base_actions -- Sets the base actions in the class's factory type
<br>    information (FTI).
<br><br> base_class -- Explicitly set the base class of a content type,
<br>    overriding the automatic selection of BaseContent, BaseFolder or
<br>    OrderedBaseFolder as well as any parent classes in the model. What
<br>    you specify here ends up as the first item (or items: comma-separate
<br>    them) in the classes it inherits from. So this is also a handy way
<br>    to place one class explicitly in front of the other. See also
<br>    additional_parents.
<br><br> base_schema -- Explicitly set the base schema for a content type,
<br>    overriding the automatic selection of the parent's schema or
<br>    BaseSchema, BaseFolderSchema or OrderedBaseFolderSchema.
<br><br> catalog:index -- Add the field (or all fields of a class, package,
<br>    model) to the index. Boolean, 1 or 0. Default is 0. If set, you may
<br>    need to provide 'index:*' tagged values too.
<br><br> catalog:metadata -- Adds the field to the metadata record on the query
<br>    result. Boolean, 1 or 0. If you do not provide 'index:attributes',
<br>    the name of the accessor of the field is the default. If
<br>    'catalog:attributes' is given for each attribute one field at the
<br>    record will be created.
<br><br> catalog:name -- Sometimes you need to add an index to a other catalog
<br>    than 'portal_catalog' and its XML-File 'catalog.xml'. Provide a
<br>    tuple of comma separated strings, id of the catalog and the filename
<br>    of its configuration file. default is "portal_catalog, Plone Catalog
<br>    Tool'.
<br><br> catalogmultiplex:black -- Remove an archetypes class (identified by
<br>    meta_type) from one or more catalogs to be cataloged in. Comma-
<br>    separated list of catalogs. Example-value: 'portal_catalog,
<br>    another_catalog'. Explaination: Instances of the class wont be
<br>    catalogged in portal_catalog anymore.
<br><br> catalogmultiplex:white -- Add an archetypes class (identified by
<br>    meta_type) to one or more catalogs to be cataloged in. Comma-
<br>    separated list of catalogs. Example-value: 'myfancy_catalog,
<br>    another_catalog'. Explaination: Additionally to the default
<br>    'portal_catalog' the instances of this class will be catalogged in
<br>    the two given catalogs.
<br><br> content_icon -- The name of an image file, which must be found in the
<br>    skins directory of the product. This will be used to represent the
<br>    content type in the user interface.
<br><br> copyright -- You can set the copyright project-wide with the '--
<br>    copyright' commandline parameter (or in the config file). This TGV
<br>    allows you to use/ overwrite it on a class level.
<br><br> creation_permission -- Sets the creation permission for the class.
<br>    Example: 'Add portal content'.
<br><br> creation_roles -- You can set an own role who should be able to add a
<br>    type. Use an Tuple of Strings. Default and example for this value:
<br>    '("Manager", "Owner", "Member")'.
<br><br> default_interface_type -- default type of interfaces (z2 or z3).
<br><br> default_view -- The TemplateMixin class in Archetypes allows your class
<br>    to present several alternative view templates for a content type.
<br>    The default_view value sets the default one. Defaults to
<br>    'base_view'. Only relevant if you use TemplateMixin.
<br><br> description -- A description of the type, a sentence or two in length.
<br>    Used to describe the type to the user.
<br><br> detailed_creation_permissions -- Give the content-type (types in the
<br>    package, model) own creation permissions, named automagically
<br>    'ProductName: Add ClassName'.
<br><br> disable_polymorphing -- Normally, archgenxml looks at the parents of
<br>    the current class for content types that are allowed as items in a
<br>    folderish class. So: parent's allowed content is also allowed in the
<br>    child. Likewise, subclasses of classes allowed as content are also
<br>    allowed on this class. Classic polymorphing. In case this isn't
<br>    desired, set the tagged value 'disable_polymorphing' to 1.
<br><br> display_in_navigation -- Setting this boolean value adds the type to
<br>    'Displayed content types' in the portals navigation settings.
<br>    Default is True
<br><br> doctest_name -- In a tests package, setting the stereotype
<br>    '&amp;lt;&amp;lt;doc_testcase&amp;gt;&amp;gt;' on a class turns it into a doctest. The doctest
<br>    itself is placed in the doc/ subdirectory. The 'doctest_name' tagged
<br>    value overwrites the default name for the file (which is the name of
<br>    the doctestcase class + '.txt'). ArchGenXML appends the '.txt'
<br>    extension automatically, so you don't need to specify it.
<br><br> email -- You can set the email project-wide with the '--email'
<br>    commandline parameter (or in the config file). This TGV allows you
<br>    to use/ overwrite it on a class level.
<br><br> filter_content_types -- If set to true (1), explicitly turn on the
<br>    filter_content_types factory type information value. If this is off,
<br>    all globally addable content types will be addable inside a
<br>    (folderish) type; if it is on, only those values in the
<br>    allowed_content_types list will be enabled. Note that when
<br>    aggregation or composition is used to define containment,
<br>    filtered_content_types will be automatically turned on.
<br><br> folder_base_class -- Useful when using the '&amp;lt;&amp;lt;folder&amp;gt;&amp;gt;' stereotype in
<br>    order to set the folderish base class.
<br><br> generate_reference_fields -- Per default (True) navigable reference (or
<br>    relation) ends are resulting in a ReferenceField (or RelationField).
<br>    Setting this value to False results in not generating
<br>    ReferenceFields automagically.
<br><br> global_allow -- Overwrite the AGX-calculated 'global_allow' setting of
<br>    class. Setting it to '1' makes your content type addable everywhere
<br>    (in principle), setting it to '0' limits it to places where it's
<br>    explicitly allowed as content.
<br><br> hide_actions -- A comma- or newline-separated list of action ids to
<br>    hide on the class. For example, set to 'metadata, sharing' to turn
<br>    off the metadata (properties) and sharing tabs.
<br><br> hide_folder_tabs -- When you want to hide the folder tabs (mostly the
<br>    "contents" tab, just set this tagged value to 1.
<br><br> i18ncontent -- Enables the content type(s) for LinguaPlone. Only
<br>    allowed value is 'linguaplone'.
<br><br> immediate_view -- Set the immediate_view factory type information
<br>    value. This should be the name of a page template, and defaults to
<br>    'base_view'. Note that Plone at this time does not make use of
<br>    immediate_view, which in CMF core allows you to specify a different
<br>    template to be used when an object is first created from when it is
<br>    subsequently accessed.
<br><br> import_from -- If you wish to include a class in your model (as a base
<br>    class or aggregated class, for example) which is actually defined in
<br>    another product, add the class to your model and set the import_from
<br>    tagged value to the class that should be imported in its place. You
<br>    probably don't want the class to be generated, so add a stereotype
<br>    '&amp;lt;&amp;lt;stub&amp;gt;&amp;gt;' as well.
<br><br> imports -- A list of python import statements which will be placed at
<br>    the top of the generated file. Use this to make new field and widget
<br>    types available, for example. Note that in the generated code you
<br>    will be able to enter additional import statements in a preserved
<br>    code section near the top of the file. Prefer using the imports
<br>    tagged value when it imports something that is directly used by
<br>    another element in your model. You can have several import
<br>    statements, one per line, or by adding several tagged values with
<br>    the name 'imports'.
<br><br> index:type -- the type of index used as (string), for example
<br>    'FieldIndex', 'KeywordIndex', 'DateIndex' or any available index in
<br>    your portal. For known types a default is guessed, such as
<br>    FieldIndex for StringFields or DateIndex for DateFields. If no guess
<br>    is possible, we assume a FieldIndex.
<br><br> inherit_allowed_types -- By default, a child type will inherit the
<br>    allowable content types from its parents. Set this property to false
<br>    (0) to turn this off.
<br><br> label -- Sets the readable name.
<br><br> license -- You can set the license project-wide with the '--license'
<br>    commandline parameter (or in the config file). This TGV allows you
<br>    to use/ overwrite it on a class level.
<br><br> marshaller -- Specify a marshaller to use for the class' schema.
<br><br> module -- Like 'module_name', it overwrites the name of the directory
<br>    it'd be normally placed in.
<br><br> module_name -- Like 'module', it overwrites the name of the directory
<br>    it'd be normally placed in.
<br><br> parentclass_first -- if this tgv is set to true generalization parents
<br>    are used before the standard base classes (e.g. BaseContent) this
<br>    option is sometimes necessary when inheriting from some special
<br>    parents (e.g. 'remember' style classes).
<br><br> parentclasses_first -- if this tgv is set to true generalization
<br>    parents are used before the standard base classes (e.g. BaseContent)
<br>    this option is sometimes necessary when inheriting from some special
<br>    parents (e.g. 'remember' style classes).
<br><br> portal_type -- Sets the CMF portal-type this class will be registered
<br>    with, defaults to the class-name.
<br><br> read_permission -- Defines archetypes fields read-permission. Use it
<br>    together with workflow to control ability to view fields based on
<br>    roles/permissions.
<br><br> register -- 'Remember' related. Set as default member type.
<br><br> searchable -- Per default a fields 'searchable' property is set to
<br>    False. Sometimes you want it for all fields True. This TGV let you
<br>    define the default for a class, package or model.
<br><br> searchable_type -- Setting this boolean value adds the type to 'types
<br>    to be searched' in the portals search settings. Default is True
<br><br> strict -- On a class with the &amp;lt;&amp;lt;interface_doctest&amp;gt;&amp;gt; stereotype: check
<br>    for inherited interfaces as well.
<br><br> suppl_views -- The TemplateMixin class in Archetypes allows your class
<br>    to present several alternative view templates for a content type.
<br>    The suppl_views value sets the available views. Example:
<br>    '("my_view", "myother_view")'. Defaults to '()'. Only relevant if
<br>    you use TemplateMixin.
<br><br> typeDescription -- DEPRECATED. Use 'description' instead.
<br><br> use_dynamic_view -- Controles wether CMFDynamicViewFTI is used for a
<br>    type/class. Boolean, default is True.
<br><br> use_portal_factory -- This boolean value controls the registration of
<br>    the type for use with portal_factory. Default: True.
<br><br> use_workflow -- Tie the class to the named workflow. A state diagram
<br>    (=workflow) attached to a class in the UML diagram is automatically
<br>    used as that class's workflow; this tagged value allows you to tie
<br>    the workflow to other classes.
<br><br> version_info -- Add ArchGenXML version information to the generated
<br>    file (default is 1).
<br><br> vocabulary:type -- Enables support for Products 'ATVocabularyManager'
<br>    by setting value to 'ATVocabularyManager'.
<br><br> vocabulary:vocabulary_type -- For use with 'ATVocabularyManager'.
<br>    Defaults to 'Simplevocabulary'. Let you define the portal_type of
<br>    the vocabulary used as initial vocabulary at Product install time.
<br>    If VdexVocabulary is used, the install-script tries to install a
<br>    vocabulary from a vdex file names
<br>    'Products/PRODUCTNAME/data/VOCABULARYNAME.vdex'.
<br><br> write_permission -- Defines archetypes fields write-permission. Use it
<br>    together with workflow to control ability to write data to a field
<br>    based on roles/permissions.
<br><br><br>field
<br><br> description -- Sets a description for this field. It's used for field
<br>    documentation while registering inside Archetypes.
<br><br> label -- Sets the readable name.
<br><br> validation_expression -- Use an ExpressionValidator and sets the by
<br>    value given expression.
<br><br> validation_expression_errormsg -- Sets the error message to the
<br>    ExpressionValidator (use with validation_expression to define the
<br>    validation expression to which this error message applies).
<br><br><br>method
<br><br> code -- The actual python code of the method. Only use this for simple
<br>    one-liners. Code filled into the generated file will be preserved
<br>    when the model is re-generated.
<br><br> documentation -- You can add documention via this tag; it's better to
<br>    use your UML tool's documentation field.
<br><br> label -- Sets the readable name.
<br><br> permission -- For method with public visibility only, if a permission
<br>    is set, declare the method to be protected by this permission.
<br>    Methods with private or protected visiblity are always declared
<br>    private since they are not intended for through-the-web unsafe code
<br>    to access. Methods with package visibility use the class default
<br>    security and do not get security declarations at all.
<br><br><br>model
<br><br> alias -- FTI Alias definition in the form alias=fromvalue,tovalue
<br><br> association_class -- You can use associations classes to store content
<br>    on the association itself. The class used is specified by this
<br>    setting. Don't forget to import the used class properly.
<br><br> association_vocabulary -- Switch, defaults to False. Needs Product
<br>    'ATVocabularyManager'. Generates an empty vocabulary with the name
<br>    of the relation.
<br><br> author -- You can set the author project-wide with the '--author'
<br>    commandline parameter (or in the config file). This TGV allows you
<br>    to use/ overwrite it on a model level.
<br><br> catalog:index -- Add the field (or all fields of a class, package,
<br>    model) to the index. Boolean, 1 or 0. Default is 0. If set, you may
<br>    need to provide 'index:*' tagged values too.
<br><br> catalog:metadata -- Adds the field to the metadata record on the query
<br>    result. Boolean, 1 or 0. If you do not provide 'index:attributes',
<br>    the name of the accessor of the field is the default. If
<br>    'catalog:attributes' is given for each attribute one field at the
<br>    record will be created.
<br><br> catalog:name -- Sometimes you need to add an index to a other catalog
<br>    than 'portal_catalog' and its XML-File 'catalog.xml'. Provide a
<br>    tuple of comma separated strings, id of the catalog and the filename
<br>    of its configuration file. default is "portal_catalog, Plone Catalog
<br>    Tool'.
<br><br> catalogmultiplex:black -- Remove an archetypes class (identified by
<br>    meta_type) from one or more catalogs to be cataloged in. Comma-
<br>    separated list of catalogs. Example-value: 'portal_catalog,
<br>    another_catalog'. Explaination: Instances of the class wont be
<br>    catalogged in portal_catalog anymore.
<br><br> catalogmultiplex:white -- Add an archetypes class (identified by
<br>    meta_type) to one or more catalogs to be cataloged in. Comma-
<br>    separated list of catalogs. Example-value: 'myfancy_catalog,
<br>    another_catalog'. Explaination: Additionally to the default
<br>    'portal_catalog' the instances of this class will be catalogged in
<br>    the two given catalogs.
<br><br> copyright -- You can set the copyright project-wide with the '--
<br>    copyright' commandline parameter (or in the config file). This TGV
<br>    allows you to use/ overwrite it on a model level.
<br><br> creation_permission -- Sets the creation permission for the class.
<br>    Example: 'Add portal content'.
<br><br> creation_roles -- You can set an own role who should be able to add a
<br>    type. Use an Tuple of Strings. Default and example for this value:
<br>    '("Manager", "Owner", "Member")'.
<br><br> default_interface_type -- default type of interfaces (z2 or z3).
<br><br> default_view -- The TemplateMixin class in Archetypes allows your class
<br>    to present several alternative view templates for a content type.
<br>    The default_view value sets the default one. Defaults to
<br>    'base_view'. Only relevant if you use TemplateMixin.
<br><br> dependency_step_qi -- Generate Quickinstaller dependency installation
<br>    for your product. Boolean (1 or 0), default 0 (off). Dependencies
<br>    can be declared in AppConfig.py in a variable DEPENDENCIES.
<br><br> dependend_profiles -- GenericSetup profiles your product depends on. A
<br>    list of profile names separated by commas. This list is used for the
<br>    dependencies tag inside the metadata.xml file of the product's
<br>    profile
<br><br> detailed_creation_permissions -- Give the content-type (types in the
<br>    package, model) own creation permissions, named automagically
<br>    'ProductName: Add ClassName'.
<br><br> display_in_navigation -- Setting this boolean value adds the type to
<br>    'Displayed content types' in the portals navigation settings.
<br>    Default is True
<br><br> email -- You can set the email project-wide with the '--email'
<br>    commandline parameter (or in the config file). This TGV allows you
<br>    to use/ overwrite it on a model level.
<br><br> fixtools -- Generate fixTools function in setuphandlers.py. It calls
<br>    initializeArchetypes for generated tools, thus reset existing data
<br>    in the tools. Boolean (1 or 0), default 0 (off).
<br><br> generate_reference_fields -- Per default (True) navigable reference (or
<br>    relation) ends are resulting in a ReferenceField (or RelationField).
<br>    Setting this value to False results in not generating
<br>    ReferenceFields automagically.
<br><br> global_allow -- Overwrite the AGX-calculated 'global_allow' setting of
<br>    class. Setting it to '1' makes your content type addable everywhere
<br>    (in principle), setting it to '0' limits it to places where it's
<br>    explicitly allowed as content.
<br><br> i18ncontent -- Enables the content type(s) for LinguaPlone. Only
<br>    allowed value is 'linguaplone'.
<br><br> immediate_view -- Set the immediate_view factory type information
<br>    value. This should be the name of a page template, and defaults to
<br>    'base_view'. Note that Plone at this time does not make use of
<br>    immediate_view, which in CMF core allows you to specify a different
<br>    template to be used when an object is first created from when it is
<br>    subsequently accessed.
<br><br> imports -- A list of python import statements which will be placed at
<br>    the top of the generated file. Use this to make new field and widget
<br>    types available, for example. Note that in the generated code you
<br>    will be able to enter additional import statements in a preserved
<br>    code section near the top of the file. Prefer using the imports
<br>    tagged value when it imports something that is directly used by
<br>    another element in your model. You can have several import
<br>    statements, one per line, or by adding several tagged values with
<br>    the name 'imports'.
<br><br> index:type -- the type of index used as (string), for example
<br>    'FieldIndex', 'KeywordIndex', 'DateIndex' or any available index in
<br>    your portal. For known types a default is guessed, such as
<br>    FieldIndex for StringFields or DateIndex for DateFields. If no guess
<br>    is possible, we assume a FieldIndex.
<br><br> label -- Sets the readable name.
<br><br> license -- You can set the license project-wide with the '--license'
<br>    commandline parameter (or in the config file). This TGV allows you
<br>    to use/ overwrite it on a model level.
<br><br> module -- Like 'module_name', it overwrites the name of the directory
<br>    it'd be normally placed in.
<br><br> module_name -- Like 'module', it overwrites the name of the directory
<br>    it'd be normally placed in.
<br><br> plone_target_version -- The target version of Plone. Defaults to 3.0
<br>    Possible values are 2.5 and 3.0
<br><br> product_description -- The description of the Product. This is placed
<br>    as description tag in the metadata.xml file of the product's profile
<br><br> read_permission -- Defines archetypes fields read-permission. Use it
<br>    together with workflow to control ability to view fields based on
<br>    roles/permissions.
<br><br> relation_implementation -- Sets the type of implementation is used for
<br>    an association: 'basic' (used as default) for classic style
<br>    archetypes references or 'relations' for use of the 'Relations'
<br>    Product.
<br><br> searchable -- Per default a fields 'searchable' property is set to
<br>    False. Sometimes you want it for all fields True. This TGV let you
<br>    define the default for a class, package or model.
<br><br> searchable_type -- Setting this boolean value adds the type to 'types
<br>    to be searched' in the portals search settings. Default is True
<br><br> skin_directories -- A comma separated list of subdirectories to be
<br>    generated inside the product skins directory. Each of this
<br>    directories is prefixed with productname in lowercase. The default
<br>    value is "'templates', 'styles', 'images'".
<br><br> suppl_views -- The TemplateMixin class in Archetypes allows your class
<br>    to present several alternative view templates for a content type.
<br>    The suppl_views value sets the available views. Example:
<br>    '("my_view", "myother_view")'. Defaults to '()'. Only relevant if
<br>    you use TemplateMixin.
<br><br> use_dynamic_view -- Controles wether CMFDynamicViewFTI is used for a
<br>    type/class. Boolean, default is True.
<br><br> use_portal_factory -- This boolean value controls the registration of
<br>    the type for use with portal_factory. Default: True.
<br><br> use_workflow -- Tie the class to the named workflow. A state diagram
<br>    (=workflow) attached to a class in the UML diagram is automatically
<br>    used as that class's workflow; this tagged value allows you to tie
<br>    the workflow to other classes.
<br><br> version_info -- Add ArchGenXML version information to the generated
<br>    file (default is 1).
<br><br> vocabulary:type -- Enables support for Products 'ATVocabularyManager'
<br>    by setting value to 'ATVocabularyManager'.
<br><br> vocabulary:vocabulary_type -- For use with 'ATVocabularyManager'.
<br>    Defaults to 'Simplevocabulary'. Let you define the portal_type of
<br>    the vocabulary used as initial vocabulary at Product install time.
<br>    If VdexVocabulary is used, the install-script tries to install a
<br>    vocabulary from a vdex file names
<br>    'Products/PRODUCTNAME/data/VOCABULARYNAME.vdex'.
<br><br> write_permission -- Defines archetypes fields write-permission. Use it
<br>    together with workflow to control ability to write data to a field
<br>    based on roles/permissions.
<br><br><br>package
<br><br> alias -- FTI Alias definition in the form alias=fromvalue,tovalue
<br><br> association_class -- You can use associations classes to store content
<br>    on the association itself. The class used is specified by this
<br>    setting. Don't forget to import the used class properly.
<br><br> association_vocabulary -- Switch, defaults to False. Needs Product
<br>    'ATVocabularyManager'. Generates an empty vocabulary with the name
<br>    of the relation.
<br><br> author -- You can set the author project-wide with the '--author'
<br>    commandline parameter (or in the config file). This TGV allows you
<br>    to use/ overwrite it on a package level.
<br><br> catalog:index -- Add the field (or all fields of a class, package,
<br>    model) to the index. Boolean, 1 or 0. Default is 0. If set, you may
<br>    need to provide 'index:*' tagged values too.
<br><br> catalog:metadata -- Adds the field to the metadata record on the query
<br>    result. Boolean, 1 or 0. If you do not provide 'index:attributes',
<br>    the name of the accessor of the field is the default. If
<br>    'catalog:attributes' is given for each attribute one field at the
<br>    record will be created.
<br><br> catalog:name -- Sometimes you need to add an index to a other catalog
<br>    than 'portal_catalog' and its XML-File 'catalog.xml'. Provide a
<br>    tuple of comma separated strings, id of the catalog and the filename
<br>    of its configuration file. default is "portal_catalog, Plone Catalog
<br>    Tool'.
<br><br> catalogmultiplex:black -- Remove an archetypes class (identified by
<br>    meta_type) from one or more catalogs to be cataloged in. Comma-
<br>    separated list of catalogs. Example-value: 'portal_catalog,
<br>    another_catalog'. Explaination: Instances of the class wont be
<br>    catalogged in portal_catalog anymore.
<br><br> catalogmultiplex:white -- Add an archetypes class (identified by
<br>    meta_type) to one or more catalogs to be cataloged in. Comma-
<br>    separated list of catalogs. Example-value: 'myfancy_catalog,
<br>    another_catalog'. Explaination: Additionally to the default
<br>    'portal_catalog' the instances of this class will be catalogged in
<br>    the two given catalogs.
<br><br> copyright -- You can set the copyright project-wide with the '--
<br>    copyright' commandline parameter (or in the config file). This TGV
<br>    allows you to use/ overwrite it on a package level.
<br><br> creation_permission -- Sets the creation permission for the class.
<br>    Example: 'Add portal content'.
<br><br> creation_roles -- You can set an own role who should be able to add a
<br>    type. Use an Tuple of Strings. Default and example for this value:
<br>    '("Manager", "Owner", "Member")'.
<br><br> default_view -- The TemplateMixin class in Archetypes allows your class
<br>    to present several alternative view templates for a content type.
<br>    The default_view value sets the default one. Defaults to
<br>    'base_view'. Only relevant if you use TemplateMixin.
<br><br> detailed_creation_permissions -- Give the content-type (types in the
<br>    package, model) own creation permissions, named automagically
<br>    'ProductName: Add ClassName'.
<br><br> display_in_navigation -- Setting this boolean value adds the type to
<br>    'Displayed content types' in the portals navigation settings.
<br>    Default is True
<br><br> email -- You can set the email project-wide with the '--email'
<br>    commandline parameter (or in the config file). This TGV allows you
<br>    to use/ overwrite it on a package level.
<br><br> generate_reference_fields -- Per default (True) navigable reference (or
<br>    relation) ends are resulting in a ReferenceField (or RelationField).
<br>    Setting this value to False results in not generating
<br>    ReferenceFields automagically.
<br><br> global_allow -- Overwrite the AGX-calculated 'global_allow' setting of
<br>    class. Setting it to '1' makes your content type addable everywhere
<br>    (in principle), setting it to '0' limits it to places where it's
<br>    explicitly allowed as content.
<br><br> i18ncontent -- Enables the content type(s) for LinguaPlone. Only
<br>    allowed value is 'linguaplone'.
<br><br> immediate_view -- Set the immediate_view factory type information
<br>    value. This should be the name of a page template, and defaults to
<br>    'base_view'. Note that Plone at this time does not make use of
<br>    immediate_view, which in CMF core allows you to specify a different
<br>    template to be used when an object is first created from when it is
<br>    subsequently accessed.
<br><br> imports -- A list of python import statements which will be placed at
<br>    the top of the generated file. Use this to make new field and widget
<br>    types available, for example. Note that in the generated code you
<br>    will be able to enter additional import statements in a preserved
<br>    code section near the top of the file. Prefer using the imports
<br>    tagged value when it imports something that is directly used by
<br>    another element in your model. You can have several import
<br>    statements, one per line, or by adding several tagged values with
<br>    the name 'imports'.
<br><br> index:type -- the type of index used as (string), for example
<br>    'FieldIndex', 'KeywordIndex', 'DateIndex' or any available index in
<br>    your portal. For known types a default is guessed, such as
<br>    FieldIndex for StringFields or DateIndex for DateFields. If no guess
<br>    is possible, we assume a FieldIndex.
<br><br> label -- Sets the readable name.
<br><br> license -- You can set the license project-wide with the '--license'
<br>    commandline parameter (or in the config file). This TGV allows you
<br>    to use/ overwrite it on a package level.
<br><br> module -- Like 'module_name', it overwrites the name of the directory
<br>    it'd be normally placed in.
<br><br> module_name -- Like 'module', it overwrites the name of the directory
<br>    it'd be normally placed in.
<br><br> read_permission -- Defines archetypes fields read-permission. Use it
<br>    together with workflow to control ability to view fields based on
<br>    roles/permissions.
<br><br> relation_implementation -- Sets the type of implementation is used for
<br>    an association: 'basic' (used as default) for classic style
<br>    archetypes references or 'relations' for use of the 'Relations'
<br>    Product.
<br><br> searchable -- Per default a fields 'searchable' property is set to
<br>    False. Sometimes you want it for all fields True. This TGV let you
<br>    define the default for a class, package or model.
<br><br> searchable_type -- Setting this boolean value adds the type to 'types
<br>    to be searched' in the portals search settings. Default is True
<br><br> suppl_views -- The TemplateMixin class in Archetypes allows your class
<br>    to present several alternative view templates for a content type.
<br>    The suppl_views value sets the available views. Example:
<br>    '("my_view", "myother_view")'. Defaults to '()'. Only relevant if
<br>    you use TemplateMixin.
<br><br> use_dynamic_view -- Controles wether CMFDynamicViewFTI is used for a
<br>    type/class. Boolean, default is True.
<br><br> use_portal_factory -- This boolean value controls the registration of
<br>    the type for use with portal_factory. Default: True.
<br><br> use_workflow -- Tie the class to the named workflow. A state diagram
<br>    (=workflow) attached to a class in the UML diagram is automatically
<br>    used as that class's workflow; this tagged value allows you to tie
<br>    the workflow to other classes.
<br><br> version_info -- Add ArchGenXML version information to the generated
<br>    file (default is 1).
<br><br> vocabulary:type -- Enables support for Products 'ATVocabularyManager'
<br>    by setting value to 'ATVocabularyManager'.
<br><br> vocabulary:vocabulary_type -- For use with 'ATVocabularyManager'.
<br>    Defaults to 'Simplevocabulary'. Let you define the portal_type of
<br>    the vocabulary used as initial vocabulary at Product install time.
<br>    If VdexVocabulary is used, the install-script tries to install a
<br>    vocabulary from a vdex file names
<br>    'Products/PRODUCTNAME/data/VOCABULARYNAME.vdex'.
<br><br> write_permission -- Defines archetypes fields write-permission. Use it
<br>    together with workflow to control ability to write data to a field
<br>    based on roles/permissions.
<br><br><br>portlet
<br><br> label -- Sets the readable name.
<br><br> template_name -- Specify a template for the portlet (without .pt).
<br>    Default is the class name. (on classes with the stereotype
<br>    &amp;lt;&amp;lt;portlet_class&amp;gt;&amp;gt;)
<br><br><br>state
<br><br> access -- Shortcut for 'Access contents information'.
<br><br> add -- Shortcut for 'Add portal content'.
<br><br> delete -- Shortcut for 'Delete objects'.
<br><br> description -- Sets the state description.
<br><br> inactive -- Shortcut for 'Access inactive portal content'.
<br><br> initial_state -- Sets this state to be the initial state. This allows
<br>    you to use a normal state in your UML diagram instead of the special
<br>    round starting-state symbol.
<br><br> label -- Sets the readable name.
<br><br> list -- Shortcut for 'List folder contents'.
<br><br> modify -- Shortcut for 'Modify portal content'.
<br><br> review -- Shortcut for 'Review portal content'.
<br><br> role -- Shortcut for 'Change local roles'.
<br><br> view -- Shortcut for 'View'.
<br><br> worklist -- Attach objects in this state to the named worklist. An
<br>    example of a worklist is the to-review list.
<br><br> worklist:guard_permissions -- Sets the permissions needed to be allowed
<br>    to view the worklist. Default value is 'Review portal content'. Set
<br>    to 'False' for no guard_permission.
<br><br> worklist:guard_roles -- Sets the roles needed to be allowed to view the
<br>    worklist. No default value
<br><br><br>state action
<br><br> after:binding -- Interface to bind the after effect to.
<br><br> before:binding -- Interface to bind the before effect to.
<br><br> label -- Sets the readable name.
<br><br><br>state machine
<br><br> bindings -- List of portal-types this workflow should be bound to.
<br>    Comma-separated, i.e. 'Document, Image, File'.
<br><br> default -- A workflow id to be set as the default workflow.
<br><br> label -- Sets the readable name.
<br><br><br>state transition
<br><br> label -- Sets the readable name.
<br><br> trigger_type -- Sets the trigger type, following what is defined by
<br>    DCWorkflow:  automatic user action (default) workflow method
<br><br> url -- Action URL, need 'PloneWorkflowTransitions' to see it in Plone.
<br><br><br>tool
<br><br> author -- You can set the author project-wide with the '--author'
<br>    commandline parameter (or in the config file). This TGV allows you
<br>    to use/ overwrite it on a tool level.
<br><br> autoinstall -- Controls, wether the tool is automatically installed
<br>    when your product is installed. Boolean, default is True.
<br><br> configlet -- Set to true (1) to set up a configlet in the Plone control
<br>    panel for your tool.
<br><br> configlet:condition -- A TALES expression defining a condition which
<br>    will be evaluated to determine whether the configlet should be
<br>    displayed.
<br><br> configlet:description -- A description of the configlet.
<br><br> configlet:icon -- The name of an image file, which must be in your
<br>    product's skin directory, used as the configlet icon.
<br><br> configlet:permission -- A permission which is required for the
<br>    configlet to be displayed.
<br><br> configlet:section -- The section of the control panel where the
<br>    configlet should be displayed. One of 'Plone', 'Products' (default)
<br>    or 'Member'. **warning**: older documentation versions mentioned
<br>    'Members' here.
<br><br> configlet:title -- The name of the configlet.
<br><br> configlet:view -- The id of the view template to use when first opening
<br>    the configlet. By default, the 'view' action of the object is used
<br>    (which is usually base_view)
<br><br> copyright -- You can set the copyright project-wide with the '--
<br>    copyright' commandline parameter (or in the config file). This TGV
<br>    allows you to use/ overwrite it on a tool level.
<br><br> creation_permission -- Sets the creation permission for the class.
<br>    Example: 'Add portal content'.
<br><br> creation_roles -- You can set an own role who should be able to add a
<br>    type. Use an Tuple of Strings. Default and example for this value:
<br>    '("Manager", "Owner", "Member")'.
<br><br> default_view -- The TemplateMixin class in Archetypes allows your class
<br>    to present several alternative view templates for a content type.
<br>    The default_view value sets the default one. Defaults to
<br>    'base_view'. Only relevant if you use TemplateMixin.
<br><br> email -- You can set the email project-wide with the '--email'
<br>    commandline parameter (or in the config file). This TGV allows you
<br>    to use/ overwrite it on a tool level.
<br><br> immediate_view -- Set the immediate_view factory type information
<br>    value. This should be the name of a page template, and defaults to
<br>    'base_view'. Note that Plone at this time does not make use of
<br>    immediate_view, which in CMF core allows you to specify a different
<br>    template to be used when an object is first created from when it is
<br>    subsequently accessed.
<br><br> imports -- A list of python import statements which will be placed at
<br>    the top of the generated file. Use this to make new field and widget
<br>    types available, for example. Note that in the generated code you
<br>    will be able to enter additional import statements in a preserved
<br>    code section near the top of the file. Prefer using the imports
<br>    tagged value when it imports something that is directly used by
<br>    another element in your model. You can have several import
<br>    statements, one per line, or by adding several tagged values with
<br>    the name 'imports'.
<br><br> label -- Sets the readable name.
<br><br> license -- You can set the license project-wide with the '--license'
<br>    commandline parameter (or in the config file). This TGV allows you
<br>    to use/ overwrite it on a tool level.
<br><br> module -- Like 'module_name', it overwrites the name of the directory
<br>    it'd be normally placed in.
<br><br> module_name -- Like 'module', it overwrites the name of the directory
<br>    it'd be normally placed in.
<br><br> suppl_views -- The TemplateMixin class in Archetypes allows your class
<br>    to present several alternative view templates for a content type.
<br>    The suppl_views value sets the available views. Example:
<br>    '("my_view", "myother_view")'. Defaults to '()'. Only relevant if
<br>    you use TemplateMixin.
<br><br> tool_instance_name -- The id to use for the tool. Defaults to
<br>    'portal_&lt;name&gt;', where &amp;lt;name&amp;gt; is the class name in lowercase.
<br><br> toolicon -- The name of an image file, which must be found in the skins
<br>    directory of the product. This will be used to represent your tool
<br>    in the Zope Management Interface.
<br><br><br>unknown
<br><br> Modify --
<br><br> access --
<br><br> allow_empty_rows --
<br><br> columns --
<br><br> default:widget:Reference --
<br><br> default_content_type --
<br><br> default_output_type --
<br><br> default_page_type --
<br><br> i18ncontent --
<br><br> index_method --
<br><br> languageIndependent --
<br><br> max_size --
<br><br> mode --
<br><br> pil_quality --
<br><br> pil_resize_algo --
<br><br> rename_after_creation --
<br><br> storage --
<br><br> swallowResizeExceptions --
<br><br> widget:addable --
<br><br> widget:allow_brightness --
<br><br> widget:allow_browse --
<br><br> widget:allow_file_upload --
<br><br> widget:allow_search --
<br><br> widget:allow_sorting --
<br><br> widget:append_only --
<br><br> widget:auto_insert --
<br><br> widget:available_indexes --
<br><br> widget:base_query --
<br><br> widget:checkbox_bound --
<br><br> widget:cols --
<br><br> widget:columns --
<br><br> widget:default_search_index --
<br><br> widget:destination --
<br><br> widget:destination_types --
<br><br> widget:divider --
<br><br> widget:dollars_and_cents --
<br><br> widget:ending_year --
<br><br> widget:force_close_on_insert --
<br><br> widget:format --
<br><br> widget:future_years --
<br><br> widget:history_length --
<br><br> widget:image_method --
<br><br> widget:image_portal_types --
<br><br> widget:maxlength --
<br><br> widget:nullValueTitle --
<br><br> widget:omitCountries --
<br><br> widget:only_for_review_states --
<br><br> widget:provideNullValue --
<br><br> widget:restrict_browsing_to_startup_directory --
<br><br> widget:rows --
<br><br> widget:search_catalog --
<br><br> widget:show_hm --
<br><br> widget:show_indexes --
<br><br> widget:show_path --
<br><br> widget:show_review_state --
<br><br> widget:show_ymd --
<br><br> widget:size --
<br><br> widget:starting_year --
<br><br> widget:startup_directory --
<br><br> widget:thousands_commas --
<br><br> widget:visible --
<br><br> widget:whole_dollars --
<br><br><br>view
<br><br> label -- Sets the readable name.
<br><br> name -- Specify a name for the zope3 view.. Default is the class name.
<br>    (on classes with the stereotype &amp;lt;&amp;lt;view_class&amp;gt;&amp;gt;)
<br><br><br>widget
<br><br> description -- Sets a description for this widget. It's used for widget
<br>    documentation while registering inside Archetypes.
<br><br> label -- Sets the readable name.
<br><br> macro -- Sets the macro used by the widget. This will be used as the
<br>    name of the auto-created page template for the widget.
<br><br> title -- Sets the widget title. It's used for widget documentation
<br>    while registering inside Archetypes.
<br><br> used_for -- Sets the possible fields which can use this widget. It's
<br>    used for widget documentation while registering inside Archetypes.
<br>    The list has the form: '"Products.Archetypes.Field.Field1Name",
<br>    "Products.Archetypes.Field.FieldName2"'.</p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.4.3.
                Stereotypes
            </h1>

            <p class="documentDescription">All stereotypes available in its context.</p>
    
            <div>
                
                    <p>*This
file was generated 2009-05-12 with bin/agx_stereotypes 2.4.1. Don't
forget to replace &amp;lt;&amp;lt; by &amp;amp;lt;&amp;amp;lt; and
&amp;gt;&amp;gt; by &amp;amp;gt;&amp;amp;gt; on this page.*
<br><br><br>abstraction
<br><br> adapts -- On a realization, specify a class (&amp;lt;&amp;lt;adapter&amp;gt;&amp;gt;,
<br> &amp;lt;&amp;lt;named_adapter&amp;gt;&amp;gt;,
&amp;lt;&amp;lt;extender&amp;gt;&amp;gt;) adapts another class
(&amp;lt;&amp;lt;stub&amp;gt;&amp;gt;,
<br>    &amp;lt;&amp;lt;interface&amp;gt;&amp;gt;).
<br><br><br>class
<br><br> adapter -- Is a (non-named) adapter.
<br><br> archetype -- Explicitly specify that a class represents an Archetypes
<br>    type. This may be necessary if you are including a class as a base
<br>    class for another class and ArchGenXML is unable to determine
<br>    whether the parent class is an Archetype or not. Without knowing
<br>    that the parent class in an Archetype, ArchGenXML cannot ensure that
<br>    the parent's schema is available in the derived class.
<br><br> atblob -- Turns the class into an plone.app.blob.content.ATBlob
<br>    subclass.
<br><br> atdocument -- Turns the class into an Atdocument subclass.
<br><br> atevent -- Turns the class into an ATEvent subclass.
<br><br> atfile -- Turns the class into an ATFile subclass.
<br><br> atfolder -- Turns the class into an ATFolder subclass.
<br><br> atimage -- Turns the class into an ATImage subclass.
<br><br> atlink -- Turns the class into an ATLink subclass.
<br><br> atnewsitem -- Turns the class into an ATNewsItem subclass.
<br><br> btree -- Like '&amp;lt;&amp;lt;folder&amp;gt;&amp;gt;', it generates a folderish object. But it
<br>    uses a BTree folder for support of large amounts of content. The
<br>    same as '&amp;lt;&amp;lt;large&amp;gt;&amp;gt;'.
<br><br> content_class -- TODO
<br><br> doc_testcase -- Turns a class into a doctest class. It must subclass a
<br>    '&amp;lt;&amp;lt;plone_testcase&amp;gt;&amp;gt;'.
<br><br> extender -- Is a schema extender supported by
<br>    archetypes.schemaextender.
<br><br> field -- Class will target in a ObjectField or CompoundField (latter if
<br>    Attributes are provided)
<br><br> flavor -- Generates a ContentFlavors flavor from this class.
<br><br> folder -- Turns the class into a folderish object. When a UML class
<br>    contains or aggregates other classes, it is automatically turned
<br>    into a folder; this stereotype can be used to turn normal classes
<br>    into folders, too.
<br><br> functional_doc_testcase -- Turns a class into a functional doctest
<br>    class. It must subclass a '&amp;lt;&amp;lt;plone_testcase&amp;gt;&amp;gt;'.
<br><br> functional_testcase -- Turns a class into a functional testcase. It
<br>    must subclass a '&amp;lt;&amp;lt;functional_testcase&amp;gt;&amp;gt;'. Adding an interface arrow
<br>    to another class automatically adds that class's methods to the
<br>    testfile for testing.
<br><br> hidden -- Generate the class, but turn off "global_allow", thereby
<br>    making it unavailable in the portal by default. Note that if you use
<br>    composition to specify that a type should be addable only inside
<br>    another (folderish) type, then "global_allow" will be turned off
<br>    automatically, and the type be made addable only inside the
<br>    designated parent. (You can use aggregation instead of composition
<br>    to make a type both globally addable and explicitly addable inside
<br>    another folderish type).
<br><br> interface -- Is an interface.
<br><br> interface_testcase -- Turns a class into a testcase for the interfaces.
<br><br> large -- Like '&amp;lt;&amp;lt;folder&amp;gt;&amp;gt;', it generates a folderish object. But it
<br>    uses a BTree folder for support of large amounts of content. The
<br>    same as '&amp;lt;&amp;lt;large&amp;gt;&amp;gt;'.
<br><br> mixin -- Don't inherit automatically from "BaseContent" and so. This
<br>    makes the class suitable as a mixin class. See also '&amp;lt;&amp;lt;archetype&amp;gt;&amp;gt;'.
<br><br> named_adapter -- Is a named adapter.
<br><br> odStub -- Prevents a class/package/model from being generated. Same as
<br>    '&amp;lt;&amp;lt;stub&amp;gt;&amp;gt;'.
<br><br> ordered -- For folderish types, include folder ordering support. This
<br>    will allow the user to re-order items in the folder manually.
<br><br> plone_testcase -- Turns a class into the (needed) base class for all
<br>    other '&amp;lt;&amp;lt;testcase&amp;gt;&amp;gt;' and '&amp;lt;&amp;lt;doc_testcase&amp;gt;&amp;gt;' classes inside a
<br>    '&amp;lt;&amp;lt;test&amp;gt;&amp;gt;' package.
<br><br> plonefunctional_testcase -- Turns a class into the base class for all
<br>    other '&amp;lt;&amp;lt;functionaltestcase&amp;gt;&amp;gt;' classes inside a '&amp;lt;&amp;lt;test&amp;gt;&amp;gt;' package.
<br><br> portal_tool -- Turns the class into a portal tool.
<br><br> portlet_class -- Generate this class as a zope3 portlet class instead
<br>    of as an Archetypes class.
<br><br> python_class -- Generate this class as a plain python class instead of
<br>    as an Archetypes class.
<br><br> remember -- The class will be treated as a remember member type. It
<br>    will derive from remember's Member class and be installed as a
<br>    member data type. Note that you need to install the separate
<br>    remember product.
<br><br> setup_testcase -- Turns a class into a testcase for the setup, with
<br>    pre-defined common checks.
<br><br> stub -- Prevents a class/package/model from being generated.
<br><br> testcase -- Turns a class into a testcase. It must subclass a
<br>    '&amp;lt;&amp;lt;plone_testcase&amp;gt;&amp;gt;'. Adding an interface arrow to another class
<br>    automatically adds that class's methods to the testfile for testing.
<br><br> tool -- Turns the class into a portal tool. Similar to
<br>    '&amp;lt;&amp;lt;portal_tool&amp;gt;&amp;gt;'.
<br><br> variable_schema -- Include variable schema support in a content type by
<br>    deriving from the VariableSchema mixin class.
<br><br> view_class -- Generate this class as a zope3 view class instead of as
<br>    an Archetypes class.
<br><br> vocabulary -- TODO
<br><br> vocabulary_term -- TODO
<br><br> widget -- A simple stub archetypes-widget class will be created.
<br><br> zope_class -- Generate this class as a plain Zope class instead of as
<br>    an Archetypes class.
<br><br><br>dependency
<br><br> value_class -- Declares a class to be used as value class for a certain
<br>    field class (see '&amp;lt;&amp;lt;field&amp;gt;&amp;gt;' stereotype).
<br><br><br>interface
<br><br> stub -- Prevents a class/package/model from being generated.
<br><br> z3 -- Generate this interface class as zope 3 interface. This will
<br>    inherit from zope.interface.Interface.
<br><br><br>method
<br><br> action -- Generate a CMF action which will be available on the object.
<br>    The tagged values "action" (defaults to method name), "id" (defaults
<br>    to method name), "category" (defaults to "object"), "label"
<br>    (defaults to method name), "condition" (defaults to empty), and
<br>    "permission" (defaults to empty) set on the method and mapped to the
<br>    equivalent fields of any CMF action can be used to control the
<br>    behaviour of the action.
<br><br> form -- Generate an action like with the '&amp;lt;&amp;lt;action&amp;gt;&amp;gt;' stereotype, but
<br>    also copy an empty controller page template to the skins directory
<br>    with the same name as the method and set this up as the target of
<br>    the action. If the template already exists, it is not overwritten.
<br><br> noaction -- Disables standard actions, applied to a method out of
<br>    'view', 'edit', 'metadata', 'references.
<br><br> view -- Generate an action like with the '&amp;lt;&amp;lt;action&amp;gt;&amp;gt;' stereotype, but
<br>    also copy an empty page template to the skins directory with the
<br>    same name as the method and set this up as the target of the action.
<br>    If the template exists, it is not overwritten.
<br><br><br>model
<br><br> odStub -- Prevents a class/package/model from being generated. Same as
<br>    '&amp;lt;&amp;lt;stub&amp;gt;&amp;gt;'.
<br><br> stub -- Prevents a class/package/model from being generated.
<br><br><br>operation
<br><br> action -- Generate a CMF action which will be available on the object.
<br>    The tagged values "action" (defaults to method name), "id" (defaults
<br>    to method name), "category" (defaults to "object"), "label"
<br>    (defaults to method name), "condition" (defaults to empty), and
<br>    "permission" (defaults to empty) set on the method and mapped to the
<br>    equivalent fields of any CMF action can be used to control the
<br>    behaviour of the action.
<br><br> form -- Generate an action like with the '&amp;lt;&amp;lt;action&amp;gt;&amp;gt;' stereotype, but
<br>    also copy an empty controller page template to the skins directory
<br>    with the same name as the method and set this up as the target of
<br>    the action. If the template already exists, it is not overwritten.
<br><br> noaction -- Disables standard actions, applied to a method out of
<br>    'view', 'edit', 'metadata', 'references.
<br><br> view -- Generate an action like with the '&amp;lt;&amp;lt;action&amp;gt;&amp;gt;' stereotype, but
<br>    also copy an empty page template to the skins directory with the
<br>    same name as the method and set this up as the target of the action.
<br>    If the template exists, it is not overwritten.
<br><br><br>package
<br><br> odStub -- Prevents a class/package/model from being generated. Same as
<br>    '&amp;lt;&amp;lt;stub&amp;gt;&amp;gt;'.
<br><br> stub -- Prevents a class/package/model from being generated.
<br><br> tests -- Treats a package as test package. Inside such a test package,
<br>    you need at a '&amp;lt;&amp;lt;plone_testcase&amp;gt;&amp;gt;' and a '&amp;lt;&amp;lt;setup_testcase&amp;gt;&amp;gt;'.</p>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                3.5.
                Step by Step Instructions
            </h1>

            <p class="documentDescription">Step by step instructions for common tasks while developing with ArchGenXML.</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.5.1.
                Setup of a Testcase Environment using UML and ArchGenXML
            </h1>

            <p class="documentDescription">Environment for test-driven and architecture centric development.</p>
    
            <div>
                
                    <p>TODO: Check if it works in 2.0. Add some information how to run the tests.
<br><br>About Testing
<br><br> Since development is going on at many places in the Plone system, 
<br> it is important to have a way ready to *test* if the software 
<br> you wrote is affected by the changes. And, more important the other 
<br> way around, if your work, in case it makes it way into the Plone 
<br> core or other add-on products, affects the work of *others*.
<br><br> There are several documents available to read on why testing is 
<br> important, so feel free to have a look:
<br><br> * "Testing in Plone - Introduction":http://plone.org/documentation/tutorial/testing/introduction
<br><br> * "Best Practices for Plone development - Unit Testing":http://plone.org/documentation/tutorial/best-practices/unit-testing
<br><br> * "RichDocument Tutorial - Unit testing":http://plone.org/documentation/tutorial/richdocument/unit-testing
<br><br> and there are many more: Try the *testing*. Some of these documents 
<br> are describing in detail how to write the tests itself, which this 
<br> manual page is not intended for. 
<br><br>Testing and UML/ ArchGenXML
<br><br> This document describes the few steps necessary to setup your testing 
<br> environment when using an UML diagram and ArchGenXML. It generates 
<br> your projects with the test infrastructure and you can focus on writing 
<br> the test itself
<br><br> ArchGenXML provides a pre-configured testing environment - no more 
<br> hand-work to create it !
<br><br>Steps:
<br><br> 1 Check if "PloneTestCase":http://plone.org/products/plonetestcase/ 
<br>   product was shipped with your Plone. If not install it in the version 
<br>   for your Plone.
<br><br> 2 Create a package in your model and name it 'tests' and give it the 
<br>   stereotype '&lt;&lt;tests&gt;&gt;' 
<br><br> 3 Inside the new tests package create class 'MyFancyTestcase' (in the 
<br>   uml below named 'testPlone') and give it the stereotype '&lt;&lt;plone_testcase&gt;&gt;'. 
<br>   This is your main testcase class.
<br><br> 4 Create an additional class inside the test package, call it 'testSetup', and 
<br>   give it the stereotype '&lt;&lt;setup_testcase&gt;&gt;'. Let it derive from the main testcase 
<br>   class using the generalization arrow.
<br><br> 5 Testing methods/behaviour of archetypes classes: Create a class inside the 
<br>   test package. Give it the stereotype '&lt;&lt;testcase&gt;&gt;' or '&lt;&lt;doc_testcase&gt;&gt;'.
<br>   Make them derive from main testcase class using the generalization arrow.
<br>   On a testcase class you can add methods starting with 'test' such
<br>   as 'testMyFancyFeature'. After code generation you just need to fill 
<br>   in your test code. A doc_testcase class creates an empty 
<br>   doctest text-file in the '/docs' directory of your product. There are some
<br>   tagged value available to control the testcase in detail. Please look at the 
<br>   chapter *Reference - Tagged Values* for more information.
<br><br> 6 To generate all imports and some startup code, you can use the dependency arrow
<br>   from the testcase class to the archetypes class.
<br><br> 7 You can repeat 5 and 6 for every class you want to include in yout test. You 
<br>   can organize your tests also different, like one integration test, as you like.
<br><br> 8 Generate and run the tests. (TODO: steps needed to get the test fly, such as 
<br>   'zopectl test' or setting SOFTWAREHOME and INSTANCEHOME environment.
<br><br> "sample UML":img:uml-testcase.png
<br><br>These are the basic steps necessary to get it running.</p>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                3.6.
                Recipes and Tips
            </h1>

            <p class="documentDescription">A collection of recipes for real world use cases and tips for making life easier.</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                3.6.1.
                Using the config file to get shorter tagged values
            </h1>

            <p class="documentDescription">Some
tagged values can get quite lengthy. If you use such a lengthy value a
few times, you can store it in your project's config file.</p>
    
            <div>
                
                    <p>An
example of long tagged values are the permissions you set on workflow
states. A key 'view' with value 'Manager, Member, Reviewer' for
instance.
<br><br>In tagged values, the text you type in is normally taken as a
string. If you prefix your value with 'python:', it is copy-pasted
literally into your code. So 'python:["a", "b"]' is put into your code
as '["a", "b"]'.
<br><br>The config file
<br><br> ArchGenXML generates a 'config.py' in your Product's root
directory, which in turn tries to import 'AppConfig.py'. So stuff you
put in there is treated as if it is placed in the main config file. <br><br> Every ArchGenXML-generated file contains an import like
'from Products.YourProduct.config import *', so the variables defined
in your AppConfig are directly available in all the files. This means
that *you can specify shortcuts* for the tagged values.
<br><br>Shorter tagged values
<br><br> Example line in your 'AppConfig.py'::
<br><br>   EDITORS = 'Manager, Member, Reviewer'
<br><br> Remember that we can use 'python:' to paste raw python code
directly into the generated files. After adding above line, the
original tagged value 'view' with value 'Manager, Member, Reviewer' can
be shortened to the tagged value 'view' with value 'python:EDITORS'.
Now that's handy :-) And if you need to change this definition you have
it at a central place. No need to touch 2, 3 or more 'states' in UML
where its used several times on each.
<br><br>You can use this little *feature* almost everywhere, so its not reduced to workflow.</p>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-1">

            <h1>
                4.
                Portlets
            </h1>

            <p class="documentDescription">An introduction to the portlets architecture of Plone 3, with practical examples.</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-2">

            <h1>
                4.1.
                What's a portlet?
            </h1>

            <p class="documentDescription">This manual covers what a developer needs to know to create new portlet types or customise existing ones.</p>
    
            <div>
                
                    <div><p>Portlets
are chunks of information that can be shown outside the main area of a
page. They are usually boxes of different kinds which
content editors can add, set properties of and policies for showing.</p>

<p>(Screenshot).</p>

<h3>Differences with viewlets</h3>

<p>A portlet is like a viewlet but with persistent configuration (i.e. persistent in the ZODB) and run-time changeable assignments.</p>

<p>Use a viewlet for:</p>

<ul><li>General content which is always displayed, for example: breadcrumbs,

the logo, or the footer. This is not limited to only visible elements

but can also include CSS, javascript, etc. (actually, that's how ResourceRegistries work).<br></li><li>Displaying elements based on the interface provided by the current context.<br></li></ul><p>Use a portlet when:</p>

<ul><li>You need to specify the configuration data for an item. - i.e. number of entries to show.</li><li>You want to give the content editors a choice about when and where to display it.</li><li>You want to display it only from inside a specific folder.</li><li>You'd like to show it only to some groups or users - e.g. Review portlet only is shown to users within the Reviewers group.<br></li></ul><p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                4.2.
                Basic plone.portlets architecture
            </h1>

            <p class="documentDescription">This
section describes the general architecture of a portlet through an
example. You can checkout the example code from the collective .</p>
    
            <div>
                
                    <div><h3>The use case</h3>

<p>As an example, we will develop a portlet to display the last <em>n</em>

(where <em>n</em> is a positive integer ;) modified content items to logged-in users, which will be

available to add it to any portlet manager (left or right column by default).</p>

<p>[screenshot follows]</p>

<h3>The configuration data</h3>

<p>When a portlet is first

created, &nbsp;there are often customizations which can be made which tailor

the portlet's behaviour to meet the user's needs: eg. which content

type to display, how many items to list, etc... In our example, we

want the person configuring the portlet to be able to specify how many

of the most recent items will be displayed inside the portlet.</p>

<p>First, we have to describe the interface schema of the configuration data we want to store using <code>zope.schema</code> (see <a class="external-link" href="http://wiki.zope.org/zope3/schema.html">this page</a> for more info on schemas). By convention, this interface derives from <code>IPortletDataProvider</code>, which is just a marker interface. In the package's <em>interfaces.py</em> file, type:</p>

<pre>from plone.portlets.interfaces import IPortletDataProvider
from Products.CMFPlone import PloneMessageFactory as _

class IRecentPortlet(IPortletDataProvider):
    count = schema.Int(title=_(u'Number of items to display'),
                       description=_(u'How many items to list.'),
                       required=True,
                       default=5)
</pre>

<p>The <code>PloneMessageFactory</code> makes our code ready to be localized using the Plone i18n machinery.</p>

<p>After defining the configuration schema interface, we implement it

in a class called the Assignment class. This is a persistent "content"

class which stores the persistent configuration data (if any) of the

portlet. Even when a portlet is not configurable, it needs to have an

Assignment class, because the presence of an Assignment instance in

various places is what determines what portlets show up where.</p>

<p>The Assignment class has a <code>title</code> attribute that is used in the portlet management UI to distinguish different instances of the portlet.</p>

<pre>from plone.app.portlets.portlets import base
from zope.interface import implements
from ploneexample.portlet.interfaces import IRecentPortlet

class Assignment(base.Assignment):
    implements(IRecentPortlet)

    def __init__(self, count=5):
        self.count = count

    @property
    def title(self):
        return _(u"Recent items")
</pre>

<h3>The add and edit forms</h3>

<p>To add the portlet and edit its configuration, we have to define appropiate add and edit forms.</p>

<p>This is typically done using <em>zope.formlib</em> and the portlet

schema, together with some base form classes to save us from designing

the forms template and logic ourselves. If the portlet is not

configurable, this can use the special <code>base.NullAddForm</code>, which is just a view that creates the portlet and then redirects back to the portlet management screen.&nbsp;</p>

<p>For more information about <em>zope.formlib</em>, check <a class="external-link" href="http://plone.org/documentation/tutorial/writing-forms-easily-with-zope-formlib">this tutorial</a>.</p>

<p>The edit form can be omitted if the portlet configuration is not editable.</p>

<pre>from zope.formlib import form
class AddForm(base.AddForm):
    form_fields = form.Fields(IRecentPortlet)
    label = _(u"Add Recent Portlet")
    description = _(u"This portlet displays recently modified content.")

    def create(self, data):
        return Assignment(count=data.get('count', 5))

class EditForm(base.EditForm):
    form_fields = form.Fields(IRecentPortlet)
    label = _(u"Edit Recent Portlet")
    description = _(u"This portlet displays recently modified content.")</pre>

<p>As it can be seen above, the add form must return an Assignment instance of the portlet.</p>

<h3>The portlet presentation</h3>

<p>Next, we define how the portlet will be rendered.</p>

<p>The Portlet Renderer is the "view" of the portlet. This is just a

content provider (in the zope.contentprovider sense), in that it has an

<code>update()</code> and a <code>render()</code> method, which will be called upon the rendering of the portlet.</p>

<p>It's a multi-adapter that takes a number of parameters which makes it possible to vary the rendering of the portlet:</p>

<dl><dt>context </dt><dd>&nbsp;The current content object. Mind the type of content object that's being shown.</dd><dt>request </dt><dd>&nbsp;The current request. Mind the current theme/browser layer.</dd><dt>view </dt><dd>The current (full page) view. Mind the current view, and whether or not

this is the canonical view of the object (as indicated by the <code>IViewView</code>

marker interface) or a particular view, like the manage-portlets view. </dd><dt>manager </dt><dd>The portlet manager where this portlet was rendered (for now, think of

a portlet manager as a column). Mind where in the page the portlet was

rendered. </dd><dt>data </dt><dd>The

portlet data, which is basically an instance of the portlet assignment

class. Mind the configuration of the portlet assignment.<br></dd></dl><p>The Renderer base class relieves us from having to remember all these parameters.</p>

<p>The Renderer class must have an <code>available</code> property,

which is used to determine whether this portlet should be shown or not.

Note you shouldn't include checks for the user id, group or

content-type here, since you can perform these assignments later by

registering the portlet under a certain category (more on this later).</p>

<pre>from plone.memoize.instance import memoize
from zope.component import getMultiAdapter
from Acquisition import aq_inner
from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile

class Renderer(base.Renderer):
    _template = ViewPageTemplateFile('recent.pt')

    def __init__(self, *args):
        base.Renderer.__init__(self, *args)

        context = aq_inner(self.context)
        portal_state = getMultiAdapter((context, self.request), name=u'plone_portal_state')
        self.anonymous = portal_state.anonymous()  # whether or not the current user is Anonymous
        self.portal_url = portal_state.portal_url()  # the URL of the portal object
        
        # a list of portal types considered "end user" types
        self.typesToShow = portal_state.friendly_types()  

        plone_tools = getMultiAdapter((context, self.request), name=u'plone_tools')
        self.catalog = plone_tools.catalog()

    def render(self):
        return self._template()

    @property
    def available(self):
        """Show the portlet only if there are one or more elements."""
        return not self.anonymous and len(self._data())

    def recent_items(self):
        return self._data()

    def recently_modified_link(self):
        return '%s/recently_modified' % self.portal_url

    @memoize
    def _data(self):
        limit = self.data.count
        return self.catalog(portal_type=self.typesToShow,
                            sort_on='modified',
                            sort_order='reverse',
                            sort_limit=limit)[:limit]
</pre>

<p>When reading the previous code, note that:</p>

<ol><li><code>plone_portal_state</code> and <code>plone_tools</code> are helper views providing some useful attributes to gather information from.<br></li><li>The <code>memoize</code> decorator is used here to cache the results of

the catalog query to avoid the perfomance hit of re-generating them in

each request. See the <a class="external-link" href="http://dev.plone.org/plone/browser/plone.memoize/trunk/plone/memoize/README.txt">plone.memoize doctests</a> for more information.</li></ol><h3>Registering the portlet</h3>

<p>A convenient ZCML directive is provided to glue all components of
the portlet in the Zope Component Architecture. In the package's <em>configure.zcml</em> file (or any other ZCML file included from it), write:</p>

<pre>&lt;configure
    xmlns:five="http://namespaces.zope.org/five"
    xmlns:plone="http://namespaces.plone.org/plone"
    i18n_domain="ploneexample.portlet"&gt;

    &lt;five:registerPackage package="." initialize=".initialize" /&gt;

    &lt;include package="plone.app.portlets"/&gt;

    &lt;plone:portlet
        name="ploneexample.portlet.Recent"
        interface=".recent.IRecentPortlet"
        assignment=".recent.Assignment"
        renderer=".recent.Renderer"
        addview=".recent.AddForm"
        editview=".recent.EditForm"
        /&gt;

&lt;/configure&gt;
</pre>

<p>Note you have to define/reference the plone XML namespace for the directive to work. There is also a <code>&lt;plone:portletRenderer /&gt;</code> directive to override the renderer for a particular context/layer/view/manager.</p>

<p>You can see the descriptions of all these directives together with their arguments in the <a class="external-link" href="http://dev.plone.org/plone/browser/plone.app.portlets/trunk/plone/app/portlets/metadirectives.py">metadirectives.py file of the plone.app.portlets package</a>.</p>

<p>This ZCML directive is read at the Zope startup, so to register each

class appropiately into the Component Architecture, but you won't be

able to add your new portlet yet. You first need to install its portlet

type into your Plone site, as described in the section which follows.</p>

<h3>Installing the portlet</h3>

<p>The components and registration above make a new type of portlet

available for installation. To install the portlet type into a

particular Plone site, use GenericSetup.</p>

<p>First, register a new GenericSetup extension profile using a registerProfile ZCML directive:</p>

<pre>&lt;configure
    xmlns:five="http://namespaces.zope.org/five"
    xmlns:plone="http://namespaces.plone.org/plone"<strong>

    xmlns:gs="http://namespaces.zope.org/genericsetup"

</strong>    i18n_domain="ploneexample.portlet"&gt;

    &lt;five:registerPackage package="." initialize=".initialize" /&gt;

    &lt;include package="plone.app.portlets"/&gt;

<strong>    &lt;gs:registerProfile

        name="ploneexample.portlet"

        title="Recent Items Example"

        directory="profiles/default"

        description="An example portlet"

        provides="Products.GenericSetup.interfaces.EXTENSION"

        /&gt;</strong>

    &lt;plone:portlet
        name="ploneexample.portlet.Recent"
        interface=".recent.IRecentPortlet"
        assignment=".recent.Assignment"
        renderer=".recent.Renderer"
        addview=".recent.AddForm"
        editview=".recent.EditForm"
        /&gt;

&lt;/configure&gt;</pre>

<p>Next, create the folder profiles/default and place a <code>portlets.xml</code> file inside with the following content:</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;portlets
    xmlns:i18n="http://xml.zope.org/namespaces/i18n"
    i18n:domain="plone"&gt;
  &lt;portlet 
    addview="ploneexample.portlet.Recent"
    title="Recent items Example"
    description="An example portlet which can render a listing of recently changed items."
    i18n:attributes="title title_recent_portlet;
                     description description_recent_portlet"&gt;
    &lt;for interface="plone.app.portlets.interfaces.IColumn" /&gt;
    &lt;for interface="plone.app.portlets.interfaces.IDashboard" /&gt;
  &lt;/portlet&gt;
&lt;/portlets</pre>

<p>When this is run, it will create a local utility in the Plone site of the <code>IPortletType</code>. This just holds some metadata about the portlet for UI purposes.</p>

<p><code>Title</code> and <code>description</code> should be self-explanatory.</p>

<p>The <code>addview</code> is the name of the view used to add the

portlet, which helps the UI to invoke the right form when the user asks

to add the portlet. This should match the portlet name.</p>

<p><code>for</code> is an interface or list of interfaces that describe

the type of portlet managers that this portlet is suitable for. This

means that we can install a portlet that's suitable for the dashboard,

say, but not for the general columns. In this case, we're making the

portlet suitable for the dashboard and for any (either left or right)

column. Current portlet manager interfaces include <code>IColumn</code>, <code>ILeftColumn</code>, <code>IRightColumn</code> and <code>IDashboard</code>, all of them defined inside the plone.app.portlets package.</p>

<p>Again, this is primarily about helping the UI construct appropriate menus.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                4.3.
                Testing the portlet
            </h1>

            <p class="documentDescription">Ensure everything's working as it should.</p>
    
            <div>
                
                    <div><p>If the portlet was registered and installed correctly, it should now

show up in the list of portlets available for addition into the type of

portlet managers specified in the for argument of the portlet type (<code>IColumn</code> and <code>IDashboard</code> in our case), under the <code>@@manage-portlets</code> view (<em>Manage Portlets</em> link).</p>

<p>However, to ensure everything's working as it should without having

to test it through the web, we can write some integration tests. This

is recommended practice in the Plone universe. Moreover, once you've

understood how the portlet infrastructure and its API work, you will be

able to write tests first (you can copy&amp;paste tests from other

portlets products) and then start coding the portlet. More info on

testing in the <a title="Writing a PloneTestCase unit/integration test" class="internal-link" href="http://manage.plone.org/documentation/manual/developer-manual/testing/writing-a-plonetestcase-unit-integration-test">Testing in Plone</a> tutorial.</p>

<p>Run them using <code>bin/instance test -s ploneexample.portlet<br></code></p>

<p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                4.4.
                How and where are Portlet Assignments stored?
            </h1>

            <p class="documentDescription">When
you choose a portlet to be displayed somewhere, for example, using the
interface that appears when you hit the Manage Portlets button, what
you're doing is storing a persistent instance of the Portlet Assignment
class into your site, together with all its associated configuration
data.</p>
    
            <div>
                
                    <div><p>Portlet Assignments are stored in what's called an Assignment

Mapping. This is an ordered container with a dict-like interface. The

keys are unique string names, and the values are instances of the

assignment class.</p>

<p>Assignment mappings can be stored in two different kinds of locations depending on their type: site-wide or contextual.</p>

<h3>Site-wide</h3>

<p>Site-wide assigned portlets are shown in the whole site, unless

blocked. They're stored in Portlet Managers. Portlet Managers define a

column or other area that can be filled with portlets, and are

analogous to the viewlet manager for viewlets. They are named

persistent local utilites providing the <code>IPortletManager</code> interface.</p>

<p>You can look up a portlet manager like this:</p>

<pre>manager = getUtility(IPortletManager, name=u"plone.leftcolumn")</pre>

<p>By default, there are two standard portlet managers, <code>plone.leftcolumn</code> and <code>plone.rightcolumn</code>, as well as four portlet managers for the four columns on the dashboard, from <code>plone.dashboard1</code> to <code>plone.dashboard4</code>. You can create your own in <code>portlets.xml</code> like this:</p>

<pre>&lt;portletmanager
  name="my.package.myportletmanager"
&nbsp; type="my.package.interfaces.IMyPortletManagerType"
  /&gt;</pre>

<p>The "type" is a marker interface that can be used to install

particular portlets only for particular types of portlet managers, as

explained above. Example: <code>plone.app.portlets.interfaces.IDashboard</code>.</p>

<p>Portlets in global categories (site-wide) are stored directly inside the <code>IPortletManager</code>

utility, under a particular category - e.g. "group" - a

category-specific key - e.g. the group id - and finally a unique

portlet id. Putting this together, we could access a particular portlet

assignment like this:</p>

<pre>from plone.portlet.constants import GROUP_CATEGORY
manager = getUtility(IPortletManager, name=u"plone.leftcolumn")
recent_assignment = manager[GROUP_CATEGORY][u"Administrators"][u"recent"]</pre>

<p>Here we look up the left column portlet manager and get the portlet assignment named <em>recent</em> assigned to the <em>Administrators</em> group.</p>

<p>

Each of the lookups here has a dict interface, so you can iterate, call <code>keys()</code>

and so on. You can store assignments under any string as category, but

the default portlet retriever is only aware of the three site-wide

assignment categories defined as constants in <em>plone.portlet.constants</em>, <code>USER_CATEGORY</code>, <code>GROUP_CATEGORY</code> and <code>CONTENT_TYPE_CATEGORY</code>, which should be enough for most use-cases. More on portlet retrievers later.</p>

<h3>Contextual</h3>

<p>Location-specific portlet assignments are stored on annotations on objects providing the <code>ILocalPortletAssignable</code> marker interface.</p>

<p>To get hold of the assignment in this case, we multi-adapt the content object and the manager instance to the <code>IPortletAssignment</code> interface, like so:</p>

<pre>manager = getUtility(IPortletManager, name=u"plone.leftcolumn")
assignment_mapping = getMultiAdapter((context, manager), IPortletAssignmentMapping)
news_portlet = assignment_mapping[u"news"]</pre>

<p>There are two functions in plone.app.portlets.utils to make it

easier to find the appropriate mapping for a portlet, or to get a

portlet assignment directly: <code>assignment_mapping_from_key()</code> and <code>assignment_from_key()</code>.</p>

<p>We can use GenericSetup to assign portlets to particular portlet

managers upon the installation of a product. Read the <a class="external-link" href="http://plone.org/documentation/manual/developer-manual/theme-reference/elements/portlet/move/">Theme Reference

Manual</a> for info about how to do that. Read the <a class="external-link" href="http://plone.org/documentation/tutorial/genericsetup">Generic Setup tutorial</a> for further info about what's GenericSetup and how it works.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                4.5.
                How are portlets rendered?
            </h1>

            <p class="documentDescription">The
process to find, update and render portlets from the main views is
rather complex. Here we describe how does it all work, step by step.</p>
    
            <div>
                
                    <div><p>Portlets are always rendered inside a portlet manager. From a

template, we can ask a portlet manager to render itself and all its

portlets. This is achieved using a <em>zope.contentprovider</em> 'provider:' expression. In Plone's <em>main_template</em>, for example, you will find:</p>

<pre>&lt;tal:block replace="structure provider:plone.leftcolumn" /&gt;
</pre>

<p>Behind the scenes, this will look up a local adapter on (context, request, view) with name <code>plone.leftcolumn</code> (this is just how the provider expression works).</p>

<p>As it happens, this local adapter factory was registered when the portlet manager was installed (via <code>portlets.xml</code>), and is a callable that returns an <code>IPortletManagerRenderer</code>. The portlet manager renderer is the "view" of the portlet manager.</p>

<p>The default implementation will simply output each portlet wrapped

in a div tag with some helpful attributes to support AJAX via KSS. You

can of course register your own portlet manager renderers. A portlet

manager renderer is a multi-adapter on (context, request, view,

manager). The <code>@@manage-portlets</code> view, for example, relies

on a portlet manager renderer override for this particular view that

renders the add/move/delete operations. For most people, the standard

renderer will suffice, though.</p>

<p>The portlet manager renderer asks an <code>IPortletRetriever</code>

to fetch and order the portlet assignments that it should render. This

is a multi-adapter on (context, manager), which means that the fetch

algorithm can be overridden either based on the type of content object

being viewed, or the particular manager. There are two default

implementations - one for "placeful" portlet managers (those which know

about contextual portlets, such as the standard left/right column ones)

and one for "placeless" ones that only deal in global categories. This

latter retriever is used by the dashboard, which stores its portlets in

a global "user" category.</p>

<p>The <code>IPortletRetriever</code> algorithm is reasonably complex,

especially when contextual blacklisting/blocking is taken into account

(see below). To make it possible to re-use this algorithm across

multiple configurations, it is written in terms of an <code>IPortletContext</code>. The context content object will be adapted to this interface. The portlet context provides:</p>

<ul><li>A universal identifier for the current context (usually just the physical path) - the <code>uid</code> property.<br></li><li>A

way to obtain the parent object of the current context (for acquiring

portlets and blacklist information in a placeful retriever) - the <code>getParent()</code> method.<br></li><li>A list of global portlet categories to look up, and the keys to look under (obtainable by using the <code>globalPortletCategories()</code> method on the adapted context).<br></li></ul><p>The last parameter is best described by an example. Let's say we're

logged in as "testuser", a member of both the "Administrators" and

"Reviewers" groups, and were looking at a Folder. The return value of <code>globalPortletCategories()</code> would then be:</p>

<pre>&gt;&gt;&gt; portlet_context.globalPortletCategories()
[("content_type", "Folder",),
&nbsp;("group", "Administrators",),
&nbsp;("group", "Reviewers",),
&nbsp;("user", "testuser",)]
</pre>

<p>This informs the retriever that it should first look up any portlets

in the current portlet manager in the "content_type" category under the

"Folder" key, and then portlets in the "group" category under the

"Administators" and "Reviewers" key, and finally portlets in the "user"

category under the "testuser" key, all in that order. Thus, if we

wanted to add a new category, or change the order of categories, we

could override the <code>IPortletContext</code>, either everywhere or just for one particular type of context.</p>

<p>Once the <code>IPortletRetriever</code> has retrieved the

assignments that should be shown for the current portlet manager, the

portlet manager renderer will look up the portlet renderer for each

assignment, ensure that it should indeed be rendered by checking its <code>available</code> property, and finally call <code>update()</code> and <code>render()</code>, placing the output in the reponse.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                4.6.
                Appendix: Practicals
            </h1>

            <p class="documentDescription"></p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                4.6.1.
                 Subclassing new portlets 
            </h1>

            <p class="documentDescription"> This how-to briefly explains how to create new portlets based on another existing portlet class. (Mikko Ohtama)</p>
    
            <div>
                
                    <div id="parent-fieldname-text" class="kssattr-atfieldname-text kssattr-templateId-widgets/rich kssattr-macro-rich-field-view">

<p>Portlet

subclassing is not trivial due to explict references between portlet

engine parts. Here are short instructions minimal steps to needed to a

subclass a portlet to another portlet. Instead of modifying the

existing portlet, we need to create a new invariant with little changed

properties. <a class="reference" href="http://martinaspeli.net/articles/an-introduction-to-plone-portlets">See this general briefing about Plone 3.x portlet mechanism.</a> This example modifies the render behavior of static text portlet, by adding a grey backgroundd CSS class for it.</p>

<ol class="arabic simple"><li>Create a portlet interface stub and portlets Python module: To define a new portlet. Refer this in your product ZCML.</li><li>Create a new assigment class: To make new portlet assignable through portlet manager</li><li>Create a new add form class: To make new portlet creatable, returning your custom portlet instances</li><li>Create a configure.xml ZCML entry: To make Zope to find the new portlet definition</li><li>Create a portlets.xml installer entry: To make the portlet appear in the portlet manager menu</li></ol><p>The

portlet interface class is fixed to a portlet when the portlet is

created. Thus, if you make changes any of above, you might need to

create a new portlet to see the effect - old portlet instances don't

necessarily see the changees.</p>

<p>Our portlet code lies in <em>myproduct/browser/portlets/misc.py</em>:</p>

<pre class="literal-block">from zope.interface import implements<br>from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile<br>from plone.portlet.static import PloneMessageFactory as _<br><br># Import the base portlet module whose properties we will modify<br>from plone.portlet.static import static<br><br>class IGreyStaticPortlet(static.IStaticPortlet):<br>    """ Defines a new portlet "grey static" which takes properties of the existing static text portlet. """<br>    pass<br><br>class GreyStaticRenderer(static.Renderer):<br>    """ Overrides static.pt in the rendering of the portlet. """<br>    render = ViewPageTemplateFile('grey_static.pt')<br><br>class GreyStaticAssignment(static.Assignment):<br>    """ Assigner for grey static portlet. """<br>    implements(IGreyStaticPortlet)<br><br>class GreyStaticAddForm(static.AddForm):<br>    """ Make sure that add form creates instances of our custom portlet instead of the base class portlet. """<br>    def create(self, data):<br>        return GreyStaticAssignment(**data)<br></pre>

<p><em>myproduct/browser/portlets/configure.zcml</em> snippet. Note that we do not need to override all (EditForm) views:</p>

<pre class="literal-block">&lt;configure xmlns="http://namespaces.zope.org/zope"<br>           xmlns:browser="http://namespaces.zope.org/browser"<br>           xmlns:plone="http://namespaces.plone.org/plone"&gt;<br><br>    &lt;include package="plone.app.portlets" /&gt;<br><br>        &lt;plone:portlet<br>        name="lsm.GreyStaticPortlet"<br>        interface=".misc.IGreyStaticPortlet"<br>         assignment=".misc.GreyStaticAssignment"<br>         view_permission="zope2.View"<br>         edit_permission="cmf.ManagePortal"<br>         renderer=".misc.GreyStaticRenderer"<br>         addview=".misc.GreyStaticAddForm"<br>         editview="plone.portlet.static.static.EditForm"<br>         /&gt;<br><br>&lt;/configure&gt;<br></pre>

<p><em>myproducts/profiles/default/portlets.xml</em> quick installer snippet:</p>

<pre class="literal-block">&lt;portlets&gt;<br><br>  &lt;portlet<br>    addview="lsm.GreyStaticPortlet"<br>    title="Static portlet (grey)"<br>    description="Portlet with light grey background"<br>    /&gt;<br><br>&lt;/portlets&gt;<br></pre>

<p><em>myproduct/browser/portlets/grey_static.pt</em>. We have

added one new CSS class (portletGrey) which has a CSS class definition

defined in ploneCustom.css (through-the-web) or some of the product's

CSS files:</p>

<pre class="literal-block">&lt;div tal:condition="view/data/omit_border"<br>     tal:attributes="class string:portletStaticText ${view/css_class}"<br>     tal:content="structure view/data/text" /&gt;<br>&lt;dl tal:condition="not:view/data/omit_border"<br>    tal:attributes="class string:portlet portletStaticText portletGrey ${view/css_class}"<br>    i18n:domain="plone"&gt;<br><br>    &lt;dt class="portletHeader"&gt;<br>        &lt;span class="portletTopLeft"&gt;&lt;/span&gt;<br>        &lt;span&gt;<br>           &lt;a tal:omit-tag="not:view/has_link"<br>              tal:attributes="href view/data/more_url"<br>              tal:content="view/data/header"<br>              /&gt;<br>        &lt;/span&gt;<br>        &lt;span class="portletTopRight"&gt;&lt;/span&gt;<br>    &lt;/dt&gt;<br><br>    &lt;dd class="portletItem odd"&gt;<br>        &lt;div tal:replace="structure view/data/text" /&gt;<br>        &lt;tal:corners condition="not:view/has_footer"&gt;<br>            &lt;span class="portletBottomLeft"&gt;&lt;/span&gt;<br>            &lt;span class="portletBottomRight"&gt;&lt;/span&gt;<br>        &lt;/tal:corners&gt;<br>    &lt;/dd&gt;<br><br>    &lt;dd class="portletFooter" tal:condition="view/has_footer"&gt;<br>        &lt;span class="portletBotomLeft"&gt;&lt;/span&gt;<br>        &lt;span&gt;<br>           &lt;a tal:omit-tag="not:view/has_link"<br>              tal:attributes="href view/data/more_url"<br>              tal:content="view/data/footer"<br>              /&gt;<br>        &lt;/span&gt;<br>        &lt;span class="portletBottomRight"&gt;&lt;/span&gt;<br>    &lt;/dd&gt;<br><br>&lt;/dl&gt;<br></pre>

<p><em>myproduct/browser/portlets/__init__.py</em>. Create empty file to a mark a Python module.</p>

<p><em>myproduct/configure.zcml</em>. Add following snippet:</p>

<pre class="literal-block">&lt;include package=".portlets" /&gt;<br></pre>

</div>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-1">

            <h1>
                5.
                Indexing and searching
            </h1>

            <p class="documentDescription">How to index and look for content into your Plone site using the Catalog Tool.</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-2">

            <h1>
                5.1.
                Introduction to ZCatalogs and the Catalog Tool
            </h1>

            <p class="documentDescription">A brief introduction to ZCatalogs, the Catalog Tool and what they're used for.</p>
    
            <div>
                
                    <div><h3>Why ZCatalogs?<br></h3>

<p>Plone is built on the CMF, which uses the ZODB to store content in a
very free-form manner with arbitrary hierarchy and a lot of flexibility
in general. For some content use cases, however, it is very useful to
treat content as more ordered, or tabular. This is where ZCatalog comes
in.</p>

<p>Searching, for example, requires being able to query content on
structured data such as dates or workflow states. Additionally, query
results often need to be sorted based on structured data of some sort.
So when it comes to searching it is very valuable to treat our
free-form persistent ZODB objects as if they were more tabular.
ZCatalog indexes do exactly this.</p>

<p>Since the ZCatalog is in the business of treating content as tabular
when it isn't necessarily so, it is very tolerant of any missing data
or exceptions when indexing. For example, Plone includes "start" and
"end" indexes to support querying events on their start and end
dates.&nbsp; When a page is indexed, however, it doesn't have start or
end dates.&nbsp; Since the ZCatalog is tolerant, it doesn't raise any
exception when indexing the start or end dates on a page. Instead it
simply doesn't include pages in those indexes. As such, it is
appropriate to use indexes in the catalog to support querying or
sorting when not all content provides the data indexed.</p>

<p class="callout">This manual is intended to be a brief start guide to
ZCatalogs, specially aimed to tasks specific to Plone, and will not
treat advanced ZCatalogs concepts in depth. If you want to learn more
about ZCatalogs in the context of Zope, please refer to <a class="external-link" href="http://docs.zope.org/zope2/zope2book/SearchingZCatalog.html">The Zope Book, Searching and Categorizing Content</a>. If you want to perform advanced searches, <a class="external-link" href="http://www.dieter.handshake.de/pyprojects/zope/AdvancedQuery.html">AdvancedQuery</a>, which is included with Plone since the 3.0 release, is what you're looking for. See <a class="external-link" href="http://plone.org/documentation/manual/developer-manual/indexing-and-searching/searching-with-advancedquery/">Searching with AdvancedQuery</a> for a brief introduction.</p>

<h3>Quick start</h3>

<p>Every ZCatalog is composed of indexes and metadata. Indexes are
fields you can search by, and metadata are copies of the contents of
certain fields which can be accessed without waking up the associated
content object.</p>

<p>Most indexes are also metadata fields. For example, you can search objects by <em>Title</em> and then display the <em>Title</em> of each object found without fetching them, but note not all indexes need to be part of metadata.</p>

<p>When you search inside the catalog, what you get as a result is a
list of elements known as brains. Brains have one attribute for each
metadata field defined in the catalog, in addition to some methods to
retrieve the underlying object and its location. Metadata values for
each brain are saved in the metadata table of the catalog upon the
(re)indexing of each object.</p>

<p>Brains are said to be lazy for two reasons; first, because they are
only created 'just in time' as your code requests each result, and
second, because retrieving a catalog brain doesn't wake up the objects
themselves, avoiding a huge perfomance hit.</p>

<p>To see the ZCatalogs in action, fire up your favourite browser and
open the ZMI. You'll see an object in the root of your Plone site named
<em>portal_catalog</em>. This is the Catalog Tool, a Plone tool (like
the Membership Tool or the Quickinstaller Tool) based on ZCatalogs
created by default in every Plone site which indexes all the created
content.</p>

<p>Open it and click the <em>Catalog</em> tab, at the top of the
screen. There you can see the full list of currently indexed objects,
filter them by path, and update and remove entries. If you click on any
entry, a new tab (or window) will open showing the metadata and index
values for the selected indexed object. Note that most fields are
"duplicated" in the <em>Index Contents</em> and <em>Metadata Contents</em>
tables, but its contents have different formats, because, as it was
said earlier, indexes are meant to search by them, and metadata to
retrieve certain attributes from the content object without waking it
up.</p>

<p>Back to the management view of the Catalog Tool, if you click the <em>Indexes</em> or the <em>Metadata</em>
tab you'll see the full list of currently available indexes and
metadata fields, respectively, its types and more. There you can also
add and remove indexes and metadata fields. If you're working on a test
environment, you can use this manager view to play with the catalog,
but beware indexes and metadata are usually added through GenericSetup
and not using the ZMI.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                5.2.
                Querying the catalog
            </h1>

            <p class="documentDescription">How to search and list content by title, description, interface, location, etc.</p>
    
            <div>
                
                    <div><p>The
Catalog Tool has an easy and clean API to search for content. First of
all, you need to acquire it from the current context. Here <code>context</code> can be any object in the site:</p>

<pre>from Products.CMFCore.utils import getToolByName
catalog = getToolByName(context, 'portal_catalog')</pre>

<p>To search for something and get the resulting brains, write:</p>

<pre>results = catalog.searchResults(**kwargs)</pre>

<p>Where <code>kwargs</code> is a dictionary of index names and their
associated query values. Only the indexes that you care about need to
be included. This is really useful if you have variable searching
criteria, for example, coming from a form where the users can select
different fields to search for. For example:</p>

<pre>results = catalog.searchResults({'portal_type': 'Event', 'review_state': 'pending'})</pre>

<p>It is worth pointing out at this point that the indexes that you
include are treated as a logical AND, rather than OR. In other words,
the query above will find all the items that are both an Event, AND in
the review state of pending.</p>

<p>Additionally, you can call the catalog tool directly, which is equivalent to calling  <code>catalog.searchResults()</code>:</p>

<pre>results = catalog(portal_type='Event')</pre>

<h3>Available indexes<br></h3>

<p>To see the full list of available indexes in your catalog, open the ZMI (what usually means navigating to <em>http://yoursiteURL/manage</em>) look for the <em>portal_catalog</em> object tool into the root of your Plone site and check the <em>Indexes</em>
tab. Note that there are different types of indexes, and each one
admits different types of search parameters, and behave differently.
For example, <em>FieldIndex</em> and <em>KeywordIndex</em> support sorting, but <em>ZCTextIndex</em> doesn't. To learn more about indexes, see <a class="external-link" href="http://docs.zope.org/zope2/zope2book/SearchingZCatalog.html">The Zope Book, Searching and Categorizing Content</a>.</p>

<p>Some of the most commonly used ones are:</p>

<dl><dt>Title</dt><dd>The title of the content object. </dd><dt>Description </dt><dd>The description field of the content. </dd><dt>Subject </dt><dd>The keywords used to categorize the content. Example:<br><pre>catalog.searchResults(Subject=('cats', 'dogs'))</pre>

</dd><dt>portal_type </dt><dd>As its name suggest, search for content whose portal type is indicated. For example: <br><pre>catalog.searchResults(portal_type='News Item')</pre>

<p>You can also specify several types using a list or tuple format:</p>

<pre>catalog.searchResults(portal_type=('News Item', 'Event'))</pre>

</dd><dt>review_state </dt><dd>The current workflow review state of the content. For example:<br><pre>catalog.searchResults(review_state='pending')</pre>

</dd><dt>object_provides</dt><dd>From Plone 3, you can search by the interface provided by the content. Example:<br><pre>from Products.MyProduct.path.to import IIsCauseForCelebration
catalog(object_provides=IIsCauseForCelebration.__identifier__)</pre>

Searching for interfaces can have some benefits. Suppose you have several types, for example, event types like <em>Birthday</em>, <em>Wedding</em> and <em>Graduation</em>, in your portal which implement the

same interface (for example, <code>IIsCauseForCelebration</code>). Suppose you want to

get items of these types from the catalog by their interface. This is more exact than naming the

types explicitly (like portal_type=['Birthday','Wedding','Graduation'

]), because you don't really care what the types' names really are: all you really care for is the interface.<br>This has the additional advantage that if products added or modified

later add types which implement the interface, these new types will

also show up in your query. </dd></dl><h3>Sorting and limiting the number of results<br></h3>

<p>To sort the results, use the sort_on and sort_order arguments. The
sort_on argument accepts any available index, even if you're not
searching by it. The sort_order can be either 'ascending' or
'descending', where 'ascending' means from A to Z for a text field.
'reverse' is an alias equivalent to 'descending'. For example:</p>

<pre>results = catalog_searchResults(Description='Plone documentation', 
                                sort_on='sortable_title', sort_order='ascending')</pre>

<p>The catalog.searchResults() returns a list-like object, so to limit
the number of results you can just use Python's slicing. For example,
to get only the first 3 items:</p>

<pre>results = catalog_searchResults(Description='Plone documentation')[:3]</pre>

<p>In addition, ZCatalogs allow a sort_limit argument. The sort_limit
is only a hint for the search algorhitms and can potentially return a
few more items, so it's preferable to use both <code>sort_limit</code> and slicing simultaneously:</p>

<pre>limit = 50
results = catalog_searchResults(Description='Plone documentation', 
                                sort_limit=limit)[:limit]</pre>

<h3>Searching for content within a folder</h3>

<p>Use the 'path' argument to specify the physical path to the folder you want to search into.</p>

<p>By default, this will match objects into the specified folder and
all existing sub-folders. To change this behaviour, pass a dictionary
with the keys 'query' and 'depth' to the 'path' argument, where</p>

<ul><li>'query' is the physical path, and&nbsp;</li><li>'depth' can be
either 0, which will return only the brain for the path queried
against, or some number greater, which will query all items down to
that depth (eg, 1 means searching just inside the
specified folder, or 2, which means searching inside the folder, and
inside all child folders, etc).</li></ul><p>The most common use case is listing the contents of an existing folder, which we'll assume to be the <code>context</code> object in this example:</p>

<pre>folder_path = '/'.join(context.getPhysicalPath())
results = catalog(path={'query': folder_path, 'depth': 1})</pre>

<h3>Getting the underlying object, its path, and its URL from a brain<br></h3>

<p>As it was said earlier, searching inside the catalog returns catalog
brains, not the object themselves. If you want to get the object
associated with a brain, do:</p>

<pre>brain.getObject()</pre>

<p>To get the path of the object without fetching it:</p>

<pre>brain.getPath()</pre>

<p>which is equivalent to <code>obj.getPhysicalPath()</code>.</p>

<p>And finally, to get the URL of the underlying object, usually to provide a link to it:</p>

<pre>brain.getURL()</pre>

<p>which is equivalent to <code>obj.absolute_url()</code>.</p>

<p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                5.3.
                Configuring Catalogs with GenericSetup
            </h1>

            <p class="documentDescription">Adding, removing and changing indexes and metadata.</p>
    
            <div>
                
                    <div><p>The
Catalog Tool can be configured through the ZMI or programatically in
Python but current best practice in the CMF world is to use
GenericSetup to configure it using the declarative <em>catalog.xml</em> file. The GenericSetup profile for Plone, for example, uses the <em>CMFPlone/profiles/default/catalog.xml</em>
XML data file to configure the Catalog Tool when a Plone site is
created. It is fairly readable so taking a quick look through it can be
very informative.</p>

<p>When using a GenericSetup extension profile to customize the Catalog Tool<em></em>
in your portal, you only need to include XML for the pieces of the
catalog you are changing. To add an index for the Archetypes location
field, as in the example above, a policy package could include the
following <em>profiles/default/catalog.xml</em>:</p>

<pre>&nbsp;&nbsp;&nbsp; &lt;?xml version="1.0"?&gt;
&nbsp;&nbsp;&nbsp; &lt;object name="portal_catalog" meta_type="Plone Catalog Tool"&gt;
&nbsp;&nbsp;&nbsp;&nbsp; &lt;index name="location" meta_type="FieldIndex"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;indexed_attr value="location"/&gt;
&nbsp;&nbsp;&nbsp;&nbsp; &lt;/index&gt;
&nbsp;&nbsp;&nbsp; &lt;/object&gt;</pre>

<p>The GenericSetup import handler for the Catalog Tool also supports
removing indexes from the catalog if present using the "remove"
attribute of the <em>&lt;index&gt;</em> element. To remove the "start" and "end" indexes used for events, for example, a policy package could include the following <em>profiles/default/catalog.xml</em>:</p>

<pre>&nbsp;&nbsp;&nbsp; &lt;?xml version="1.0"?&gt;
&nbsp;&nbsp;&nbsp; &lt;object name="portal_catalog" meta_type="Plone Catalog Tool"&gt;
&nbsp;&nbsp;&nbsp;&nbsp; &lt;index name="start" remove="True" /&gt;
&nbsp;&nbsp;&nbsp;&nbsp; &lt;index name="end" remove="True" /&gt;
&nbsp;&nbsp;&nbsp; &lt;/object&gt;
</pre>

<p>Care must be taken when setting up indexes with GenericSetup - if the import step for a <em>catalog.xml</em>
is run a second time (for example when you reinstall the product), the
indexes specified will be destroyed, losing all currently indexed
entries, and then re-created fresh (and empty!). If you want to
workaround this behaviour, you can either update the
catalog afterwards or add the indexes yourself in Python code using a
custom import handler.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                5.4.
                Custom indexing strategies
            </h1>

            <p class="documentDescription">How to add special logic to indexing.</p>
    
            <div>
                
                    <div><p>Sometimes
you want to index "virtual" attributes of an object computed from
existing ones, or just want to customize the way certain attributes are
indexed, for example, saving only the 10 first characters of a field
instead of its whole content.</p>

<p>To do so in an elegant and flexible way, Plone 3.3 includes a new package, <code>plone.indexer</code>, which provides a series of primitives to delegate indexing operations to adapters.</p>

<p>Let's say you have a content-type providing the interface <code>IMyType</code>.
To define an indexer for your type which takes the first 10 characters
from the body text, just type (assuming the attribute's name is 'text'):</p>

<pre>from plone.indexer.decorator import indexer

@indexer(IMyType)
def mytype_description(object, **kw):
&nbsp; &nbsp;&nbsp; return object.text[:10]
</pre>

<p>Finally, register this factory function as a named adapter using ZCML. Assuming you've put the code above into a file named <code>indexers.py</code>:</p>

<pre>&nbsp;&nbsp; &lt;adapter name="description" factory=".indexers.mytype_description" /&gt;
</pre>

<p>And that's all! Easy, wasn't it?</p>

<p>Note you can omit the <code>for</code> attribute because you passed this to the <code>@indexer</code> decorator, and you can omit the <code>provides</code> attribute because the thing returned by the decorator is actually a class providing the required <code>IIndexer</code> interface.</p>

<p>To learn more about the <em>plone.indexer</em> package, read <a class="external-link" href="http://dev.plone.org/plone/browser/plone.indexer/trunk/plone/indexer/README.txt">its doctest</a>.</p>

<p>For more info about how to create content-types, refer to the <a class="external-link" href="http://plone.org/documentation/manual/archetypes">Archetypes Developer Manual</a>.</p>

<p><strong>Important note:</strong> If you want to adapt a
out-of-the-box Archetypes content-type like Event or News Item, take
into account you will have to feed the <code>indexer</code> decorator with the Zope 3 interfaces defined in <code>Products.ATContentTypes.interface.*</code> files, not with the deprecated Zope 2 ones into the <code>Products.ATContentTypes.interfaces</code> file.</p>

<p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                5.5.
                Searching with AdvancedQuery
            </h1>

            <p class="documentDescription">A brief primer on using AdvancedQuery to simplify searches that are otherwise hard with plain ZCatalog</p>
    
            <div>
                
                    <div><p>AdvancedQuery
is an excellent product that overcomes several of the more cumbersome
limitations otherwise present with plain ZCatalog queries. The
comprehensive documentation is available <a class="external-link" href="http://www.dieter.handshake.de/pyprojects/zope/AdvancedQuery.html">here</a>.</p>

<p>If you want to install it, require it in your&nbsp;add-on product's <em>setup.py</em>:<a class="external-link" href="http://www.dieter.handshake.de/pyprojects/zope/AdvancedQuery.html"></a></p>

<pre>      install_requires=[
          'setuptools',
          'Products.AdvancedQuery',</pre>

<p>AdvancedQuery is straightforward to use. In the simplest scenario,
it can simply duplicate the action of running a normal ZCatalog query:</p>

<pre>from Products.CMFCore.utils import getToolByName
cat = getToolByName(context, 'portal_catalog')
aq = cat.makeAdvancedQuery({'portal_type' : 'Event', 'review_state' : 'pending'})
brains = cat.evalAdvancedQuery(aq)</pre>

<p>At this stage, all it looks like is a slightly more complicated way
of doing things that you already know how to do. However, AdvancedQuery
comes into its own by making possible things that are otherwise very
hard to do with plain ZCatalog queries. For example, we want to get all
published <em>Document</em>s sorted first by <em>Creator</em>, and sub-sorted by date of publication:</p>

<pre>from Products.CMFCore.utils import getToolByName
cat = getToolByName(context, 'portal_catalog')
aq = cat.makeAdvancedQuery({'portal_type' : 'Document', 'review_state' : 'published'})
brains = cat.evalAdvancedQuery(aq, (('Creator', 'asc'), ('effective', 'asc')))</pre>

<p>Or how about only those documents the same as above which have had related items noted against them?</p>

<pre>from Products.AdvancedQuery import Ge
from Products.CMFCore.utils import getToolByName
cat = getToolByName(context, 'portal_catalog')
aq = cat.makeAdvancedQuery({'portal_type' : 'Document', 'review_state' : 'published'})
aq &amp;= Ge('getRawRelatedItems', None)
brains = cat.evalAdvancedQuery(aq, (('Creator', 'asc'), ('effective', 'asc')))</pre>

<p>As you can see, AdvancedQuery makes specifying <em>exactly</em> what
you want from the catalog very easy, and the transition to using it is
very straightforward, as it already accepts the same sort of query
parameters and format that you are already familiar with. When you are
ready, you can mix in more advanced criteria without disturbing your
existing way of working with the Catalog Tool.</p>

<p>It's strongly recommended to read the AdvancedQuery documentation
linked to above and playing with some of the more advanced options it
details.</p></div>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-1">

            <h1>
                6.
                Forms
            </h1>

            <p class="documentDescription">Creating forms for Plone</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-2">

            <h1>
                6.1.
                Using zope.formlib
            </h1>

            <p class="documentDescription">zope.formlib
is a zope 3 library to handle forms creation, validation, display and
actions. It provides a series of base classes and methods to allow
forms to be defined with just a little bit of meta data. </p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                6.1.1.
                Why learn how to use a new framework?
            </h1>

            <p class="documentDescription">You
may be wondering why should you learn how to use a new forms framework
if you already know how to use the CMF Form Controller Tool (Form
Controller).</p>
    
            <div>
                
                    <div><p>Why
should you use a forms framework at all? You could always write your
own HTML form snippets and use the request dictionary to retrieve and
handle data.</p>

<p>The reason is simple: you'll end up writing a lot of boilerplate
code to collect, validate and build the response. It would be better if
you could just define the fields and metadata of the form and re-use a
set of base classes to do the repetitive work behind the scenes, i.e.,
a forms framework.</p>

<p>One of these frameworks is the Form Controller Tool, which is not bad, but has some disadvantages over formlib:</p>

<ul><li>First, the Form Controller spreads the form logic across several files so it can be hard to follow it.<br></li><li>Second,
the From Controller doesn't handle the creation and display of the
widgets, so you have to create them manually, what could become <em>especially</em> unmantainable when using choice-type fields.<br></li><li>Last,
the Form Controller doesn't work with Zope 3 schema interfaces nor
views. Using a Zope 3 schema can help you creating add and edit forms.<br></li></ul><p>However,
the Form Controller can be useful and even preferable when you need to
implement a complex page flow, or if you want to customize Plone forms
that use it; e.g. the ''Send this page to someone'' form.</p>

<p>Beginning with Zope 2.9.3 (Plone 2.5) zope.formlib is being distributed

with Zope 2.  Five &gt;= 1.4 is required to make use of this

Zope 3 package.</p>

<h3>Note: Where do I place the code?</h3>

<p>You can place the code wherever you want: all in the same file, each class in a file, in several directories, utilities in a <code>utilities.py</code> file, etc. Just keep in mind two things:</p>

<ul><li>If you write several pieces of code (functions, classes) in
separate files, remember to import them whenever you use them, as you
would do in any other Python program.<br></li><li>The ZCML statements have to be placed into a file called <code>configure.zcml</code> in the root of your package, or in any other file included from it.</li></ul><p>Said that, the author reccommends putting all the Python code in a file named <code>browser.py</code> in this tutorial to avoid confusion.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                6.1.2.
                Creating a simple feedback form
            </h1>

            <p class="documentDescription">This section explains how to create a very basic feedback form.</p>
    
            <div>
                
                    <div><p class="callout">The code for this example is available to checkout from the collective as <a class="external-link" href="http://svn.plone.org/svn/collective/example.formlib/">the <em>example.formlib</em> package</a>.</p>

<p>For all practical sense formlib based components are really

regular Zope view components with some convenient base classes for

auto-generating output based on schemas and other configuration info. You will see that in a moment.</p>

<p>First, define an interface class with the schema of the form:</p>

<pre>from zope.interface import Interface
from zope.schema import TextLine, Text

class IFeedbackForm(Interface):
    """
    A typical feedback schema
    """
    customer = TextLine(title=u'Customer',
                      description=u'Customer email',
                      required=True)

    subject = TextLine(title=u'Subject',
                       required=True)

    message = Text(title=u'Message',
                   description=u'The message body',
                   required=True)
</pre>

<p>The purpose of this interface is to define the fields of the form.
The type of each schema field determines the type of widget that will
be
used by default for that field, so choose it carefully. To see all the
schema fields
available, read the zope.schema package's interfaces.</p>

<p>Next, create a form instance, which is a class that groups an
ordered collection of fields and actions. To do that, simply subclass
Five's PageForm class, a wrapper to the formlib Form class to keep Zope
2 happy. Type the following code into a Python file inside your product:</p>

<pre>from Products.Five.formlib.formbase import PageForm</pre>

<p>You will also need to make use of Five's strange hybrid between Zope 2 and Zope 3 page templates:</p>

<pre>from Products.Five.browser.pagetemplatefile import ViewPageTemplateFile</pre>

<p>The simplest way to define a collection of form fields is using the <code>Fields</code> constructor with the previous schema:</p>

<pre>from zope.formlib import form

class FeedbackForm(PageForm):
    """
    A typical feedback form
    """
    form_fields = form.Fields(IFeedbackForm)</pre>

<p>By inheriting from the <code>PageForm</code> class, the <code>FeedbackForm</code> class inherit functionality from

formlib itself.  By default, <code>PageForm</code> knows how to generate all the HTML

that will make up of a finished form.  But in order to do this, formlib

needs to know what fields are wanted. This is done by providing the

<span class="pre">form_fields</span> attribute. The <code>Fields</code> constructor is a formlib helper class that

generates the appropriate field items from any Zope 3 schema (in this case,

the schema interface defined above).</p>

<p>In order to provide a complete form, you need to specify the action
to perform when the "submit" button of the form (or any other
indicated) is activated. To define the action, use the <code>form.action</code> decorator with a handler function for the submitted data. More on actions later.</p>

<pre><strong># use a dummy MailHost tool here to keep it simple

class MHost:

    def __init__(self):

        pass

    def Send(self, sender, to, subject, body):

        pass</strong>

class FeedbackForm(PageForm):
    """
    A typical feedback form
    """
    form_fields = form.Fields(IFeedbackForm)
<strong>    result_template = ViewPageTemplateFile('feedback_result.pt')



    @form.action("send")

    def action_send(self, action, data):

        mhost = MHost()

        self.mFrom = data['customer']

        self.mTo = "feedback@mycompany.com"

        self.mSubject = data['subject']

        self.mBody = data['message']

        mhost.Send(self.mFrom, self.mTo, self.mSubject, self.mBody)

        return self.result_template()</strong></pre>

<p>



This is where the real work takes place. In this example, the <code>feedback_result.pt</code>
page template is rendered and returned. All the view's attributes will
be available inside this template, which will be introduced later.</p>

<p>An example result form is:</p>

<pre>&lt;html metal:use-macro="context/@@standard_macros/view"&gt;
     
&lt;head&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div metal:fill-slot="body"&gt;
        &lt;h1 tal:content="view/label"&gt;Form label&lt;/h1&gt;
        &lt;p&gt;Thank you for your request about
        &lt;span tal:replace="view/mSubject"&gt;subject&lt;/span&gt;,
        &lt;span tal:replace="view/mFrom"&gt;customer@mail&lt;/span&gt;.&lt;/p&gt;
        &lt;p&gt;We will reply to it shortly.&lt;/p&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

<p>zope.formlib already includes a default general page form template,
with the fields labels, the widgets structures and the submit buttons,
so you only have to register your form page with the appropiate ZCML
snippet in order to make it accesible from a browser. Assuming you've
placed your code into a file named <code>browser.py</code>:</p>

<pre>&lt;browser:page
        name="feedback"
        for="Products.CMFPlone.Portal.PloneSite"
        class=".browser.FeedbackForm"
        permission="zope.Public"
        /&gt;
</pre>

Let's explain what this ZCML snippet means:

<ul><li>The <code>for</code> attribute indicates the class or interface
this view will be available for; in this case, it will be shown only
from the root of a Plone site. To see the interfaces provided by a
certain object, fire up the ZMI, navigate up to your object and check
the Interfaces tab.</li><li>The <code>name</code> attribute sets the name of the view, so the form will be available from a URL with the form <code>http://&lt;plone-site&gt;/feedback</code>.</li><li>The <code>class</code> attribute indicates the view class responsible for displaying the page form, in this case, the FeedbackForm class inside the <code>browser.py</code> file.</li><li>The <code>permission</code> attribute specify the permission needed to access the page.</li></ul><p>Among the most used permissions you can find:</p>

<ul><li><code>zope.Public</code> - no restrictions, available to everyone.</li><li><code>zope.View</code> - permission to view this component.</li><li><code>zope.ManageContent</code> - add, edit and delete content objects.</li></ul><blockquote>

<p>Note: Keen readers will notice the special name for configuring the new view

component, <span class="pre">browser:page</span>.  This XML tag actually employs an XML

namespace prefix which needs to be defined.  Normally this is added right

onto the <span class="pre">configure</span> tag like this:</p>

<pre class="literal-block">&lt;configure<br>    xmlns="http://namespaces.zope.org/zope"<br><strong>    xmlns:browser="http://namespaces.zope.org/browser"</strong><br>    xmlns:five="http://namespaces.zope.org/five"&gt;</pre>

</blockquote>

<p>And that's all! Here's how the form and result pages will look like:<strong><br></strong></p>

<p><strong>Contact form:</strong></p>

<p><img class="image-inline" src="developer-manual_archivos/firstform-filled.png" alt="First form"></p>

<p><strong>Result page</strong>:</p>

<img class="image-inline" src="developer-manual_archivos/firstresult.png" alt="First result"><p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                6.1.3.
                Adding validation
            </h1>

            <p class="documentDescription">Server-side form validation is vital to ensure data sanity and protect our site from malicious users.</p>
    
            <div>
                
                    <div><h3>Field validation<br></h3>

<p>Once you've understood the "hello form", let's move onto a more advanced topic: validation.</p>

<p>The easiest way to manage validation in a formlib-based form is to
specify the validation rules in our schema. Actually, you've already
implemented some validation: the customer, subject and message fields
are required. If you leave the <em>subject</em> field empty, for example, and click the <em>send</em> button, a pretty red error message will show up asking you to fill that field.</p>

<p>Let's add email validation to the <em>customer</em> field using the
constraint keyword argument fot that attribute in our schema. For
simplicity, the mail address checker that comes with the CMFDefault
utilities toolbox will be used in this example, althought you could
also use your own regular expression checking. The constraint argument
must be a callable that returns <code>True</code> if the value submitted is valid, or raise an exception inheriting from <code>zope.schema.ValidationError</code>, whose docstring will be used in the error message.</p>

<pre><strong>from zope.schema import ValidationError



class InvalidEmailAddress(ValidationError):

    "Invalid email address"



from Products.CMFDefault.utils import checkEmailAddress

from Products.CMFDefault.exceptions import EmailAddressInvalid



def validateaddress(value):

    try:

        checkEmailAddress(value)

    except EmailAddressInvalid:

        raise InvalidEmailAddress(value)

    return True</strong>

class IFeedbackForm(Interface):
    """
    A typical feedback schema
    """
    customer = TextLine(title=u'Customer',
                      description=u'Customer email',
                      required=True,
                      <strong>constraint=validateaddress</strong>)

    subject = TextLine(title=u'Subject',
                       required=True)

    message = Text(title=u'Message',
                   description=u'The message body',
                   required=True)</pre>

<p>Now, if you type an invalid address into the <em>customer</em> field and click <em>send</em>, a kind and colorful error message will be displayed:</p>

<p><img class="image-inline" src="developer-manual_archivos/validation_error_pretty.png" alt="Simple validation error"></p>

<p>That was too easy, wasn't it?&nbsp;</p>

<h3>Invariants validation<br></h3>

<p><em>zope.formlib</em> also supports the validation of schema
invariants, e.g. the min value entered must be smaller than the max
value. In this example the form will be extended to provide a set of
predefined subjects and a field named <em>other</em> which must be filled when selecting the the <em>Other</em> option in the subject select dropdown. It's easier to explain it in Python than in English:</p>

<pre><strong>from zope.schema import Choice

</strong><strong>from zope.interface import invariant, Invalid</strong>

class IFeedbackForm(Interface):
    """
    A typical feedback schema
    """
    customer = TextLine(title=u'Customer',
                      description=u'Customer email',
                      required=True,
                      constraint=validateaddress)

    subject = <strong>Choice</strong>(title=u'Subject',
<strong>                   vocabulary='Available Subjects',</strong>
                   required=True,
                   )

<strong>    other = TextLine(title=u'Other',

                     description=u"""

                        If you've specified Other above,

                        please fill this this field too.""",

                        required=False)</strong>

    message = Text(title=u'Message',
                   description=u'The message body',
                   required=True)

<strong>    @invariant

    def otherFilledIfSelected(feedback):

        if feedback.subject == u'Other' and not feedback.other:

            raise Invalid("Please specify the motivation of your request")</strong></pre>

<p>Here, the <em>subject</em> field type has been set to <em>Choice</em>, and the list of available values has been indicated to be obtained from the <em>Available Subjects</em> vocabulary, a named utility which will be defined shortly.</p>

<p>The form will call all the <em>invariant</em>-decorated functions of the schema upon validation and catch any raised <em>Invalid</em> exceptions.</p>

<p>You still need to define the <em>Available Subjects</em> vocabulary:</p>

<pre>from zope.schema.vocabulary import SimpleVocabulary

def availableSubjects(context):
    subjects = ('Comment',
                'Feature Request',
                'Technical Issue',
                'Complaint',
                'Other',
                )
    return SimpleVocabulary.fromValues(subjects)</pre>

<p>and register it as a named utility using ZCML in the <code>configure.zcml</code> file:</p>

<pre>&lt;configure ... &gt;
...
    &lt;utility
            component=".browser.availableSubjects"
            name="Available Subjects"
            provides="zope.schema.interfaces.IVocabularyFactory"
            /&gt;
&lt;/configure&gt;
</pre>

<p>Restart your Zope instance for the changes to take effect and test your new form. You'll see something similar to this:</p>

<p><img class="image-inline" src="developer-manual_archivos/invariant_error.png" alt="Invariant error"></p>

<p>Unfortunately, invariant errors descriptions are not shown in the default template.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                6.1.4.
                Customizing the template and the widgets
            </h1>

            <p class="documentDescription">Hack into the appearance of your form.</p>
    
            <div>
                
                    <div><h3>Customizing the template<em><br></em></h3>

<p><em>plone.app.form </em>provides a handy default template named <code>pageform.pt</code> which integrates well with the default Plone skin, but you might need to customize it or write your own one.</p>

<p>To do that, override the <code>template</code> attribute of the form class definition:</p>

<pre>class FeedbackForm(PageForm):
    """
    A typical feedback form
    """
    label = u'Contact Us'
    form_fields = form.Fields(IFeedbackForm)
<strong>    template = ViewPageTemplateFile('feedback_form.pt')</strong>
    result_template = ViewPageTemplateFile('feedback_result.pt')

    @form.action("send")
    def action_send(self, action, data):
        mhost = MHost()
        self.mFrom = data['customer']
        self.mTo = "feedback@mycompany.com"
        self.mSubject = data['subject']
        self.mBody = data['message']
        mhost.Send(self.mFrom, self.mTo, self.mSubject, self.mBody)
        return self.result_template()</pre>

<p>As already stated, all the view attributes will be available inside the page template, including:</p>

<ul><li><strong>label -</strong> A label to display at the top of the form.</li><li><strong>prefix -</strong> A string added to all widget and action names.</li><li><strong>form_fields -</strong> The list of form's fields.</li><li><strong>widgets

-</strong> A list of views for the former fields. The widgets are looked up as

multiadapters for each schema field and the request providing <code>IDisplayWidget</code> or <code>IInputWidget</code>.</li><li><strong>errors -</strong> A list of errors encountered during validation.</li><li><strong>error_views

-</strong> A list of views for the former errors. These views are looked up as

multiadapters for each error and the request providing <code>zope.app.form.browser.interfaces.IWidgetInputErrorView</code>.</li><li><strong>status -</strong> An update status message, normally generated by success or failure handlers.</li><li><strong>availableActions -</strong> The list of form's available actions.</li><li><strong>template -</strong> The template used to display the form.</li></ul><p>It's reccommended to start with the default <code>pageform.pt</code> and customize it cutting, pasting, deleting and entering text and tags.</p>

<p><strong>Using named templates</strong></p>

<p>Another really zope3-ish method to choose the form template is using the <em>zope.formlib</em>
named templates. Using named templates can be (and actually is) an
overkill if you've designed your template to work with your form class
as a single component. But if you write a form class and the template
is just a visual customization of that form, you might want to be able
to customize the template without having to reimplement the whole
class, or let others do so. This is exactly how Plone overrides the
default <em>zope.formlib</em> template with a more plone-ish one in the <em>plone.app.form</em> package.</p>

<p>Please note that this approach was not taken in the example product <em>example.formlib</em>.</p>

<p>Named templates are adapters for the form's view class to <code>INamedTemplate</code>,
bound to the form class only by their names. This way, a third party
product (e.g. a theme) can register a different template with the same
name (usually in a different browser skin layer) to override the
default one. Moreover, they're very easy to use. Modify and add the
emphasized lines:</p>

<pre><strong>from zope.formlib.namedtemplate import NamedTemplate

</strong># Five's ViewPageTemplateFile doesn't work correctly with formlib's NamedTemplateImplementation,
# so we use here the Plone implementation
<strong>from plone.app.form import named_template_adapter</strong>  

class FeedbackForm(PageForm):
    """
    A typical feedback form
    """
    label = u'Contact Us'
    form_fields = form.Fields(IFeedbackForm)
<strong>    template = NamedTemplate('feedback.form')</strong>
    result_template = ViewPageTemplateFile('feedback_result.pt')
    # rest of the form class implementation...

<strong>feedback_template = named_template_adapter(

    ViewPageTemplateFile('feedback_form.pt'))</strong>
</pre>

<p>In configure.zcml, add the following snippet to register the named template as an adapter for your form:</p>

<pre>    &lt;adapter
            factory=".browser.feedback_template"
            for=".browser.FeedbackForm"
            name="feedback.form"
            /&gt;</pre>

<p>Name your page template <code>feedback_form.pt</code> and you're done.</p>

<h3>Customizing the widgets</h3>

<p>As we've already stated earlier, form widgets are views for schema
fields, i.e. multiadapters for each schema field and the request
providing <em>IDisplayWidget</em> or <em>IInputWidget</em>, depending on if they display field data or offer editing funcionality to the user.</p>

<p>To do so, override the <code>custom_widget</code> attribute of a field (which defaults to None). Remember how we set up the form's fields:</p>

<pre>class FeedbackForm(PageForm):
    """
    A typical feedback form
    """
    label = u'Contact Us'
<strong>    form_fields = form.Fields(IFeedbackForm)

    </strong># rest of the form class...
</pre>

<p>The <code>form_fields</code> fields are accessible throught a dict-like interface, with the schema field names as keys, so we write:</p>

<pre><strong>from zope.app.form.browser import RadioWidget as _RadioWidget</strong>
<strong>

def RadioWidget(field, request):

    vocabulary = field.vocabulary

    widget = _RadioWidget(field, vocabulary, request)

    return widget </strong>

class FeedbackForm(PageForm):
    """
    A typical feedback form
    """
    label = u'Contact Us'
<strong>    </strong>form_fields = form.Fields(IFeedbackForm)<strong>

    form_fields['subject'].custom_widget = RadioWidget

    </strong># rest of the form class...</pre>

<p>Here, we're specifying a custom widget for the subject field: <code>RadioWidget</code>, which displays a radio box for every item from the field's vocabulary. The <em>zope.app.form.browser</em>
and plone.app.form.widgets packages provide a reasonable set of widgets
to use and customize, including dropdowns and Kupu/WYSIWYG.
Unfortunately, creating new widgets is out of the scope of this
tutorial for now.</p>

<p>The <code>RadioWidget</code> function deserves a little explanation. Believe it or not, <em>zope.formlib</em> doesn't handle custom widgets with vocabularies (called items widgets) properly, because it calls <code>form_field.custom_widget(field, request)</code>
either the field has an associated vocabulary or not, and item widgets
have to be initialized with a vocabulary argument too; so a wrapper
function is needed to workaround this issue.</p>

<p>Here's how the improved form looks like:</p>

<p><img class="image-inline" src="developer-manual_archivos/form_radiobuttons.png" alt="Form radio buttons"></p></div>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                6.2.
                Using CMFFormController
            </h1>

            <p class="documentDescription">How
to create and validate forms in Plone using its CMFFormController. Be
sure to also read the CMFFormController tutorial in the
Products/CMFFormController/documentation directory, included with your
copy of Plone. This how-to is also available in
Products/CMFFormController/www/ as the file docs.stx, included with
Plone.
</p>
    
            <div>
                
                    <div><p>The CMFFormController package helps developers by simplifying the

process of validating forms. It also makes it easier for site

administrators to override some of the behavior of packages without

modifying code, making it easier to upgrade packages without

disturbing the modifications.</p>
<p>How it works:</p>

<ul><li>Developers associate a set of default variables for their Page

  Templates.

  These variables control the validation that takes place after the

  form is submitted and the actions that occur after

  validation. The variables are stored on the filesystem in the

  .metadata properties file.</li>
<li>Site administrators can override the default validations and

  actions using the ZMI. Once a set of validations or actions has

  been specified in the ZMI, the default validations and actions

  will be ignored.</li>

</ul><h2>Forms</h2>
<p>   To take advantage of CMFFormController, you need to use

   Controller Page Templates rather than ordinary Page

   Templates. Controller Page Templates act just like ordinary Page

   Templates, but they do some extra work when they are viewed.</p>
<p>   Here is a basic form that uses CMFFormController:
</p><pre>     &lt;form tal:define="errors options/state/getErrors"
           tal:attributes="action string:${here/absolute_url}/${template/id};"
          method="post"&gt;
        &lt;input type="hidden" name="form.submitted" value="1" /&gt;
        &lt;p tal:define="err errors/foo|nothing" tal:condition="err" tal:content="err" /&gt;
        &lt;input type="text"
               name="foo"
               tal:define="val request/foo|nothing"
               tal:attributes="value val" /&gt;
        &lt;input type="submit" name="submit" value="submit" /&gt;
     &lt;/form&gt;
</pre>

<p>   Let's take a look.</p>

<ul><li>First, we note that the form is set up to submit to itself.

     <em>Forms must submit to themselves.</em></li>
<li>Second, we see the special hidden variable <code>form.submitted</code>.

     The controlled page template checks the REQUEST for

     form.submitted to see if the form has been submitted or if,

     instead, it has just been accessed, e.g. via a link.

     <em>Forms must contain the hidden variable <code>form.submitted</code></em></li>
<li>At the beginning of the form we set the variable errors.  The

     errors dictionary comes from the state object which is passed

     in the template options.  The state object lets validators and

     scripts pass information to each other and to forms.  For our

     purposes, the most important information is the errors

     dictionary, which has entries of the form <code>{field_name:error_message}</code>.</li>

</ul><p>   Before we can use this form we need to specify the validators

   that will be used to check the form values, and we need to

   specify the action that will occur after validation.</p>
<h2>Specifying Validators</h2>
<h3>      There are two basic ways to specify a form's validators.</h3>

<ol><li> You can specify the validators in the .metadata

            properties for filesystem-based Controller Page

            Templates.</li>
<li> You can specify the validators via the ZMI (or

            programmatically). These values will be stored in the

            ZODB as attributes of the <code>portal_form_controller</code> object.</li>

</ol><p>      If you specify validators in both places, the validators

      specified in the ZMI will take precedence over those

      specified in the .metadata file.</p>
<h3>   Specifying Validators on the Filesystem</h3>
<p>      You can specify validators on the filesystem using an objects

      .metadata properties file.</p>
<p>      To create a .metadata file, simply create a file with the

      same name as your page template, and then append .metadata to

      the end of the name of the file. For instance, you might have

      a Controller Page Template called

      <code>document_edit_form.cpt</code>. The properties for that file would

      be stored in a file called <code>document_edit_form.cpt.metadata</code></p>
<p>      The .metadata file uses the standard python ConfigParser

      syntax. The validator section of the .metadata file would

      look like:
</p><pre>        [validators]
        validators = validate_script1, validate_script2
</pre>

<p>      The validation scripts <code>validate_script1</code> and

      <code>validate_script2</code> will be called in order.</p>
<h4>      Type-Specific Validators</h4>
<p>         Suppose you want different validators to be called,

         depending on the type of context the form has.</p>
<p>      You can do so as follows:
</p><pre>         [validators]
         validators = validate_script1
         validators.Document = validate_script2
</pre>

<p>      In the above example, if the context is a Document object,

      <code>validate_script2</code> will be called for validation; for

      everything else, only <code>validate_script1</code> will be called.</p>
<p>      Note that the order in which the variables are specified does

      not matter; the type-specific validators override

      non-specific validators if both are applicable.</p>
<h4>      Button-Specific Validators</h4>
<p>         Suppose instead that you have two different buttons on

         your form, and you want different validation sequences to

         occur depending on which button is pressed.  You can

         accomplish this as follows:</p>
<p>      First, name your buttons button1 and button2:
</p><pre>            &lt;input type="submit"
                   name="form.button.button1"
                   value="First Button" /&gt;
            &lt;input type="submit"
                   name="form.button.button2"
                   value="Second Button" /&gt;
</pre>

<p>      Next, specify validators in the .metadata file for button1

      and for button2:
</p><pre>            [validators]
            validators..button1 = validate_script1, validate_script3
            validators..button2 = validate_script2, validate_script4
</pre>

<p>      Note the presence of the <code>..</code>.  This is a placeholder for a

      type specifier.  You could further specify that

      <code>validate_script5</code> is called if <code>button2</code> is pressed and the

      context is a Document by adding:
</p><pre>            [validators]
            validators.Document.button2 = validate_script5
</pre>

<p>      Remember that button specific validators take precedence over

      non-specific validators.</p>
<h4>   Specifying Validators in the ZMI</h4>
<p>         If you look at a Controller Page Template in the ZMI, you

         will see that it looks just like an ordinary Page Template

         with two extra tabs, Validation and Actions. Click on the

         Validation tab.</p>
<p>         The Validation tab shows all the validators for the page

         template in question. You can specify validators with the

         same kind of specialization options as above via a web

         form.</p>
<p>         The validator information for all forms is stored in the

         <code>portal_form_controller</code> tool in your portal. This means

         that you can specify validators for filesystem objects

         with no problems, since the information is persisted in

         the ZODB. Note that the validator information is bound to

         the form's Id, so all forms with the same Id use the same

         validators. This keeps things simple when you have

         multiple skins:</p>
<p>         <em>Forms with the same Id use the same validators, no matter

         what skin they are in.</em></p>
<p>         When a form is submitted, it first checks to see if there

         are any applicable validators that have been specified via

         the ZMI.  If it finds one, it uses it. If it does not find

         a validator via the ZMI, it then checks the REQUEST object

         to see if validators have been specified in hidden

         variables.  As a result, validators specified in the ZMI

         take precedence over those specified in forms.</p>
<h5>      Specifying Validators Programmatically</h5>
<p>         The portal's <code>portal_form_controller</code> tool has methods you

         can use to specify the validators for a given

         ControllerPageTemplate. The API is as follows:
</p><pre>           portal_form_controller.addFormValidators(id,
                                                    context_type,
                                                    button,
                                                    validators)
</pre>

<p>         Here <code>id</code> is the Id of the ControllerPageTemplate,

         <code>context_type</code> is the class name for the class of the

         context object, <code>button</code> is the name of the button

         pressed, and validators is a comma-delimited string or a

         list of strings. If you want a validator to act for any

         class, set context_type to None.

         Similarly, you want a validator to act for any button, set

         button to None.</p>
<h2>Specifying Actions</h2>
<p>      The sequence of validators that is executed returns a status

      in the state object.

      The default status is <code>success</code>, i.e. if no validators are

      executed, the status will be <code>success</code>. If a validator

      encounters an error, it will typically set the status to

      <code>failure</code>.  The next thing we need to do in your form is to

      specify what happens when a given status is returned.</p>
<p>      As with validators, there are two basic ways to specify a

      form's actions.
</p><ol><li> You can specify the actions in the .metadata properties

            for filesystem-based Controller Page Templates and

            Controller Python Scripts.</li>
<li> You can specify the actions via the ZMI (or

            programmatically). These values will be stored in the

            ZODB as attributes of the <code>portal_form_controller</code> object.</li>

</ol><p>      If you specify actions in both places, the actions specified

      in the ZMI will take precedence over those specified in the

      form.</p>
<h3>      Specifying Actions on the Filesystem</h3>
<p>         You can specify actions on the filesystem using an objects

         .metadata properties file.</p>
<p>      Actions are stored in the same .metadata file as the

      validators. The syntax for the actions section of your file

      would look like:
</p><pre>        [actions]
        action.success = traverse_to:string:script1
</pre>

<p>      In the above example, when the form is submitted and the

      validation scripts return a status of <code>success</code>, the

      <code>traverse_to</code> action is called with the argument

      <code>string:script1</code>, i.e. if the form data is valid, we run the

      script <code>script1</code>.  Alternatively, we could specify

      <code>action.success = redirect_to:string:http://my_url_here</code>,

      which would cause the browser to be redirected to

      <code>http://my_url_here</code>.</p><p>       The default action for the <code>failure</code> status is to reload the

       current form. The form will have access to all the error

       messages, via the state object in its options.</p><h3>         Type-Specific Actions</h3>
<p>            Suppose you want different actions to occur depending

            on the type of context the form has.</p>
<p>         You can do so as follows:
</p><pre>               [actions]
               action.success = traverse_to:string:script1
               action.success.Document = traverse_to:string:document_script
</pre>

<p>         In the above example, if the context is a Document object,

         document_script will be executed upon successful

         validation; for everything else, script1 will be executed.

         Note that the order in which the variables are specified

         does not matter; the type-specific actions will override

         non-specific actions if both are applicable.</p>
<h3>         Button-Specific Actions</h3>
<p>            Suppose instead that you have two different buttons on

            your form, and you want different actions to occur

            depending on which button is pressed.  You can

            accomplish this as follows:</p>
<p>         First, name your buttons button1 and button2:
</p><pre>            &lt;input type="submit"
                   name="form.button.button1"
                   value="First Button" /&gt;
            &lt;input type="submit"
                   name="form.button.button2"
                   value="Second Button" /&gt;
</pre>

<p>         Next, specify actionss for button1 and for button2:
</p><pre>            [actions]
            action.success..button1 = traverse_to:string:script1
            action.success..button2 = traverse_to:string:script2
</pre>

<p>         Note the presence of the <code>..</code>.  This is a placeholder for

         a type specifier.  You could further specify that

         <code>document_script2</code> is called if button2 is pressed and the

         context is a Document by adding:
</p><pre>            [actions]
            action.success.Documnet.button2 = traverse_to:string:document_script2
</pre>



<h3>      Specifying Actions in the ZMI</h3>
<p>         If you look at a Controller Page Template in the ZMI, you

         will see that it looks just like an ordinary Page Template

         with two extra tabs, Validation and Actions. Click on the

         Actions tab.</p>
<p>         The Actions tab shows all the actions for the page

         template in question. You can specify actions with the

         same kind of specialization options as above via a web

         form.</p>
<p>         The action information for all forms is stored in the

         <code>portal_form_controller</code> tool in your portal.  This means

         that you can specify actions for filesystem objects with

         no problems, since the information is persisted in the

         ZODB. Note that the action information is bound to the

         form's Id, so all forms with the same Id use the same

         actions. This keeps things simple when you have multiple

         skins: forms with the same Id use the same actions, no

         matter what skin they are in.</p>
<p>         When a form is submitted, it first checks to see if there

         are any applicable actions that have been specified via

         the ZMI. If it finds one, it uses it. If it does not find

         an action via the ZMI, it then checks the REQUEST object

         to see if actions have been specified in hidden

         variables. As a result, actions specified in the ZMI take

         precedence over those specified in forms.</p>
<h3>      Specifying Actions Programmatically</h3>
<p>         The portal's <code>portal_form_controller</code> tool has methods you

         can use to specify the actions for a given

         ControllerPageTemplate. The API is as follows:
</p><pre>            portal_form_controller.addFormAction(id,
                                                 status,
                                                 context_type,
                                                 button,
                                                 action_type,
                                                 args)
</pre>

<p>         Here <code>id</code> is the Id of the ControllerPageTemplate,

         <code>status</code> is the status for which the action will be

         executed, <code>context_type</code> is the class name for the class

         of the context object, <code>button</code> is the name of the button

         pressed, <code>action_type</code> is the type of action that will

         occur, and <code>args</code> is a string (typically a TALES

         expression) that will be passed to the action. If you want

         an action to be executed for any class, set context_type

         to None. Similarly, you want an action to be executed for

         any button, set button to None.</p>
<h2>Validation Scripts</h2>
<p>   When writing validation scripts, use Controller Validators

   instead of Python Scripts. Controller Validators are just like

   ordinary Scripts with the addition of a ZMI Actions tab.  On the

   file system, Controller Validators use the extension .vpy rather

   than .py.</p>
<p>   Let's take a look at a basic validation script that tests the

   REQUEST value <code>n</code> to see if it is an integer:
</p><pre>      n = context.REQUEST.get('n', None)
      if not n:
         state.setError('n', 'Please enter a value', new_status='failure')
      else:
         try:
            int(n)
         except ValueError:
            state.setError('n', 'Please enter an integer',
                           new_status='failure')

      if state.getErrors():
         state.set(portal_status_message='Please correct the errors shown.')
      return state
</pre>

<p>   The first thing to note is that Controller Validators have a

   built-in state object called <code>state</code>.  This state object (of

   class ControllerState) contains basic information about what has

   happened during the validation chain.</p>
<p>   The state object has a <code>status</code> attribute which contains the

   current validation status. The initial status is <code>success</code>. If

   errors are detected by validators, they set the status to

   something else, typically <code>failure</code>.</p>
<p>   The state object also stores errors that have been detected. The

   <code>setError</code> method is used to set an error message for a

   particular variable. The setError method has the optional

   <code>new_status</code> argument that can be used to both set an error

   message as well as to update the status. You can see if an error

   message has already been stored for a particular variable by

   calling <code>state.getError(variable_name)</code>.</p>
<p>   The set method lets you set multiple attributes of the state

   object all at once, e.g.:
</p><pre>      state.set(status='my_new_status')
</pre>

<p>   You can also pass keyword arguments to the state object via the

   set method. These arguments will get passed along by the

   action. The <code>traverse_to</code> action places these keyword arguments

   in the REQUEST. The <code>redirect_to</code> action adds them to the query

   string of the URL to which it is redirecting.</p>
<p>   Finally, we return the state object.</p>
<p>Another interesting example is email validation:
</p><pre>    from Products.CMFDefault.utils import checkEmailAddress
    from Products.CMFDefault.exceptions import EmailAddressInvalid

    email = context.REQUEST.get('email', None)
    if not email:
        state.setError('email', 'No e-mail address')
    else:
    # Do try-catch here because checkEmailAddress will throw an exception
    # instead of saying "no, not valid".
    try:
        checkEmailAddress(email)
        email_ok = True
    except EmailAddressInvalid:
        email_ok = False
    if not email_ok:
        state.setError('email', 'Invalid e-mail address.') 
</pre>

<h2>Scripts</h2>
<p>   When writing scripts that do some processing after a validated

   form, you can use Controller Python Scripts instead of ordinary

   Python Scripts to let site managers override their actions via

   the ZMI.  On the file system, Controller Python Scripts use the

   extension .cpy rather than .py.  Note that Controller Validators

   and Controller Python Scripts differ in signficant ways.  Be

   sure to use the appropriate script type (Controller Validator or

   Controller Python Script) and/or the appropriate file extension

   (.cpy or .vpy).</p>
<p>Let's take a look at a basic script that sets a context attribute

to the value <code>n</code> that is passed in via the 'REQUEST':
</p><pre>   context.n = context.REQUEST.get('n')

   # Optionally set the default next action (this can be overridden
   # in the ZMI)

   state.setNextAction('redirect_to:string:view')

   # Optionally pass a message to display to the user
   state.setKwargs({'portal_status_message':'You set context.n to %s.' % str(context.n)})
   return state
</pre>

<p>Note that you will usually want to use the <code>traverse_to</code> action to

call your script. This will ensure that form variables set in the

REQUEST object are available to your script.</p>
<p>This script sets its action to redirect to the relative url <code>view</code>

for the current context object. The status has not been set, so it

is the default status, <code>success</code>.</p>
<p>The <code>state.setNextAction</code> directive above is analogous to having

the following line in your .metadata file:
</p><pre>     [actions]
     action.success = redirect_to:string:view
</pre>

<p>As with the .metadata file, the default action specified in the

script can be overridden via the ZMI.  This allows site managers to

override post-script actions without having to customize your code.</p>
<p>Finally, we return the state object.</p>
<h2>Validation for Scripts</h2>
<p>   Having separate validation scripts typically means that

   validation is moved out of scripts.  This simplifies scripts,

   but means that it is possible to call them directly with invalid

   data.  We can prevent this problem by adding validators to

   scripts.  Controller Python Scripts use the same ZMI and/or

   .metadata file mechanisms for adding validators as do Controller

   Page Templates.</p>
<p>   Each time a validator is called, it logs the call in the state

   object. Validation is smart enough that if a validator is called

   by a form, it will not be called again by the script.</p>
<p>   Note that if you associate validators with a script, you will

   need to set a sensible <code>failure</code> status action, since scripts do

   not set such an action by default.  You may wish to define a

   different failure status for failures that occur within your

   script, e.g. <code>script_failure</code>.  Then you can specify a behavior

   for failures that occur as a result of invalid parameters coming

   in and for failures that occur within the script.
</p></div>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-1">

            <h1>
                7.
                Testing
            </h1>

            <p class="documentDescription">This
tutorial will explain how to write safer, better code that makes you
look more professional. That's right - it's time to write tests, for
everything you do. Don't worry, it's not boring or complicated, you
just need to learn how.</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-2">

            <h1>
                7.1.
                Introduction
            </h1>

            <p class="documentDescription">What is this thing called testing anyway?</p>
    
            <div>
                
                    <div><p>"I know I should write tests, but ...</p>

<ul><li>... they take time to write </li><li>... Iâm a good developer </li><li>... my customer / the community does the testing"</li></ul><p>Sound
familiar? No matter how good you think you are, you will make mistakes.
Your code will contain bugs and someone will come after you demanding
an explanation. Without some methodical way of testing, you are
guaranteeing your code with nothing more than guesswork and arrogance.
Clicking around the Plone interface for a few minutes before you ship
your code off to the customer or user is simply not enough.</p>

<p>Testing is an art, it needs to be built into your development cycle
from the very beginning - it is not something you do only after all the
other work is finished, it is something you do continuously.
Unfortunately, testing often evokes emotions of dread in developers.
It's slow, it's boring, it's not what they signed up to do. But the art
of testing has evolved beyond that - there is considerable elegance and
fun to be found in well-conceived test strategies.</p>

<p>This tutorial aims to give you the tools you need to write tests and
testable software in Plone. If you are writing software for Plone core
itself, don't even think about commiting any bug fix or feature without
test coverage. If you are writing an add-on product or doing a
customisation, holding yourself to the same high standards that the
Plone core team do will give you better confidence in your software and
will likely save you considerable pain down the road.</p>

<h2>Examples<br></h2>

<p>

This tutorial contains several examples of the various types of tests. They are available in the <a href="http://dev.plone.org/collective/browser/examples/example.tests/trunk">example.tests</a>
package, which you can install as a develop egg in a Plone 3 buildout.
The examples of running tests use the standard commands for buildouts,
since this is the only way that works reliably on Windows (that is,
plain <span class="visualHighlight">zopectl test</span> will not work on Windows).</p>

<p>Take a look at the <a title="Managing projects with zc.buildout" href="http://plone.org/documentation/manual/developer-manual/buildout">buildout tutorial</a> for more information.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                7.2.
                A brief example
            </h1>

            <p class="documentDescription">Just so that you know what we're talking about</p>
    
            <div>
                
                    <div><p>Try to find the bug in the following piece of code:</p>

<pre>class Employee(object): 
&nbsp;&nbsp;&nbsp; def __init__(self, name, position, employee_no=None): 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.name = name 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.position = position 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.employee_no = employee_no 

salaries = {0: 12000, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1: 4000, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2: 8000, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3: 4000}

def print_salary(employee): 
&nbsp;&nbsp;&nbsp; if employee.employee_no: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; salary = salaries.get(employee.employee_no, 0) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print "You make EUR %s." % salary 
&nbsp;&nbsp;&nbsp; else: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print "You're not an employee currently."
</pre>

<p>Found it yet? Did you have to spend more than a few seconds thinking
about it? Any developer could have written that code and not seen the
problem. Furthermore, the bug is an edge case that you may not have
tested using manual/through-the-web testing.</p>

<p>Let us write a test (actually, a doc/unit test) for this code. Don't
worry too much about how this is set up and executed just yet.</p>

<pre>Employee w/o an employee number is ignored: 

&nbsp; &gt;&gt;&gt; print_salary(Employee('Adam', 'Developer')) 
&nbsp; You're not an employee currently 

Employee w/o a known employee number earns nothing: 

&nbsp; &gt;&gt;&gt; print_salary(Employee('Berta', 'Designer', 100)) 
&nbsp; You make EUR 0. 

Employee w/ a valid employee number is found properly: 

&nbsp; &gt;&gt;&gt; print_salary(Employee('Chris', 'CTO', 2)) 
&nbsp; You make EUR 8000.
&nbsp;
Zero is a valid employee number: 

&nbsp; &gt;&gt;&gt; print_salary(Employee('Devon', 'CEO', 0)) 
&nbsp; You make EUR 12000
</pre>

<p>As it happens, the last test would fail. It would print <span class="visualHighlight">You are not an employee currently.</span>, unless we fixed the code:</p>

<pre>class Employee(object): 
&nbsp;&nbsp;&nbsp; def __init__(self, name, position, employee_no=None): 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.name = name 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.position = position 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.employee_no = employee_no 

salaries = {0: 12000, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1: 4000, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2: 8000, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3: 4000} 

def print_salary(employee): 
&nbsp;&nbsp;&nbsp; if employee.employee_no is not None: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; salary = salaries.get(employee.employee_no, 0) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print "You make EUR %s." % salary 
&nbsp;&nbsp;&nbsp; else: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print "You're not an employee currently."
</pre>

<p>The moral of the story?</p>

<ul><li>you rarely catch problems like these with manual testing </li><li>put the time you waste catching silly bugs and typos into writing tests </li><li>with decent test coverage, you end up saving lots of time when you refactor</li></ul></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                7.3.
                Types of tests
            </h1>

            <p class="documentDescription">Some terminology you should be familiar with</p>
    
            <div>
                
                    <div><p>Broadly speaking, there are four main types of tests:</p>

<dl><dt>Unit tests </dt><dd>These are written from the programmer's perspective. A unit test should

test a single method or function in isolation, to ensure that it

behaves correctly. For example, testing that a given calculation is

performed correctly given a variety of input is a good unit test for

that one method. </dd><dt>Integration tests</dt><dd>Whereas unit tests try to remove or abstract away as many dependencies

as possible to ensure that they are truly only concerned with the

method under test, integration tests exercise the integration points

between a method or component and the other components it relies on.

For example, testing that a method performs some calculation and then

correctly stores the result in the ZODB is an integration test in that

it tests the integration between that component and the ZODB. </dd><dt>Functional tests </dt><dd>A
functional test is typically demonstrating a use case, exercising a
"vertical" of functionality. For example, testing that filling in a
form and clicking "Save" then makes the resulting object available for
future use, is a functional test for the use case of using that form to
create content objects.&nbsp;</dd><dt></dt><dt>System tests</dt><dd>These are written from the user's perspective, and treat the system as

a black box. A system test may be simulating a user interacting with

the system according to expected usage patterns. By their nature, they

are typically less systematic than the other types of tests.&nbsp;</dd></dl><p>Furthermore, functional tests may be <strong>white box</strong>,
in which case they can make assertions about things like the underlying
data storage (but only if this is specified clearly; implementation
details should never affect functional tests). Such tests are also
called <strong>functional integration tests</strong> (you can see where the lines start to blur, but don't worry too much about the naming). Alternatively, functional tests can be <strong>black box</strong>
in which case they only perceive the system from the point of view of
an actor (usually the end user) and make assertions only on what is
presented in the (user) interface to that actor. Such tests, also known
as <strong>acceptance tests</strong> would not make assumptions about the underlying architecture at all.</p>

<h2>Tests and documentation</h2>

<p>In a post to the Zope 3 mailing list, Jim Fulton explains the
importance of tests and documentation, and how they go hand-in-hand:</p>

<blockquote>&nbsp;&nbsp; One of the important things about this is that most doctests<br>&nbsp;&nbsp; should be written as documentation.&nbsp; When you write new software<br>&nbsp;&nbsp; components and you need to write tests for the main functionality<br>&nbsp;&nbsp; of your software you need to:<br><br>&nbsp;&nbsp; - Get your head into the mode of writing documentation.<br>&nbsp;&nbsp;&nbsp;&nbsp; This is very very very important.<br><br>&nbsp;&nbsp; - You need to document how to use the software.&nbsp; Include examples,<br>&nbsp;&nbsp;&nbsp;&nbsp; which are tests<br></blockquote>

<p>We will learn more about doctests, and how they are used for unit
testing and functional testing later. The important thing to note is
that good tests often serve as documentation describing how your
component is supposed to be used. Thinking about the story they tell is
just as important as thinking about the number of input and output
states they cover.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                7.4.
                Telling stories with doctests
            </h1>

            <p class="documentDescription">Doctests bring code and test closer together, and makes it easier to describe what a test does, and why.</p>
    
            <div>
                
                    <div><p>By
their nature, tests should exercise an API and demonstrate how it is
used. Thus, for other developers trying to understand how a module or
library should be used, tests can be the best form of documentation.
Python supports the notion of <strong>doctests</strong>, otherwise known as <strong>executable documentation</strong>.</p>

<p>Doctests look like Python interpreter sessions. They contain plain
text (normally in reStructedText, which can be rendered to HTML or PDF
easily) as well as <strong>examples</strong>. The idea is to show
something that could have been typed in an interpreter session and what
the expected outcome should be. In the Zope 3 world, doctests are
extremely prevalent and are used for most unit and integration testing.</p>

<p>Doctests come in two main flavours: You can write a simple text file, such as a <span class="visualHighlight">README.txt</span>,

that explains your code along with verifiable examples, or you can add

doctests for a given method or class into the docstring of that method

or class.</p>

<p>The full-file approach - sometimes known as <strong>documentation-driven development</strong>
- is the most common. This type of test is very well suited for
explaining how an API should be used and ensuring that it works as
expected at the same time. However, note that these are
not technically proper unit tests, because there is no guarantee of
isolation between the steps of the "script" that the doctest describes.
The docstring version uses the same basic syntax, but each docstring is
executed as its own test fixture, guaranteeing full isolation between
tests.</p>

<p>Here is a trivial example of a doctest. We will learn how to set up such a test shortly.</p>

<pre>Interfaces are defined using Python class statements:: 

  &gt;&gt;&gt; import zope.interface 
  &gt;&gt;&gt; class IFoo(zope.interface.Interface): 
  ...    """Foo blah blah""" 
  ... 
  ...    x = zope.interface.Attribute("""X blah blah""") 
  ... 
  ...    def bar(q, r=None): 
  ...        """bar blah blah""" 

In the example above, we've created an interface:: 

  &gt;&gt;&gt; type(IFoo) 
  &lt;class 'zope.interface.interface.InterfaceClass'&gt; 

We can ask for the interface's documentation:: 

  &gt;&gt;&gt; IFoo.__doc__ 
  'Foo blah blah'

We could create an arbitrary object - this will of course not provide 
the interface.

  &gt;&gt;&gt; o = object()
  &gt;&gt;&gt; o # doctest: +ELLIPSIS
  &lt;object at ....&gt;
  &gt;&gt;&gt; IFoo.providedBy(o)
  False
  &gt;&gt;&gt; o.bar() # doctest: +ELLIPSIS
  Traceback (most recent call last):
  ...
  AttributeError: 'object' object has no attribute 'bar'

</pre>

<p>Each time the doctest runner encounters a line starting with <span class="visualHighlight">&gt;&gt;&gt;</span>, the prompt of the Python interpreter (i.e. what you get by running <span class="visualHighlight">python</span>
without any arguments in a terminal), it will execute that line of
code. If that statement is then immediately followed by a line with the
same level of indentation as the <span class="visualHighlight">&gt;&gt;&gt;</span> that is not a blank line and does not start with <span class="visualHighlight">&gt;&gt;&gt;,</span>
this is taken to be the expected output of the statement. The test
runner will compare the output it got by executing the Python statement
with the output specified in the doctest, and flag up an error if they
don't match.</p>

<p>Note that <em>not</em> writing an output value is equivalent to stating that the method has no output. Thus, this is a failure:</p>

<pre>    &gt;&gt;&gt; foo = 'hello'
    &gt;&gt;&gt; foo
    &gt;&gt;&gt; # do something else
</pre>

<p>The reference to <span class="visualHighlight">foo</span> on its own will print the value of foo. The correct DocTest would read:</p>

<pre>    &gt;&gt;&gt; foo = 'hello'
    &gt;&gt;&gt; foo
    'hello'
    &gt;&gt;&gt; # do something else
</pre>

<p>Notice also the ... (ellipsis) element in the expected otuput. These mean "any number of characters" (anologus to a <span class="visualHighlight">.*</span>
statement in a regular expression, if you are familiar with those).
They are usually convenient shorthand, but they can sometimes be
necessary. For example:</p>

<pre>  &gt;&gt;&gt; class Foo:
  ...     pass
  &gt;&gt;&gt; Foo()
  &lt;__main__.Foo instance at ...&gt;
</pre>

<p>Here, the <span class="visualHighlight">...</span> in the expected output replaces a hexadecimal memory address (<span class="visualHighlight">0x0x4523a0</span>
on the author's computer at the time of writing), which cannot be
predicted in advance. When writing doctests in particular (but also
when writing regular unit tests), you need to be careful about values
you cannot predict, such as auto-generated ids based on the current
time or a random number. The ellipsis operator can help you work around
those.</p>

<p>Do not confuse the ellipsis operator in the expected output with the syntax of using <span class="visualHighlight">...</span> underneath a <span class="visualHighlight">&gt;&gt;&gt;</span>
line. This is the standard Python interpreter syntax used to designate
statments that run over multiple lines, normally as the result of
indentation. You can, for example, write:</p>

<pre>  &gt;&gt;&gt; if a == b:
  ...     foo = bar
</pre>

<p>&nbsp;if that is necessary in your test.</p>

<h2>Doctest tips and tricks</h2>

<p>As with all testing, you will get better at doctests over time. Below are a few tips that may help you get started.</p>

<dl><dt>Read the documentation</dt>

<dd>doctests have been in Python for a long time. The <a href="http://docs.python.org/lib/module-doctest.html">doctest module</a> comes with more documentation on how they work.</dd>

<dt>A test is just a bunch of python statements!</dt>

<dd>Never forget this. You can, for example, reference helper methods
in your own product, for example, imagine you have a method in <span class="visualHighlight">Products.MyProduct.tests.utils</span> that has a method <span class="visualHighlight">setUpSite()</span> to pre-populate your site with a few directories and users. Your doctest could contain:

<pre>  &gt;&gt;&gt; from Products.MyProduct.tests.utils import setUpSite
  &gt;&gt;&gt; setUpSite()
</pre>

</dd>

<dt>The test suite can perform additional initialisation</dt>

<dd>A test suite can have <span class="visualHighlight">setUp()</span> and/or <span class="visualHighlight">tearDown()</span> handlers that perform additional set-up or clean-up. We will see further examples of this later.&nbsp; </dd>

<dt>PDB is still your friend</dt>

<dd>You can put the standard <span class="visualHighlight">import pdb; pdb.set_trace()</span>
on a line in doctest. Unfortunately, you can't step through a doctest
line by line, but you can print variables and examine the state of the
test fixture.</dd>

<dt>You can catch exceptions</dt>

<dd>If you need to debug a doctest that is throwing an exception, this statement is often useful:

<pre>  &gt;&gt;&gt; try:
  ...     someOperation()
  ... except:
  ...     import pdb; pdb.set_trace()
  &gt;&gt;&gt; # continue as normal
</pre>

</dd></dl></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                7.5.
                Running tests
            </h1>

            <p class="documentDescription">It is not much good writing a test or relying on someone else's tests if you don't know how to run them.</p>
    
            <div>
                
                    <div><p>The easiest way to run tests in Zope is to use <span class="visualHighlight">zopectl</span> or the equivalent control script.

</p><pre>  ./bin/zopectl test -s Products.RichDocument
</pre>

<p>This would run all tests in the <span class="visualHighlight">Products.RichDocument</span> module. If you are using a <a title="Managing projects with zc.buildout" href="http://plone.org/documentation/manual/developer-manual/buildout">buildout</a> with an instance control script called <span class="visualHighlight">instance</span>, this would be:</p>

<pre>  ./bin/instance test -s Products.RichDocument</pre>

<p>Using buildout is probably a good idea - see <a title="Managing projects with zc.buildout" href="http://plone.org/documentation/manual/developer-manual/buildout">the buildout tutorial</a> - not at least because this is the only way that works reliably on Windows. We will use this syntax from now on.</p>

<p>To execute a single test or a set of tests matched by regular expression, you can use:</p>

<pre>  ./bin/instance test -s Products.RichDocument -t setup
</pre>

<p>This would run tests in files like <span class="visualHighlight">test_setup.py</span>. To run all doctests in <span class="visualHighlight">README.txt</span> (presuming there was a test suite for this file) you would write:</p>

<pre>  ./bin/instance test -s Products.RichDocument -t README.txt</pre>

<p>The new test runner also includes a few debugging options. For example:</p>

<pre>  ./bin/instance test -m Products.RichDocument -D
</pre>

<p>This will stop execution at the first failing test and drop into a PDB post-mortem.</p>

<p>To see the other options that are available, run:</p>

<pre>  ./bin/instance test --help
</pre>

<p>When the tests you think are relevant all pass, it's time to run all
tests and make sure nothing else broke. (No, we don't care that you are
writing your code in a totally different python module than what those
other tests are supposed to test, and that they were all fine and good
and all you changed was a docstring. Run the tests when you think
you're done.)</p>

<p>When tests finish running, you will see a report like:</p>

<pre>    ...
    Ran 18 tests in 6.463s

    OK
</pre>

<p>(it may look slightly different, depending on which test runner you are using)</p>

<p>Rehearse a satisfied sigh as you read the line "OK", as opposed to
seeing a count of failed tests. With time, this will be the little
notifier that lets you go to bed, see your friends again or generally
get back to real life with an <span class="visualHighlight">svn commit</span>.</p>

<p>If you're not so lucky, you may see:</p>

<pre>    Ran 18 tests in 7.009s

    FAILED (failures=1, errors=1)
</pre>

<p>(again, the output may look slightly different depending on your test runner, but the same information should always be there)</p>

<p>This means that there were 1 python error and 1 failed test during test execution.</p>

<p>A python error means that some of your test code, or some code that
was called by a test, raised an exception. This is bad, and you should
fix it right away.</p>

<p>A failed test means that your test was trying to assert something
that turned out not to be true. This could be OK. It could mean you
haven't written the code the test is testing yet (well done, you wrote
the test first!), or that you don't yet know why it's failing.
Sometimes you may be radically refactoring or rewriting parts of your
code, and the tests will keep on failing until you're done.
Incidentally, this is part of the reason why unit tests are so good -
you can do that kind of stuff.</p>

<p>It's sometimes (not always - don't try this on Plone core unless
you've been told it's OK by the release manager) acceptable to go to
bed and check in a failing test if you are not in a position to know
how to fix it. At least other developers will be aware of the problem
and may be able to fix it.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                7.6.
                Writing unit tests
            </h1>

            <p class="documentDescription">Now
that you understand the principle of tests and how to run them, it's
time to write some. We will start with simple unit tests using doctest
syntax.</p>
    
            <div>
                
                    <div><p>We
will start by showing how to create a simple unit test with doctest
syntax. There is nothing Zope- or Plone-specific about this test. This
type of test is ideal for methods and classes that perform some kind of
well-defined operation on primitives or simple objects. The doctest
syntax is well-suited for explaining the inputs and outputs. Since the
tests are relatively few and/or descriptive, keeping the tests,
documentation and code close together makes sense.</p>

<p>Tests are usually found in a <span class="visualHighlight">tests/</span> sub-package. In the <span class="visualHighlight">example.tests</span> package, we have created a file called <span class="visualHighlight">tests/test_simple_doctest.py</span>. This sets up a test suite to run doctests in the doc strings in the module <span class="visualHighlight">example.tests.context</span>. Let's look at the test setup first:</p>

<pre>"""This is the setup for a doctest where the actual test examples are held in 
docstrings in a module.

Here, we are not using anything Zope-specific at all. We could of course 
use the Zope 3 Component Architecture in the setup if we wanted. For that,
take a look at test_zope3_doctest.py.

However, we *do* use the zope.testing package, which provides improved
version of Python's standard DocTestSuite, DocFileSuite and so on. If you
don't want this dependency, just use doctest.DocTestSuite.
"""

import unittest
import zope.testing

import example.tests.context

def setUp(test):
    """We can use this to set up anything that needs to be available for
    each test. It is run before each test, i.e. for each docstring that
    contains doctests.
    
    Look at the Python unittest and doctest module documentation to learn 
    more about how to prepare state and pass it into various tests.
    """
    
def tearDown(test):
    """This is the companion to setUp - it can be used to clean up the 
    test environment after each test.
    """
    
def test_suite():
    return unittest.TestSuite((
    
        # Here, we tell the test runner to execute the tests in the given
        # module. The setUp and tearDown methods can be used to perform
        # test-specific setup and tear-down.
    
        zope.testing.doctest.DocTestSuite(example.tests.context,
                     setUp=setUp,          # setUp and tearDown are optional!
                     tearDown=tearDown),
        ))
</pre>

<p>There are a lot of comments here, and we show how to use <span class="visualHighlight">setUp()</span> and <span class="visualHighlight">tearDown()</span> methods for additional initialisation and clean-up, if necessary. The test runner will call the <span class="visualHighlight">test_suite()</span> method and expect a <span class="visualHighlight">TestSuite</span> object back. If desired, we could have put multiple test suites referring to multiple modules into the <span class="visualHighlight">TestSuite</span> that is being returned.</p>

<p>Here is the actual code under test, in <span class="visualHighlight">context.py</span>:</p>

<pre>from zope.interface import implements
from example.tests.interfaces import IContext

class Context(object):
    """An object used for testing. We will register an adapter from this
    interface to IUpperCaser in the test setup.
    
    Here's how you use it. First, import the class.
    
        &gt;&gt;&gt; from example.tests.context import Context
        
    Then in-stan-ti-ate it (with me so far?):
    
        &gt;&gt;&gt; my_context = Context()

    Okay, here's the tricky bit ... now we need to set the title:
    
        &gt;&gt;&gt; my_context.title = u"Some string!"
        
    Phew ... did that work?
    
        &gt;&gt;&gt; my_context.title
        u'Some string!'
        
    Yeah!
    """
    
    implements(IContext)
    
    def __init__(self, title=u""):
        self.title = title
</pre>

<p>Here is how we may run the tests from a buildout:</p>

<pre>./bin/instance test -s example.tests -t context
Running unit tests:
  Running:
....
  Ran 4 tests with 0 failures and 0 errors in 0.071 seconds.
</pre></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                7.7.
                Testing a Zope 3 component with a separate doctest file
            </h1>

            <p class="documentDescription">Sometimes, we may need to perform additional set-up for our tests to run properly.</p>
    
            <div>
                
                    <div><p>In
the previous example, we wrote a doctest in a docstring. As tests
become more complex or require more involved configuration, it is
usually better to separate the actual test into a text file. Sometimes,
this can be the <span class="visualHighlight">README.txt</span> file of a package. This is the approach favoured by Zope 3 components.</p>

<p>In this example, we will register an adapter that is used in a
doctest. This doctest also serves to illustrate how this particular
adapter should be used.&nbsp; This style of test is great when the
emphasis is on the documentation as well as the test. Note that we do
not load the package's ZCML in its entirely. Instead, we register the
required components explicitly. This means that we retain control over
what is executed in the test. We use the <span class="visualHighlight">zope.component.testing.tearDown</span> method to ensure that our test environment is properly cleaned up.</p>

<p>In the <span class="visualHighlight">example.tests</span> package, we have the following test setup in <span class="visualHighlight">tests/test_zope3_doctest.py</span>:</p>

<pre>"""This is the setup for a doctest that tests a Zope 3 component.

There is really nothing too different from a "plain Python" test. We are not
parsing ZCML, for example. However, we use some of the helpers from Zope 3
to ensure that the Component Architecture is properly set up and torn down.
"""

import unittest

import zope.testing
import zope.component

def setUp(test):
    """This method is used to set up the test environment. We pass it to the
    DocFileSuite initialiser. We also pass a tear-down, but in this case,
    we use the tear-down from zope.component.testing, which takes care of
    cleaning up Component Architecture registrations.
    """
    
    # Register the adapter. See zope.component.interfaces for more

    from example.tests.context import UpperCaser
    zope.component.provideAdapter(UpperCaser)

def test_suite():
    return unittest.TestSuite((
    
        # Here, we tell the test runner to execute the tests in the given
        # file. The setUp and tearDown methods employed make use of the Zope 3
        # Component Architecture, but really there is nothing Zope-specific
        # about this. If you want to test "plain-Python" this way, the setup
        # is the same.
    
        zope.testing.doctest.DocFileSuite('tests/zope3.txt',
                     package='example.tests',
                     setUp=setUp,
                     tearDown=zope.component.testing.tearDown),
        ))
</pre>

<p>Notice how we use a custom <span class="visualHighlight">setUp()</span> method to register the custom adapter, and then reference <span class="visualHighlight">zope.component.testing.tearDown</span> for the tear-down method.</p>

<p>This refers to the file <span class="visualHighlight">zope3.txt</span>, which looks like this:</p>

<pre>==========================
A Zope 3 component doctest
==========================

This is the type of test found most commonly in Zope 3. We have a custom
setup method (in test_zope3_doctest.py) which registers the components we
need for the test. We can then use those here. ZCML is not processed directly,
nor do we have a full Zope 2/Plone environment available. This makes the test
more isolated (and faster!). Often, we may choose to use mock implementations
of certain components in order to make the test properly isolated.

Of course, we should still tell a story with this documentation.

Let's say we had one of our really exciting context objects:

    &gt;&gt;&gt; from example.tests.context import Context
    &gt;&gt;&gt; context = Context()
    &gt;&gt;&gt; context.title = u"Some puny title"

Of course, that's nice, but what if we wanted to make a bit more of an impact?
We can use our handy upper-caser adapter!

    &gt;&gt;&gt; from example.tests.interfaces import IUpperCaser
    &gt;&gt;&gt; shout = IUpperCaser(context)
    &gt;&gt;&gt; shout.title
    u'SOME PUNY TITLE'
    
Wow!
</pre>

<p>To run just this test, we may do:</p>

<pre>  ./bin/instance test -s example.tests -t zope3.txt
  Running unit tests:
    Running:
  ..
    Ran 2 tests with 0 failures and 0 errors in 0.010 seconds.
</pre></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                7.8.
                Writing a PloneTestCase unit/integration test
            </h1>

            <p class="documentDescription">Sometimes, we need access to a full-blown Plone instance in order to effectively write tests</p>
    
            <div>
                
                    <div><p><span class="visualHighlight">PloneTestCase</span>, which in turn uses <span class="visualHighlight">ZopeTestCase</span>,
is used to set up a full Zope environment, including a Plone instance,
for testing. This type of test is very convenient and often necessary
because content types, tools and other parts of Plone have hard
dependencies on various underlying Zope, CMF and Plone components. It
is generally better to write simpler tests, however, both because they
provide better isolation (thus testing the component more directly and
under better controlled circumstances) and because they execute faster.</p>

<p>PloneTestCase-tests are often referred to as "unit tests", but in truth they are <em>integration</em>
tests, since they depend on a "live" Zope instance and thus test the
integration between your code and the underlying framework. We can use
the PloneTestCase setup to run doctests, as we will see in the next
section.</p>

<p>Here, however, we will demonstrate how to use <span class="visualHighlight">unittest.TestCase</span> classes, where each test is a method on a class (with a name beginning with <span class="visualHighlight">test</span>)
This type of test is not as good for documentation, but can be very
useful for systematically executing many variations on the same test.
Some developers also find this type of test easier to debug, since it
is plain Python code which can be stepped through using the debugger.</p>

<p>In the <span class="visualHighlight">example.tests</span> package, we have <span class="visualHighlight">tests/base.py</span>. This does not contain any tests, but performs the necessary configuration to set up the test fixture:</p>

<pre>"""Test setup for integration and functional tests.

When we import PloneTestCase and then call setupPloneSite(), all of Plone's
products are loaded, and a Plone site will be created. This happens at module
level, which makes it faster to run each test, but slows down test runner
startup.
"""

from Products.Five import zcml
from Products.Five import fiveconfigure

from Testing import ZopeTestCase as ztc

from Products.PloneTestCase import PloneTestCase as ptc
from Products.PloneTestCase.layer import onsetup

#
# When ZopeTestCase configures Zope, it will *not* auto-load products in 
# Products/. Instead, we have to use a statement such as:
# 
#   ztc.installProduct('SimpleAttachment')
# 
# This does *not* apply to products in eggs and Python packages (i.e. not in
# the Products.*) namespace. For that, see below.
# 
# All of Plone's products are already set up by PloneTestCase.
# 

@onsetup
def setup_product():
    """Set up the package and its dependencies.
    
    The @onsetup decorator causes the execution of this body to be deferred
    until the setup of the Plone site testing layer. We could have created our
    own layer, but this is the easiest way for Plone integration tests.
    """
    
    # Load the ZCML configuration for the example.tests package.
    # This can of course use &lt;include /&gt; to include other packages.
    
    fiveconfigure.debug_mode = True
    import example.tests
    zcml.load_config('configure.zcml', example.tests)
    fiveconfigure.debug_mode = False
    
    # We need to tell the testing framework that these products
    # should be available. This can't happen until after we have loaded
    # the ZCML. Thus, we do it here. Note the use of installPackage() instead
    # of installProduct().
    # 
    # This is *only* necessary for packages outside the Products.* namespace
    # which are also declared as Zope 2 products, using 
    # &lt;five:registerPackage /&gt; in ZCML.
    
    # We may also need to load dependencies, e.g.:
    # 
    #   ztc.installPackage('borg.localrole')
    # 
    
    ztc.installPackage('example.tests')
    
# The order here is important: We first call the (deferred) function which
# installs the products we need for this product. Then, we let PloneTestCase 
# set up this product on installation.

setup_product()
ptc.setupPloneSite(products=['example.tests'])

class ExampleTestCase(ptc.PloneTestCase):
    """We use this base class for all the tests in this package. If necessary,
    we can put common utility or setup code in here. This applies to unit 
    test cases.
    """

class ExampleFunctionalTestCase(ptc.FunctionalTestCase):
    """We use this class for functional integration tests that use doctest
    syntax. Again, we can put basic common utility or setup code in here.
    """
</pre>

<p>Notice how we can explicitly install third party products (and
egg-based packages which use product semantics) and then tell
PloneTestCase to quick-install these into the test fixture site. The
test runner will <em>not</em> automatically load all products in the <span class="visualHighlight">Products.*</span> namespace, nor will it execute ZCML for packages outside <span class="visualHighlight">Products.*</span> automatically.</p>

<p>The test class which uses this environment is found in <span class="visualHighlight">tests/test_integration_unit.py</span>:</p>

<pre>"""This is an integration "unit" test. It uses PloneTestCase, but does not
use doctest syntax.

You will find lots of examples of this type of test in CMFPlone/tests, for 
example.
"""

import unittest
from example.tests.tests.base import ExampleTestCase

from Products.CMFCore.utils import getToolByName

class TestSetup(ExampleTestCase):
    """The name of the class should be meaningful. This may be a class that
    tests the installation of a particular product.
    """
    
    def afterSetUp(self):
        """This method is called before each single test. It can be used to
        set up common state. Setup that is specific to a particular test 
        should be done in that test method.
        """
        self.workflow = getToolByName(self.portal, 'portal_workflow')
        
    def beforeTearDown(self):
        """This method is called after each single test. It can be used for
        cleanup, if you need it. Note that the test framework will roll back
        the Zope transaction at the end of each test, so tests are generally
        independent of one another. However, if you are modifying external
        resources (say a database) or globals (such as registering a new
        adapter in the Component Architecture during a test), you may want to
        tear things down here.
        """
    
    def test_portal_title(self):
        
        # This is a simple test. The method needs to start with the name
        # 'test'. 

        # Look at the Python unittest documentation to learn more about hte
        # kinds of assertion methods which are available.

        # PloneTestCase has some methods and attributes to help with Plone.
        # Look at the PloneTestCase documentation, but briefly:
        # 
        #   - self.portal is the portal root
        #   - self.folder is the current user's folder
        #   - self.logout() "logs out" so that the user is Anonymous
        #   - self.setRoles(['Manager', 'Member']) adjusts the roles of the current user
        
        self.assertEquals("Plone site", self.portal.getProperty('title'))

    def test_able_to_add_document(self):
        new_id = self.folder.invokeFactory('Document', 'my-page')
        self.assertEquals('my-page', new_id)
        
    # Keep adding methods here, or break it into multiple classes or
    # multiple files as appropriate. Having tests in multiple files makes
    # it possible to run tests from just one package:
    #
    #   ./bin/instance test -s example.tests -t test_integration_unit


def test_suite():
    """This sets up a test suite that actually runs the tests in the class
    above
    """
    suite = unittest.TestSuite()
    suite.addTest(unittest.makeSuite(TestSetup))
    return suite
</pre>

<p>Here, we have a test suite with one test class - we could have added more classes if necessary. The <span class="visualHighlight">afterSetUp()</span> and <span class="visualHighlight">beforeTearDown()</span>
methods - if present - are called immediately before and after each
test. After a test is run, the transaction is rolled back, causing
tests to run in isolation. You only really need explicit teardown if
your tests make permantent changes that are not covered by the ZODB
transaction machinery.</p>

<p>You are free to add whatever helper methods you wish to your unit test class, but any method with a name starting with <span class="visualHighlight">test</span> will be executed as a test. Tests are usually written to be as concise (not to be confused with "obfuscated") as possible.</p>

<p>Notice the calls to methods like <span class="visualHighlight">self.assertEqual()</span> or <span class="visualHighlight">self.failUnless()</span>.
These are the assertion methods that do the actual testing. If any of
these fail, that test is counted as a failure and you'll get an ugly F
in your test output.</p>

<p>To run the test, we would do:</p>

<pre>  ./bin/instance test -s example.tests -t test_integration_unit
    Running:
  ..
    Ran 2 tests with 0 failures and 0 errors in 0.178 seconds.
</pre>

<p>There is actually more output than this, as PloneTestCase installs a number of products and processes ZCML.</p>

<h2>Rules of thumb<br></h2>

<p>There are some basic rules of thumb for writing unit tests with PloneTestCase you should be aware of:</p>

<ul><li>Write test first, don't put it off, and don't be lazy (did we say this enough already?)</li><li>Write one test (i.e. one method) for each thing you want to test</li><li>Keep related tests together (i.e. in the same test case class)</li><li>Be
pragmatic. If you want to test every combination of inputs and outputs
you will probably go blue in the face, and the additional tests are
unlikely to be of much value. Similarly, if a method is complicated,
don't just test the basic case. This comes with experience, but in
general, you should test common cases, edge cases and preferably cases
in which the method or component is expected to fail (i.e. test that it
fails as expected - you still shouldn't get any F's in your test
output!).</li><li>Keep tests simple. Don't try to be clever, don't
over-generalise. When a test fails, you need to easily determine
whether it is because the test itself is wrong, or the thing it is
testing has a bug.<br></li></ul><h2>Assertion and utility methods in the unit testing framework</h2>

<p>There are quite a few assertion methods, most of which do basically
the same thing - check if something is True or False. Having a variety
of names allows you to make your tests read the way you want. The list
of assertion methods can be found in the Python documentation for <span class="visualHighlight">unittest.TestCase</span>. The most common ones are:</p>

<dl><dt>failUnless(expr)</dt><dd>Ensure expr is true&nbsp;</dd><dt>assertEqual(expr1, expr2)&nbsp;</dt><dd>Ensure expr1 is equal to expr2&nbsp;</dd><dt>assertRaises(exception, callable, ...)&nbsp;</dt><dd>Make
sure exception is raised by the callable. Note that callable here
should be the name of a method or callable object, not an actual call,
so you write e.g. <span class="visualHighlight">self.assertRaises(AttributeError, myObject.myMethod, someParameter)</span>. Note lack of () after <span class="visualHighlight">myMethod</span>.
If you included it, you'd get the exception raised in your test method,
which is probably not what you want. Instead, the statement above will
cause the unit testing framework to call <span class="visualHighlight">myMethod(someParameter)</span> (you can pass along any parameters you want after the calalble) and check for an <span class="visualHighlight">AttributeError</span>.<br></dd><dt>fail()&nbsp;</dt><dd>Simply
fail. This is useful if a test has not yet been completed, or in an if
statement inside a test where you know the test has failed.&nbsp;</dd></dl><p>In addition to the unit testing framework assertion methods,

ZopeTestCase and PloneTestCase include some helper methods and

variables to help you interact with Zope. It's instructive to read the

source code for these two products, but briefly, the key variables you

can use in unit tests are:</p>

<dl><dt>self.portal&nbsp;</dt><dd>The Plone portal the test is executing in&nbsp;</dd><dt>self.folder&nbsp;</dt><dd>The member folder of the member you are executing as&nbsp;</dd></dl><p>And the key methods are:</p>

<dl><dt>self.logout()&nbsp;</dt><dd>Log out, i.e. become anonymous&nbsp;</dd><dt>self.login()&nbsp;</dt><dd>Log in again. Pass a username to log in as a different user.&nbsp;</dd><dt>self.setRoles(roles)&nbsp;</dt><dd>Pass in a list of roles you want to have. For example, self.setRoles(('Manager',)) lets you be manager for a while. How nice.</dd><dt>self.setPermissions(permissions)</dt><dd>Similarly, grant a number of permissions to the current user in <span class="visualHighlight">self.folder</span>.&nbsp;</dd><dt>self.setGroups(groups)&nbsp;</dt><dd>Set which groups the test user is in.&nbsp;<br></dd></dl><h2>Tips &amp; Tricks<br></h2>

<p>Good unit testing comes with experience. It's always useful to read
the unit tests of code with which you are fairly familiar, to see how
other people unit test. We'll cover a few hints here to get you
thinking about how you approach your own tests:</p>

<ul><li>Don't be timid! Python, being a dynamic scripting language,
lets you do all kinds of crazy things. You can rip a function right out
from the Plone core and replace it with your own implementation in
afterSetUp() or a test if that serves your testing purposes.</li><li>Similarly, replacing things like the <span class="visualHighlight">MailHost</span> with dummy implementations may be the only way to test certain features. Look at <span class="visualHighlight">CMFPlone/tests/dummy.py</span> for some examples of dummy objects.</li><li>Use
tests to try things out. They are a safe environment. If you need to
try something a bit out of the ordinary, writing them in a test is
often the easiest way of seeing how something works.</li><li>During
debugging, you can insert print statements in tests to get traces in
your terminal when you execute the tests. Don't check in code with
printing tests, though. :)</li><li>Similarly, the python debugger is very valuable inside tests. Putting <span class="visualHighlight">import pdb; pdb.set_trace()</span>
inside your test methods lets you step through testing code and step
into the code it calls. If you're not familiar with the python
debugger, your life is incomplete. <a class="external-link" href="http://plone.org/documentation/manual/how-to/using-pdb/">More about using pdb with Plone</a>.<br></li></ul></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                7.9.
                Integration doctests using PloneTestCase
            </h1>

            <p class="documentDescription">The PloneTestCase integration test setup can also be used in doctests</p>
    
            <div>
                
                    <div><p>The
choice of test case classes over doctest is purely one of syntactic
preference. We can use the test setup from the previous section (in <span class="visualHighlight">base.py</span>)
in a doctest as well. This type of test is more useful for documenting
the integration of your code with Zope/Plone in a narrative fashion.</p>

<p>There is no change to <span class="visualHighlight">tests/base.py</span> for this type of setup. However, we must be careful to use a test class that derives from <span class="visualHighlight">FunctionalTestCase</span>, since this performs the initialisation necessary for doctests. The test setup is found in  <span class="visualHighlight">tests/test_integration_doctest.py</span>:</p>

<pre>"""This is an integration doctest test. It uses PloneTestCase and doctest
syntax.
"""

import unittest
import doctest

from zope.testing import doctestunit
from Testing import ZopeTestCase as ztc

from example.tests.tests import base

def test_suite():
    """This sets up a test suite that actually runs the tests in the class
    above
    """
    return unittest.TestSuite([

        # Here, we create a test suite passing the name of a file relative 
        # to the package home, the name of the package, and the test base 
        # class to use. Here, the base class is a full PloneTestCase, which
        # means that we get a full Plone site set up.

        # The actual test is in integration.txt

        ztc.ZopeDocFileSuite(
            'tests/integration.txt', package='example.tests',
            test_class=base.ExampleFunctionalTestCase,
            optionflags=doctest.REPORT_ONLY_FIRST_FAILURE | 
                        doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS),
            
        # We could add more doctest files here as well, by copying the file
        # block above.

        ])
</pre>

<p>Here, we set <span class="visualHighlight">ExampleFunctionalTestCase</span> from <span class="visualHighlight">base.py</span> as the <span class="visualHighlight">test_class</span>, which means that <span class="visualHighlight">self</span> in the doctest will be the same as <span class="visualHighlight">self</span> in the test class we saw in the previous section. In particular, we can access variables such as <span class="visualHighlight">self.portal</span> and <span class="visualHighlight">self.folder</span>.
We also set some common doctest option flags - reporting only the first
failure (to avoid overly long error output when an example early on in
the doctest fails), normalising whitespace (so that we can use newlines
freely) and allowing the ellipsis operator everywhere (as opposed to
having to turn it on each time we want to use it). Look at the <span class="visualHighlight">doctest</span> module documentation for more information.</p>

<p>The test itself, in <span class="visualHighlight">tests/integration.txt</span>, is written much like the other doctests we have seen:</p>

<pre>======================
An integration doctest
======================

This test is an integration test that uses PloneTestCase. Here, 'self' is
the test class, so we can use 'self.folder', 'self.portal' and so on. The
setup is done in teststest_integration_doctest.py

Being a doctest, we can tell a story here. 

For example, let's say a user had a dying wish: to add a news item. We'll do
that using the standard Plone API.

    &gt;&gt;&gt; self.folder.invokeFactory('News Item', 'news-item')
    'news-item'
    
That's great, but really, he wanted to add it to the portal root:
    
    &gt;&gt;&gt; self.portal.invokeFactory('News Item', 'news-item')
    Traceback (most recent call last):
    ...
    Unauthorized: Cannot create News Item

Whoops! Too bad! 

At least we got to demonstrate the ellipsis operator, which
matches arbitrary text. We enabled this in test_integration_doctest.py. It
is also possible to enable (or disable) this flag on a single statement.
See the Python doctest documentation for more information.
</pre>

<p>To run this test on its own, we would do:</p>

<pre>  ./bin/instance test -s example.tests -t integration.txt
    Running:
  ..
    Ran 2 tests with 0 failures and 0 errors in 0.384 seconds.
</pre>

<p>Again, we have cut out some of the output from PloneTestCase.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                7.10.
                Functional and system tests with zope.testbrowser
            </h1>

            <p class="documentDescription">Whilst
unit tests and doctests verify the correctness of individual methods
and modules, functional tests test portions of the application as a
whole, often from the point of view of the user, and typically aligned
with use cases. System tests, in comparison, test the entire
application as a black box.</p>
    
            <div>
                
                    <div><p>No
developer likes to click around the browser to check if that button
that was only supposed to show up in some cases really did show up.
Unfortunately, these are also the types of problems that most often
suffer from regressions, because templates are difficult (and slow) to
test.</p>

<p>Zope 3 has an elegant library called <span class="visualHighlight">zope.testbrowser</span>
which lets you write doctests that behave like a real web browser
(almost... it cannot yet handle JavaScript, which means that testing
dynamic UIs that depend on JavaScript is not possible, although <a href="http://www.openqa.org/selenium/">Selenium </a>may
be a viable alternative here). You can open URLs, click links, fill in
form fields and test the HTTP headers, URLs and page contents that are
returned from Plone. In fact, you could test any website, not just Zope
or Plone ones.</p>

<p>Functional tests are no replacement for unit tests. They test a
slice of functionality, typically as the user sees it. Thus, they may
not systematically include every aspect of the application. For
example, a functional test may check whether a "Delete" button is
present, and even that it works as expected, but should not be used to
exhaustively test whether the delete operation works in every possible
edge case. Where they excel, however, is in testing things like which
options appear to which users depending on roles and permissions, or
simply to exercise all the various templates used in a given product to
make sure they don't break.</p>

<p>Here is an example from the <span class="visualHighlight">example.tests</span> package. The test setup is in <span class="visualHighlight">tests/test_functional_doctest.py</span>:</p>

<pre>"""This is a a functional doctest test. It uses PloneTestCase and doctest
syntax. In the test itself, we use zope.testbrowser to test end-to-end
functionality, including the UI.

One important thing to note: zope.testbrowser is not JavaScript aware! For
that, you need a real browser. Look at zope.testbrowser.real and Selenium
if you require "real" browser testing.
"""

import unittest
import doctest


from Testing import ZopeTestCase as ztc

from example.tests.tests import base

def test_suite():
    """This sets up a test suite that actually runs the tests in the class
    above
    """
    return unittest.TestSuite([

        # Here, we create a test suite passing the name of a file relative 
        # to the package home, the name of the package, and the test base 
        # class to use. Here, the base class is a full PloneTestCase, which
        # means that we get a full Plone site set up.

        # The actual test is in functional.txt

        ztc.ZopeDocFileSuite(
            'tests/functional.txt', package='example.tests',
            test_class=base.ExampleFunctionalTestCase,
            optionflags=doctest.REPORT_ONLY_FIRST_FAILURE | 
                        doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS),
            
        # We could add more doctest files here as well, by copying the file
        # block above.

        ])
</pre>

<p>This code is actually identical to the test setup for the
integration doctest in the previous section. The differences are found
in the actual test itself, which uses <span class="visualHighlight">Products.Five.testbrowser.Browser</span>, a Zope 2 compatability wrapper around <span class="visualHighlight">zope.testbrowser.Browser</span>:</p>

<pre>====================
A functional doctest
====================

This is a full-blown functional test. The emphasis here is on testing what
the user may input and see, and the system is largely tested as a black box.
We use PloneTestCase to set up this test as well, so we have a full Plone site
to play with. We *can* inspect the state of the portal, e.g. using 
self.portal and self.folder, but it is often frowned upon since you are not
treating the system as a black box. Also, if you, for example, log in or set
roles using calls like self.setRoles(), these are not reflected in the test
browser, which runs as a separate session.

Being a doctest, we can tell a story here. 

First, we must perform some setup. We use the testbrowser that is shipped
with Five, as this provides proper Zope 2 integration. Most of the 
documentation, though, is in the underlying zope.testbrower package.

    &gt;&gt;&gt; from Products.Five.testbrowser import Browser
    &gt;&gt;&gt; browser = Browser()
    &gt;&gt;&gt; portal_url = self.portal.absolute_url()

The following is useful when writing and debugging testbrowser tests. It lets
us see all error messages in the error_log.

    &gt;&gt;&gt; self.portal.error_log._ignored_exceptions = ()

With that in place, we can go to the portal front page and log in. We will
do this using the default user from PloneTestCase:

    &gt;&gt;&gt; from Products.PloneTestCase.setup import portal_owner, default_password

    &gt;&gt;&gt; browser.open(portal_url)

We have the login portlet, so let's use that.

    &gt;&gt;&gt; browser.getControl(name='__ac_name').value = portal_owner
    &gt;&gt;&gt; browser.getControl(name='__ac_password').value = default_password
    &gt;&gt;&gt; browser.getControl(name='submit').click()

Here, we set the value of the fields on the login form and then simulate a
submit click.

We then test that we are still on the portal front page:

    &gt;&gt;&gt; browser.url == portal_url
    True
    
And we ensure that we get the friendly logged-in message:

    &gt;&gt;&gt; "You are now logged in" in browser.contents
    True

To learn more, look at the zope.testbrowser documentation and interfaces.
There are also a few examples of testbrowser tests in Plone itself.
</pre>

<p>All the action happens with the <span class="visualHighlight">browser</span>
object. This simulates a web browser (though as stated above, one that
does not support JavaScript), and has a pleasant API for finding form
controls and links and clicking on them. The variables <span class="visualHighlight">browser.url</span> and <span class="visualHighlight">browser.contents</span>
represent what would've been in the URL bar and the rendered view of
the page, respectively, and can be examined like any other variable.</p>

<p><span class="visualHighlight">zope.testbrowser</span> has pretty comprehensive documentation in its <a href="http://svn.zope.org/zope.testbrowser/trunk/src/zope/testbrowser/README.txt?view=auto">README.txt</a> file - which is, of course, a runnable doctest. In brief, the most important methods of the <a href="http://svn.zope.org/zope.testbrowser/trunk/src/zope/testbrowser/interfaces.py?view=auto">IBrowser interface</a> (and thus the <span class="visualHighlight">Browser</span> class) are:</p>

<dl><dt>open(url)</dt>

<dd>Open a given URL.</dd>

<dt>reload()</dt>

<dd>Reload the current page, much as the Refresh button in your browser would do.</dd>

<dt>goBack(count=1)</dt>

<dd>Simulate pressing the Back button <span class="visualHighlight">count</span> times.</dd>

<dt>getLink(text=None, url=None, id=None)</dt>

<dd>Get an ILink (which you can then call <span class="visualHighlight">click()</span> on), either by the text inside the &lt;a&gt; tags, by the URL in the <span class="visualHighlight">href</span> attribute, or the <span class="visualHighlight">id</span> of the link.</dd>

<dt>getControl(label=None, name=None, index=None)</dt>

<dd>Get an <span class="visualHighlight">IControl</span>, representing a form control, by label (either the value of a submit button or the contents of an associated <span class="visualHighlight">&lt;label&gt;</span> tag) or form name. The index argument is used to disambiguate if there is more than one control (e.g. <span class="visualHighlight">index=0</span> gets the first one). Again, you can call <span class="visualHighlight">click()</span> on the control object to simulate clicking on it.</dd></dl><p>The
IBrowser interface also provides some properties that can be used to
examine the state of the current page. The most important ones are:</p>

<dl><dt>url</dt>

<dd>The full URL to the current page.</dd>

<dt>contents</dt>

<dd>The full contents of the current page, as a string (usually containing HTML tags)</dd>

<dt>headers</dt>

<dd>A dict of HTTP headers</dd></dl><p>Please refer to the <a href="http://svn.zope.org/zope.testbrowser/trunk/src/zope/testbrowser/interfaces.py?view=auto">interfaces</a> and the <a href="http://svn.zope.org/zope.testbrowser/trunk/src/zope/testbrowser/README.txt?view=auto">README file</a> for details on the other methods and attributes, the interfaces for various types of links and controls, and further examples.</p>

<h2>Debugging functional tests</h2>

<p> Sometimes you will get errors from Zope resulting from some command
executed using the testbrowser. In this case, it can sometimes be
difficult to know what the underlying cause is. Two debugging aids
exist to make this a bit easier.</p>

<p>First of all, make sure you see all errors in full by setting:</p>

<pre>    &gt;&gt;&gt; browser.handleErrors = False
</pre>

<p>If <span class="visualHighlight">handleErrors</span> is True (the default) you will get errors like <span class="visualHighlight">HTTPError: HTTP Error 404: Not Found</span> or <span class="visualHighlight">HTTPError: HTTP Error 500: Internal Server Error</span>. Those are probably not very useful to you. Setting <span class="visualHighlight">handleErrors</span> to False will show the full exceptions Zope (or possibly the HTML rendering of the error page, depending on the type of error).</p>

<p>Secondly, if you are using PloneTestCase, you can use Plone's error log. At the top of the example, we do:</p>

<pre>    &gt;&gt;&gt; self.portal.error_log._ignored_exceptions = ()
</pre>

<p>This means that errors such as NotFound and Unauthorized will be
shown in the error log. It may also be useful to enable Verbose
Security in <span class="visualHighlight">zope.conf</span> (see the comments in that file for details). Now, when a line appears that is throwing an error you can't debug, you can do:</p>

<pre>    &gt;&gt;&gt; try:
    ...     browser.getControl('Save').click()
    ... except:
    ...     print self.portal.error_log.getLogEntries()[0]['tb_text']
    ...     import pdb; pdb.set_trace()
    &gt;&gt;&gt; # continue as normal
</pre>

<p>This will print the most recent entry in the error log, and set a PDB break point.</p>

<h3>Using a real browser to render the results of your tests</h3>

<p>Sometimes you would like to see the output of <code>browser.contents</code>
in a browser to easily debug what's happening in your functional tests.
To do so, place a PDB break point in your tests as described above (<code>import pdb; pdb.set_trace()</code>) and type the following when you get to the PDB prompt while running the tests:</p>

<pre>&gt;&gt;&gt; from Testing.ZopeTestCase.utils import startZServer
&gt;&gt;&gt; startZServer()
</pre>

<p>This will print a tuple like</p>

<pre>('127.0.0.1', 55143)</pre>

<p>containing an IP address and port where you can access the same test
site that the testbrowser is working with, in a real browser.</p>

<h2>Functional tests vs. system tests</h2>

<p> A system test is one which treats the entire system as a black box,
interacting with it as a user would. A functional test is more focused
on a single "vertical" of functionality, typically linked to a
particular use case.</p>

<p>For a functional test, it <em>may</em> be acceptable to examine the internal state of the portal (using <span class="visualHighlight">self.portal</span> and the <span class="visualHighlight">PloneTestCase.FunctionalTestCase</span>
class to build a test suite) to provide assertions. A system test, by
contrast, makes no such assumptions. Ideally, you should be able to
point a <span class="visualHighlight">zope.testbrowser</span> test at a remote site running a fresh installation of your system, and have the tests pass.</p>

<p>Beyond that, the tools used to write a system test are the same. It
is only the approach to testing that changes. Whether you need one, or
the other, or both, will depend on the level of rigour you need in your
tests, and how your system is constructed. In general, though, true
system tests are more rare than functional (integration) tests and unit
tests.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                7.11.
                Using zope.testrecorder to record functional tests
            </h1>

            <p class="documentDescription">The
zope.testrecorder product brings us full-circle: functional tests are
recorded from within the browser, and saved to a runnable test.</p>
    
            <div>
                
                    <div><p>Functional tests using <span class="visualHighlight">zope.testbrowser</span>
save us from clicking around the browser to regression test UI, but
writing them could still be easier. With complex templates, it can
sometimes be difficult to find out what actual links and form fields
the testbrowser test should be looking for, and what text to use in
assertions.</p>

<p>This is where <span class="visualHighlight">zope.testrecorder</span>
comes in. The theory is that you click around the UI only once, and
then render the history of what you did to a runnable testbrowser test.
<span class="visualHighlight">zope.testrecorder</span> can even create <a href="http://plone.org/documentation/manual/developer-manual/testing/zope.org/Members/tseaver/Zelenium">Selenium</a>
tests - an alternative form of functional tests which runs in the
browser (i.e. it automates your browser right before your eyes) and
thus supports JavaScript, but which cannot be run as part of an
automated test run without a browser.</p>

<p>Installing <span class="visualHighlight">zope.testrecorder</span> is simple. First, check it out from Zope's subversion repository:</p>

<pre>    svn co svn://svn.zope.org/repos/main/zope.testrecorder/trunk zope.testrecorder
</pre>

<p>&nbsp;</p>

<p>See <span class="visualHighlight">INSTALL.txt</span> for further instructions, but the easiest way to install it in a Zope 2 instance is just to put it in your <span class="visualHighlight">Products</span> directory: Copy <span class="visualHighlight">zope.testrecorder/src/zope/testrecorder</span> as a product into <span class="visualHighlight">Products/testrecorder</span> and restart Zope. Then, go to the ZMI and add a <span class="visualHighlight">Test Recorder</span> object in the root of your Zope instance. Call it e.g. <span class="visualHighlight">test-recorder</span>.</p>

<p>Presuming you run Zope on localhost:8080, you should now be able to go to <span class="visualHighlight">http://localhost:8080/test-recorder/index.html</span>. You should see a page something like this:</p>

<p><img src="developer-manual_archivos/blank-testrecorder.png" alt="Screenshot of blank test recorder"></p>

<p><strong>NOTE:</strong> Like most things, <span class="visualHighlight">zope.testrecorder</span> seems to work better in Firefox than in other browsers.</p>

<p>Now, enter the address of your Plone site (or indeed any web site), e.g. <span class="visualHighlight">http://localhost:8080/Plone</span>
and click Go. You can perform any number of operations, e.g. logging in
and clicking around the UI. If you wish to add a comment to your test
run, as you would add free text inside a doctest, click the <span class="visualHighlight">Add comment</span>
button. If you wish to verify that some text appears on the page,
highlight that text, shift-click on it, and select "Check text appears
on page":</p>

<p><img src="developer-manual_archivos/verify-testrecorder.png" alt="Screenshot of text verification"></p>

<p>When you are done, click <span class="visualHighlight">Stop recording</span>. You can then choose to render the test as a <span class="visualHighlight">Python doctest</span> and you will get something like:</p>

<pre>  Create the browser object we'll be using.

      &gt;&gt;&gt; from zope.testbrowser import Browser
      &gt;&gt;&gt; browser = Browser()
      &gt;&gt;&gt; browser.open('http://localhost/test')

  A test comment.

      &gt;&gt;&gt; 'start writing' in browser.contents
      True
</pre>

<p>&nbsp;</p>

<p>You can then paste this into a doctest file, and perform any
post-processing or make any changes that may be necessary to make the
test more generally valid.</p>

<h2>Tips for using zope.testrecorder</h2>

<dl><dt> Plan, plan, plan</dt>

<dd>It's best if you have a rough script in front of you before you
start recording tests, or you may get lost afterwards. Make good use of
the <span class="visualHighlight">Add comment</span> button to state what you are testing before you test it, so that the final doctest will make sense.</dd>

<dt> Careful where you click</dt>

<dd>Some parts of the Plone UI are more ephemeral than others. It may not be a good idea to rely on links in the <span class="visualHighlight">Recent</span>
portlet, for example. Think about what operations will provide the most
general and valid test. It will save you time in the long run.</dd>

<dt> Set up your site beforehand</dt>

<dd>Recall from the section on <span class="visualHighlight">zope.testbrowser</span>
that we set up users and basic site structure with calls to the Python
APIs instead of using testbrowser to manipulate the "site setup"
screents. When using <span class="visualHighlight">zope.testrecorder</span>
you may want to set up the same users with the same user names and
passwords, and the same site structure before you start recording to
test. Otherwise, you may need to change some of the values of the test.</dd>

<dt> Check the doctest</dt>

<dd><span class="visualHighlight">zope.testrecorder</span> is a
time-saving tool. Sometimes, it may end up referring to parts of the
page that can't be guaranteed to be consistent (such as randomly
generated ids of content objects), and sometimes you may have gone on a
detour and ended up with a test that contains irrelevant or duplicate
sections. Always fix up your test (and run it!) afterwards, to make
sure that the test remains valid for the future - otherwise, you will
end up clicking around the UI in anger again before you know it.
</dd></dl></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                7.12.
                Determining the Code Coverage of your Test Suite
            </h1>

            <p class="documentDescription">Explanation for how to use the Zope test runner's built in code coverage features to prove the quality of your test suite. </p>
    
            <div>
                
                    <div><p>The
better your test suite's coverage, the lower the likelihood that some
modification to your code will break another piece of functionality in
some unanticipated way.&nbsp; But, how do you <strong>know the quality</strong> of your test coverage?&nbsp; Zope's test runner comes with several features to help you do just that.</p>

<p>&nbsp;</p>

<p>But first, let's say you've written some code with a Python conditional like the following:</p>

<pre>if value % 2 == 0:
    print "This is an even number"
else:
    # we need to do some more complex
    # computation to handle odd numbers
    _someComplexCodeDealingWithOddNumbers(value)
</pre>

<p>The comments and function call in the else clause are symbolic of
some advanced coding that's required to handle all odd numbers.&nbsp;</p>

<p>&nbsp;</p>

<p>Now, as you've no doubt learned while reading this tutorial, testing
is important.&nbsp; But what if for one reason or another, all the test
cases you've come up with during testing amount to even numbers when
you get to the aforementioned block of code. If this were the case,
you'd have a big risk of unanticipated code breakage to the way that
you handle odd numbers.&nbsp; This is something that you'd ideally
cover in your test suite.</p>

<p>&nbsp;</p>

<h3>Discovering the untested sections of your code<br></h3>

<p>You've learned how to run your test suite in this tutorial.&nbsp; Zope's test runner accepts an optional parameter called <span class="visualHighlight">--coverage</span>.&nbsp;
When passed a path to a directory, Zope will generate some high-level
output and produce a coverage file for each of the Python modules in
your product or package.&nbsp;</p>

<p>In full, running your test suite with the coverage option enabled looks like:</p>

<pre>./bin/instance test -s Products.productname --coverage=$HOME/coverage
</pre>

<p><br><strong>Note</strong>: Running your tests with the coverage
option enabled takes significantly longer (as in ~10 times or more)
than without, so this is something to be done occasionally to gauge
your work, rather than each time you run your tests.</p>

<p><br>At the end of running your test suite, you'll get some immediate
output like the following, which includes lines of code and your
coverage percentage:</p>

<pre>lines&nbsp;&nbsp; cov%&nbsp;&nbsp; module&nbsp;&nbsp; (path)
&nbsp; 104&nbsp;&nbsp; 100%&nbsp;&nbsp; $INSTANCE_HOME.parts.salesforce-integration-products.salesforcepfgadapter.Extensions.Install
               ($INSTANCE_HOME/parts/salesforce-integration-products/salesforcepfgadapter/Extensions/Install.py)
&nbsp;&nbsp; 39&nbsp;&nbsp;&nbsp; 41%&nbsp;&nbsp; $INSTANCE_HOME.parts.salesforce-integration-products.salesforcepfgadapter.__init__&nbsp;&nbsp; 
               ($INSTANCE_HOME/parts/salesforce-integration-products/salesforcepfgadapter/__init__.py)
&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; 100%&nbsp;&nbsp; $INSTANCE_HOME.parts.salesforce-integration-products.salesforcepfgadapter.content.__init__&nbsp;&nbsp; 
               ($INSTANCE_HOME/parts/salesforce-integration-products/salesforcepfgadapter/content/__init__.py)
&nbsp; 168&nbsp;&nbsp;&nbsp; 91%&nbsp;&nbsp; $INSTANCE_HOME.parts.salesforce-integration-products.salesforcepfgadapter.content.salesforcepfgadapter&nbsp;&nbsp; 
               ($INSTANCE_HOME/parts/salesforce-integration-products/salesforcepfgadapter/content/salesforcepfgadapter.py)
&nbsp;&nbsp; 21&nbsp;&nbsp; 100%&nbsp;&nbsp; $INSTANCE_HOME.parts.salesforce-integration-products.salesforcepfgadapter.migrations.migrateUpTo10rc1&nbsp;&nbsp; 
               ($INSTANCE_HOME/parts/salesforce-integration-products/salesforcepfgadapter/migrations/migrateUpTo10rc1.py)</pre>

<p>&nbsp;If all you're looking for is a quick status report, this should suffice.</p>

<p>&nbsp;</p>

<p>However, if you want to dig deeper, head to the directory you listed in the <span class="visualHighlight">--coverage</span> option.&nbsp; <strong>Note:</strong> The files may be preceded with dots, thus requiring an <span class="visualHighlight">ls -a</span> in order to reach the coverage files.</p>

<p>&nbsp;</p>

<p>A sample file may look like the following:</p>

<pre>&nbsp;&nbsp;&nbsp; 1:&nbsp;&nbsp;&nbsp;&nbsp; def initializeArchetype(self, **kwargs):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """Initialize Private instance variables
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """
&nbsp;&nbsp; 15:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FormActionAdapter.initializeArchetype(self, **kwargs)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 15:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self._fieldsForSFObjectType = {}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 1:&nbsp;&nbsp;&nbsp;&nbsp; security.declareProtected(View, 'onSuccess')
&nbsp;&nbsp;&nbsp; 1:&nbsp;&nbsp;&nbsp;&nbsp; def onSuccess(self, fields, REQUEST=None):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """ The essential method of a PloneFormGen Adapter 
"""
&gt;&gt;&gt;&gt;&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logger.debug('Calling onSuccess()')
&gt;&gt;&gt;&gt;&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sObject = self._buildSObjectFromForm(fields, REQUEST)
&gt;&gt;&gt;&gt;&gt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if len(sObject.keys()) &gt; 1:

</pre>

<p>It's really just your file with some meaningful data proceeding each line.&nbsp; Anything with a <span class="visualHighlight">1:</span>
signifies that your code was at least touched during the running of the
test suite.&nbsp; The higher the number, the more often your code was
touched.&nbsp; Perhaps this is intentional and signifies really good
coverage in other cases, it's may be either unavoidable or could even
signify that the high level of coverage wouldn't actually be
required.&nbsp; The <span class="visualHighlight">&gt;&gt;&gt;&gt;&gt;&gt;</span>
means that you've missed a line and you should consider coming up with
a test scenario or more that will touch the line of code in
question.&nbsp; The number of untested lines divided by total lines
gives you your coverage percentage.</p>

<p>&nbsp;</p>

<h3>If what you really want is eye-candy</h3>
If you want pretty graphs to provide for you boss to include in a
report or to make a client feel better about the quality of code they
are receiving, <span class="visualHighlight">z3c.coverage</span> takes the contents of the output files

and creates pretty summaries.&nbsp; Get z3c.coverage from subversion via the following:

<pre>svn co&nbsp; svn://svn.zope.org/repos/main/z3c.coverage/trunk z3c.coverage</pre>

<p>Create a directory within your previously created coverage
directory.&nbsp; We call it reports.&nbsp; Run the coveragereport.py
module with the source being you coverage output and the destination,
your newly created reports directory.&nbsp; See the following:</p>

<pre>mkdir $HOME/coverage/reports
python z3c.coverage/src/z3c/coverage/coveragereport.py $HOME/coverage $HOME/coverage/reports</pre>

<p>You should now be able to open <span class="visualHighlight">$HOME/coverage/reports/all.html</span> within your browser for a pretty output like the one below.</p>

<p>&nbsp;</p>

<img class="image-inline" src="developer-manual_archivos/coverage.png" alt="z3c.coverage test coverage screenshot"><p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>With this information available, you can start to make conclusions
about how you may work your way towards better coverage of your product.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                7.13.
                Testing examples
            </h1>

            <p class="documentDescription">Here, we list a few packages and projects that demonstrate good test coverage</p>
    
            <div>
                
                    <div><p>Testing
is best learned by example. It can be very instructive to read through
the tests written by other developers and learn what they test, what
they don't test and how they write their tests.</p>

<ul><li><a href="http://dev.plone.org/collective/browser/examples/example.tests/trunk">example.tests</a>,
which we have already mentioned, contains an example of each of the
different types of tests covered in this tutorial. The test setup code
is well-commented, with the intention that this package should provide
good boilerplate for developers setting up a new project.</li><li><a class="external-link" href="http://dev.plone.org/plone/browser/Plone/trunk/Products/CMFPlone/tests">Plone itself</a>
has more than 1,600 tests at the time of writing. Most of these are
integration tests using unit-test syntax with PloneTestCase.</li><li><a href="http://dev.plone.org/collective/browser/RichDocument/trunk/tests/testSetup.py">RichDocument</a> has a basic <span class="visualHighlight">test_setup.py</span>
integration test. This is a good example of the kind of testing you may
want to do to ensure that your package installs cleanly.</li><li><a href="http://dev.plone.org/collective/browser/borg/components/borg.project/trunk">borg.project</a> contains a <a href="http://dev.plone.org/collective/browser/borg/components/borg.project/trunk/borg/project/README.txt">README.txt</a> file with an integration doctest demonstrating how it is used. It has only a single test module, <a href="http://dev.plone.org/collective/browser/borg/components/borg.project/trunk/borg/project/tests.py">tests.py</a>, which performs the same setup as <span class="visualHighlight">base.py</span> and <span class="visualHighlight">test_integration_doctest.py</span> from <span class="visualHighlight">example.tests</span>.</li><li>Many of the tests in the <a href="http://dev.plone.org/plone/browser/plone.app.controlpanel/trunk/plone/app/controlpanel/tests">plone.app.controlpanel</a> package use basic test-browser functional tests to verify that the Plone control panels work as expected.<br></li></ul><p>Feel free edit or comment on this page if you have more examples to add!</p></div>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-1">

            <h1>
                8.
                Generic Setup
            </h1>

            <p class="documentDescription">GenericSetup gives developers a way to easily import and export site configuration</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-2">

            <h1>
                8.1.
                What is GenericSetup?
            </h1>

            <p class="documentDescription">A brief overview of what GenericSetup is</p>
    
            <div>
                
                    <div><p>GenericSetup
is a product that allows developers to import and export site
configuration. This product was created to counteract Seaver's Law,
which states the following: "Persistence means always having to say
you're sorry". This means that any time you configure your Plone site
purely through the Plone interface or ZMI you run the risk of losing
your configuration. Since your configuration was only persisted into
the ZODB, if you lose your data, you also lose your configuration.</p>

<p>This is where GenericSetup comes in to save the day. You can still
make all your configuration changes in the Plone site or through the
ZMI. Then when you are ready you can export these settings using the
portal_setup tool.</p>

<p>GenericSetup was introduced in Plone 2.5 to help replace the use of
customization policies and the quick installer. The old methods relied
on the user to write Python code to set up their product or site.&nbsp;
When the API of the tools and objects changed the install and uninstall
methods would also have to be changed. GenericSetup gives us a way to
deal with the settings that we want to import and export and not have
to worry about the API changing over time.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                8.2.
                GenericSetup Profiles
            </h1>

            <p class="documentDescription">How to setup a GenericSetup profile</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.2.1.
                What is a profile?
            </h1>

            <p class="documentDescription">Information on what a GenericSetup profile is for</p>
    
            <div>
                
                    <p>A
GenericSetup profile is a preset configuration of a site, defined on
the filesystem. This configuration can consist on a broad variety of
settings, including roles and permissions mappings, skin layers order,
site properties...</p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.2.2.
                Profile types
            </h1>

            <p class="documentDescription">Information about the different types of GenericSetup profiles</p>
    
            <div>
                
                    <div><p>GenericSetup has two kinds of profiles that you can create. A <strong>base profile</strong>
is a profile that defines the basis for the site configuration.&nbsp;
In Plone the base profile is the "plone" profile from the CMFPlone
product. A base profile is not typically something that product
developers needs to deal with.&nbsp; There can only be one base profile
in use, when you create a new Plone site the base profile is applied
for you.&nbsp; The base profile will setup a default set of import and
export steps along with a default configuration for each.</p>

<p>The second type of profile is an <strong>extension profile</strong>.
An extension profile is what allows us to build on top of the base
profile. When you create a new product, theme or policy package you
will register extension profiles to build on top of the existing
configuration. Extension profiles also allow you to define new import
and export steps that other extension profiles can use.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.2.3.
                Registering a profile
            </h1>

            <p class="documentDescription">Learn how to register a profile</p>
    
            <div>
                
                    <div><p>GenericSetup
profiles are registered via ZCML. The registration is typically done in
the configure.zcml of your package. Let's register a default profile
for our example my.package</p>

<pre>&lt;configure
    xmlns="http://namespaces.zope.org/zope"
    xmlns:genericsetup="http://namespaces.zope.org/genericsetup"
    i18n_domain="my.package"&gt;

  &lt;genericsetup:registerProfile
      name="default"
      title="My Package"
      directory="profiles/default"
      description="Default profile for My Package"
      provides="Products.GenericSetup.interfaces.EXTENSION"
      /&gt;

&lt;/configure&gt;
</pre>

<p>This is what we would see in the configure.zcml of my.package.&nbsp;
Let's examine what each of the attributes of the registerProfile
directive mean.</p>

<dl><dt>name </dt><dd>The name is how GenericSetup will identify your
profile.&nbsp; The full profile id is
"profile-&lt;package_name&gt;:&lt;profile_name&gt;", in our case
profile-my.package:default </dd><dt>title </dt><dd>The title of the
profile will show up in the portal_setup tool when you select what
profile you want to import. The title may also be used in the
portal_quickinstaller if it picks up the profile as the install profile
for your package. </dd><dt>directory </dt><dd>The directory attribute
is the relative path to the folder containing the profile
information.&nbsp; The directory name is conventionally the same as the
profile name. </dd><dt>description </dt><dd>The description gives a brief summary of what the profile is used for. </dd><dt>provides </dt><dd>The
provides attribute tells GenericSetup what kind of profile you are
registering. For almost all cases you will be registering an extension
profile to extend Plone's base profile. </dd><dt><br></dt></dl></div>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                8.3.
                Using GenericSetup Efficiently
            </h1>

            <p class="documentDescription">Tips about getting the most out of GenericSetup</p>
    
            <div>
                
                    <div><p>Once
you have your GenericSetup profile set up you'll need to start adding
import files into it. It is common for people to think that they have
to write all the XML by hand. This should almost never be the case.</p>

<h2>Change and export</h2>

<p>The easiest way to to make changes with GenericSetup is to make the
changes in your site and then export the corresponding step. Let's
start with a very basic example, changing the MailHost settings so that
we can send out mail.</p>

<p>Go to the ZMI (http://yourplonesite:8080/manage) and find the <em>MailHost </em>object in the Plone site root. Enter the configuration data for your mail provider. Now go to <em>portal_setup</em> and click on the <em>Export</em> tab. Click the checkbox next to the MailHost import step and then on the <em>Export selected steps</em> button.</p>

<p>A targz bundle with the XML declarations of this exported import
step will be generated and downloaded. Note you can select as many
import steps as necessary or even export all steps directly so you have
a complete snapshot of the configuration of the your site.<br><em></em></p>

<h2>Trimming down the export</h2>

<p>When you export settings from from GenericSetup, you will get more
than what you changed. It's a very good idea to trim down the export
file to only have the specific items that you changed. If you don't
trim down the file then you will inadvertently override a change that
is made in another profile.</p>

<p>A common example is the <em>propertiestool.xml</em> export. This exports the properties in the <em>portal_properties</em> tool. Let's say you have modified the <em>default_language</em> property in <em>portal_properties/site_properties</em>
and you want to save it for your policy product. If you go to
portal_setup and export the Plone Properties, the generated
propertiestool.xml will more than 100 lines long.</p>

<p>Since you have only modified a property and you're using a extension
profile, you only have to keep the configuration data for this property.</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;object name="portal_properties" meta_type="Plone Properties Tool"&gt;
 &lt;object name="site_properties" meta_type="Plone Property Sheet"&gt;
  &lt;property name="default_language" type="string"&gt;en&lt;/property&gt;
 &lt;/object&gt;
&lt;/object&gt;</pre>

<h2>Play well with others</h2>

<p>When writing Plone add-ons you need to be aware of how your profile is going to interact with other add-ons and custom packages.</p>

<p>By default existing settings are purged before applying settings
from base profiles. Extension profiles are applied in update mode.</p>

<p>However, you can use the <em>purge="True"</em> and <em>purge="False"</em> directives to override the default behavior. If <em>True</em> the existing settings of the current object are always purged, if <em>False</em> they are not purged.</p>

<p>For example, the declarations in the propertiestool.xml in an extension profile:</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;object name="portal_properties"&gt;
    &lt;object name="navtree_properties"&gt;
        &lt;property name="metaTypesNotToList" type="lines" <strong>purge="False"</strong>&gt;
           &lt;element value="Promotion"/&gt;
        &lt;/property&gt;
    &lt;/object&gt;
&lt;/object&gt;</pre>

<p>will append the <em>Promotion</em> type to the list of content types
not to list in the navigation trees, leaving the rest of them intact,
whereas, in the same extension profile</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;object name="portal_properties"&gt;
    &lt;object name="navtree_properties"&gt;
        &lt;property name="metaTypesNotToList" type="lines" purge="True"&gt;
           &lt;element value="Promotion"/&gt;
        &lt;/property&gt;
    &lt;/object&gt;
&lt;/object&gt;</pre>

<p>would remove all previous elements from the mentioned list and let <em>Promotion</em> alone.</p>

<h2>User editable settings</h2>

<p>Another thing to take into consideration is the fact that some of
the properties or settings that you are importing can be changed by the
end user. The most common of these properties would be the site title.
The end user can easily change this setting by going to the Plone
control panel.</p>

<p>Be careful not to place a setting like this in a profile that runs
when your product is re-installed. This could lead to the end users'
changes being wiped out each time. You can place these settings in
another profile that can be run on the initial creation of the site.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                8.4.
                GenericSetup Reference
            </h1>

            <p class="documentDescription">Information about how each import/export step handles the data given to it</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.1.
                Actions
            </h1>

            <p class="documentDescription">Information about action import and export</p>
    
            <div>
                
                    <div><p>GenericSetup
can export the actions that are set up in each of the action providers.
When you export the actions step then you will be given an <code>actions.xml</code> file. Here is an excerpt from the <code>actions.xml</code> file.</p>

<pre><code>&lt;?xml version="1.0"?&gt;

&lt;object name="portal_actions" meta_type="Plone Actions Tool"

   xmlns:i18n="http://xml.zope.org/namespaces/i18n"&gt;



 &lt;action-provider name="portal_workflow"/&gt;

 &lt;action-provider name="portal_types"/&gt;

 &lt;action-provider name="portal_actions"/&gt;



 &lt;object name="document_actions" meta_type="CMF Action Category"&gt;



  &lt;object name="print" meta_type="CMF Action" i18n:domain="plone"&gt;

   &lt;property name="title" i18n:translate=""&gt;Print this&lt;/property&gt;

   &lt;property name="description" i18n:translate=""&gt;&lt;/property&gt;

   &lt;property name="url_expr"&gt;string:javascript:this.print();&lt;/property&gt;

   &lt;property name="icon_expr"&gt;string:$portal_url/print_icon.png&lt;/property&gt;

   &lt;property name="available_expr"&gt;&lt;/property&gt;

   &lt;property name="permissions"&gt;

    &lt;element value="View"/&gt;

   &lt;/property&gt;

   &lt;property name="visible"&gt;True&lt;/property&gt;

  &lt;/object&gt;



  &lt;!-- more actions here --&gt;



 &lt;/object&gt;

&lt;/object&gt;

</code></pre>

<p>Here we can see that there are three different things being defined
here. First is the list of action providers as defined in the <code>portal_actions</code> tool. Each <code>action-provider</code> element provides the <code>name</code> of the tool or object that provides the actions. In the following example the types tool is being set up.</p>

<pre><code>&lt;action-provider name="portal_types"/&gt;

</code></pre>

<p>The next element that you see is the <code>document_actions</code>. This is an action category in the <code>portal_actions</code> tool. Each action category is a folder of actions. You can see that the category is defined as follows.</p>

<pre><code>&lt;object name="document_actions" meta_type="CMF Action Category"&gt;

  &lt;!-- contained actions here --&gt;

&lt;/object&gt;

</code></pre>

<h2>Action Objects</h2>

<p>Inside the action category are the actions. In our example above we were looking at the <code>print</code> action. Here is the action.</p>

<pre><code>  &lt;object name="print" meta_type="CMF Action" i18n:domain="plone"&gt;

   &lt;property name="title" i18n:translate=""&gt;Print this&lt;/property&gt;

   &lt;property name="description" i18n:translate=""&gt;&lt;/property&gt;

   &lt;property name="url_expr"&gt;string:javascript:this.print();&lt;/property&gt;

   &lt;property name="icon_expr"&gt;string:$portal_url/print_icon.png&lt;/property&gt;

   &lt;property name="available_expr"&gt;&lt;/property&gt;

   &lt;property name="permissions"&gt;

    &lt;element value="View"/&gt;

   &lt;/property&gt;

   &lt;property name="visible"&gt;True&lt;/property&gt;

  &lt;/object&gt;

</code></pre>

<p>The object element has a name of <code>print</code>, this is the id of the action. We know that this object is an action because its <code>meta_type</code> is <code>CMF Action</code>. Inside of the action object we can see the properties for that action. These correspond to the form that we see in the ZMI.</p>

<p>Each property consists of the <code>name</code> and the value inside the element. Let's say we wanted to add a description to the <code>print</code> action. We would modify the <code>description</code> property as follows.</p>

<pre><code>&lt;property name="description"&gt;Print the current page&lt;/property&gt;

</code></pre>

<h3>Permissions</h3>

<p>The permissions property accepts multiple elements. If you want
multiple permissions you could add multiple elements to the permissions
property as follows.</p>

<pre><code>&lt;property name="permissions"&gt;

 &lt;element name="Modify portal content"/&gt;

 &lt;element name="Manage portal"/&gt;

&lt;/property&gt;

</code></pre>

<p>The <code>name</code> of each element is the name of the permission
as seen on the security tab or on the action form in the ZMI. Of
course, the easiest way to modify these settings is to change them in
the ZMI and then export. This way there is no guess work involved.</p>

<h3>Visible</h3>

<p>The <code>visible</code> property is a boolean. This means it has a
slightly different syntax. If you want the action to show up then you
would set it to <code>True</code>.</p>

<pre><code>&lt;property name="visible"&gt;True&lt;/property&gt;

</code></pre>

<p>And of course, if you want to hide it then you would set the value to <code>False</code>.</p>

<pre><code>&lt;property name="visible"&gt;False&lt;/property&gt;

</code></pre>

<p>Please note that hiding an action affects only the UI and won't
disable it. It will still be accessible using the associated URL.</p>

<h2>Removing Action Objects</h2>

<p>You can remove actions and action categories via the <code>actions.xml</code>. First let's see how to remove a particular action. In the following example we will remove the <code>print</code> action.</p>

<pre><code>&lt;object name="print" remove="True"/&gt;

</code></pre>

<p>Since we are removing the action, all we need to do is define the <code>name</code> and add the <code>remove</code> attribute. Here is what our <code>actions.xml</code> would look like if we were to remove that action.</p>

<pre><code>&lt;?xml version="1.0"?&gt;

&lt;object name="portal_actions"&gt;

 &lt;object name="document_actions"&gt;

  &lt;object name="print" remove="True"/&gt;

 &lt;/object&gt;

&lt;/object&gt;

</code></pre>

<p>We could do the same for the whole category with the following.</p>

<pre><code>&lt;?xml version="1.0"?&gt;

&lt;object name="portal_actions"&gt;

 &lt;object name="document_actions" remove="True"/&gt;

&lt;/object&gt;

</code></pre></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.2.
                Catalog
            </h1>

            <p class="documentDescription">Information about the import and export of catalog indexes, metadata and settings.</p>
    
            <div>
                
                    <div><p>The Catalog Tool is the tool that Plone uses for indexing and searching content. Check the <a class="external-link" href="http://plone.org/documentation/manual/developer-manual/developer-manual/indexing-and-searching">Indexing and Searching section of the Developer Manual</a> for more information about how the Catalog Tool works.<br>Imagine
you've created an 'Apartment' content-type using Archetypes with a
field called 'address'. To index the address of each apartment so to be
able to search by this field, create a <em>catalog_tool.xml</em> file in your extension profile with the following content:</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;object name="portal_catalog" meta_type="Plone Catalog Tool"&gt;
&nbsp; &lt;index name="address" meta_type="FieldIndex"&gt;
&nbsp;&nbsp;&nbsp; &lt;indexed_attr value="getAddress" /&gt;
&nbsp; &lt;/index&gt;
&nbsp; &lt;column value="a_field" /&gt;
&lt;/object&gt;
</pre>

<p>The first line after the xml declaration specifies the type of
object GenericSetup is dealing with: the Plone Catalog Tool, with id <em>portal_catalog</em>.<br>The
'index' node will create a new index of the type 'meta_type' with the
name specified. You can find a list of the available meta-types, as
well as the differences between them in the <a class="external-link" href="http://docs.zope.org/zope2/zope2book/SearchingZCatalog.html">Searching and Categorizing Content section of The Zope Book</a>.<br>The
'indexed_attr' node specifies the name of the attribute or method that
will be called in each content object to index its values. This is
useful, for example, if you want to create an index named 'Address'
from the values returned by the <em>getAddress()</em> method.<br>The
'column' node will register a new column in the metadata table of the
Plone Catalog Tool, so to include it in the returned brains.<br>Some
index types has different properties which can be set up using
'property' and 'extra' nodes. For example, the default 'modified' index
in Plone is registered with the following code:</p>

<pre>&lt;index name="modified" meta_type="DateIndex"&gt;
 &lt;property name="index_naive_time_as_local"&gt;True&lt;/property&gt;
&lt;/index&gt;
</pre>

<p>Here, the property specifies that the time stored will be the local time instead of the UTC time.<br>Another example is the default 'SearchableText' field:</p>

<pre>&lt;index name="SearchableText" meta_type="ZCTextIndex"&gt;
&nbsp; &lt;indexed_attr value="SearchableText"/&gt;
&nbsp; &lt;extra name="index_type" value="Okapi BM25 Rank"/&gt;
&nbsp; &lt;extra name="lexicon_id" value="plone_lexicon"/&gt;
&lt;/index&gt;
</pre>

<p>&nbsp;Here, the <em>index_type</em> attribute specifies the ranking
strategy for the index. For searches in text indexes, the results are
returned in order of relevancy - the algorithm used to order the
results is the ranking strategy. The available ranking stragegies are <em>Okapi BM25 Rank</em> and <em>Cosine Measure</em>. See <a class="external-link" href="http://docs.zope.org/zope2/zope2book/SearchingZCatalog.html#sorting">The sorting subsection of the Searching and Categorizing Content section of The Zope Book</a> for details on this.</p>

<p>The <em>lexicon_id</em> specifies the lexicon used for the text
index. Lexicons process and store
the words from the text and help in processing queries, for example,
turning the text into lowercase or removing very common words in a
language like "the" or "and". See <a class="external-link" href="http://docs.zope.org/zope2/zope2book/SearchingZCatalog.html#lexicons">The Lexicons subsection of the Searching and Categorizing Content section of The Zope Book</a> for details on this.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.3.
                Control Panel
            </h1>

            <p class="documentDescription">Information about the import and export of the Control Panel settings</p>
    
            <div>
                
                    <div><p>The
controlpanel.xml file keeps the information about the different
configuration dialogs available for the different users, including
members and site managers.</p>

<p>An excerpt of the the Plone controlpanel.xml file showing the general syntax follows:</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;object name="portal_controlpanel" meta_type="Plone Control Panel Tool"
    xmlns:i18n="http://xml.zope.org/namespaces/i18n" i18n:domain="plone"&gt;
 ...
 &lt;configlet title="Change Password" action_id="MemberPassword" appId="Plone"
    category="Member" condition_expr="python:member.canPasswordSet()"
    icon_expr="string:$portal_url/lock_icon.png"
    url_expr="string:${portal_url}/password_form" visible="True"
    i18n:attributes="title"&gt;
  &lt;permission&gt;Set own password&lt;/permission&gt;
 &lt;/configlet&gt;
 ...
&lt;/object&gt;
</pre>

<p>

Each configuration dialog is called a <em>configlet</em>. The different attributes available are:</p>

<dl><dt>title </dt><dd>The human readable text to be shown in the Plone interface.</dd><dt>action_id </dt><dd>A unique identifier for the configlet. </dd><dt>appId </dt><dd>An
application identifier for the configlet. This application id can be
shared by more than one configlet and can be useful, for example, to
remove all configlets related to a certain application in one go.</dd><dt>category </dt><dd>A
category id to specify the area of the Plone interface where the
configlet should be shown. Using the Plone category will cause it to be
shown in the main site setup configuration panel, while the Member
category will make it show in the list of configuration options for the
account of the user logged in.</dd><dt>condition_expr </dt><dd>A TALES
expression to control if the configlet is available or not. In the
example above, the Change Password configlet will only be available if
the current user can actually change her password.<br></dd><dt>icon_expr </dt><dd>&nbsp;The
URL of the icon for the configlet in TALES, to be shown in the Plone
interface where applicable. Leave empty if there isn't any icon
associated.<br></dd><dt>url_expr </dt><dd>The URL of the configlet dialog, i.e. the view or form the user should use to perform the configuration changes. </dd><dt>visible </dt><dd>Controls if the configlet will be shown or not. Useful if you want to disable a configlet temporarily for any reason.<br></dd></dl><p>The <em>&lt;permission&gt;</em> nodes inside the <em>&lt;configlet&gt;</em> one specify the neccessary permissions to use the configlet.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.4.
                Component Registry
            </h1>

            <p class="documentDescription">Information about component registration with GenericSetup.</p>
    
            <div>
                
                    <div><p>To register an (Zope3-like) utility local to your Plone site you can use a <em>componentregistry.xml</em> file in your profile. <br>Imagine
you write an utility that connects to an external Internet video
streaming service like YouTube, sending and receiving data using the
API provided by them. Since you can only have a single simultaneus
connection, you need an singleton utility to look up and use. Each site
(you have more than one in the same instance) has its own login
account, so you need to register the utility locally instead of
globally.<br>Let's say that your utility provides the <em>yourcompany.video.interfaces.IExternalVideo</em> interface, and it's implemented in the <em>yourcompany.video.ExternalVideo.ExternalVideo</em> class. Write the following code into your <em>componentregistry.xml</em> file:</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;componentregistry&gt;
&nbsp; &lt;utilities&gt;
&nbsp;&nbsp;&nbsp; &lt;utility
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interface="yourcompany.video.interfaces.IExternalVideo"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; factory="yourcompany.video.ExternalVideo.ExternalVideo"
&nbsp;&nbsp;&nbsp; /&gt;
&nbsp; &lt;/utilities&gt;
&lt;/componentregistry&gt;
</pre>

<p>The utility will be registered upon the installation of the product.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.5.
                Factory Tool
            </h1>

            <p class="documentDescription">Information about the Factory tool settings import and export.</p>
    
            <div>
                
                    <div><p>Use the <em>factorytool.xml</em>
import steps to include new types into the Plone Factory Tool&nbsp;
when creating new Archetypes content-types. This is needed because
Archetypes needs the content to be already created before validating
it. In order to avoid broken objects in the site, they're first created
in a place called <em>portal factory</em> and moved to the desired place later after they've been validated.<br>Imagine you've created the <em>Cat</em> content-type and want to register a factory for it. Just create a <em>factorytool.xml</em> file for your extension profile with the following contents:</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;object name="portal_factory" meta_type="Plone Factory Tool"&gt;
&nbsp; &lt;factorytypes&gt;
&nbsp;&nbsp;&nbsp; &lt;type portal_type="Cat"/&gt;
&nbsp; &lt;/factorytypes&gt;
&lt;/object&gt;
</pre>

<p>Check the <a class="external-link" href="http://plone.org/documentation/manual/developer-manual/developer-manual/archetypes">Archetypes Developer Manual</a> for more info about how to create content-types.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.6.
                MailHost
            </h1>

            <p class="documentDescription">Information about the import and export of MailHost settings.</p>
    
            <div>
                
                    <div><p>Use this step to configure the MailHost tool to match your SMTP server settings. This example should speak for himself:</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;object name="MailHost" meta_type="Secure Mail Host" 
    smtp_host="smtp.mydomain.tld"
&nbsp;&nbsp;&nbsp; smtp_port="25" 
    smtp_pwd="secret123" smtp_uid="myusername@mydomain.tld"/&gt;
</pre>

<p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.7.
                Metadata
            </h1>

            <p class="documentDescription">Info about GenericSetup metadata</p>
    
            <div>
                
                    <div><p>GenericSetup profiles can define a <code>metadata.xml</code>
file with some metadata about that particular profile. The contents are
straight forward and don't need much explanation. Here is an example.</p>

<pre><code>&lt;?xml version="1.0"?&gt;

&lt;metadata&gt;

  &lt;description&gt;This is the profile description&lt;/description&gt;

  &lt;version&gt;1&lt;/version&gt;

  &lt;dependencies&gt;

    &lt;dependency&gt;profile-my.package:default&lt;/dependency&gt;

    &lt;dependency&gt;profile-collective.foo:default&lt;/dependency&gt;

  &lt;/dependencies&gt;

&lt;/metadata&gt;

</code></pre>

<p>There are three pieces to the <code>metadata.xml</code> file. We will go into more detail for each piece here.</p>

<h2>Description</h2>

<p>First there is the <code>description</code> element. This is where you can give a brief explanation of the profile.</p>

<pre><code>&lt;description&gt;My package's default installation profile&lt;/description&gt;

</code></pre>

<h2>Version</h2>

<p>Next is the <code>version</code> element. This tells GenericSetup
what the version of the profile is. The version number will be used to
run upgrade steps. Upgrade steps only run between the given version
numbers. The <code>version</code> will be a whole number that is incremented when the profile has been changed. Here is an example.</p>

<pre><code>&lt;version&gt;42&lt;/version&gt;

</code></pre>

<p>In Plone 3.1 the practice of using the GenericSetup profile version
as a fall back for the QuickInstaller version was deprecated. The
QuickInstaller version will be taken from your product's version
instead.</p>

<h2>Dependencies</h2>

<p>You can define profile dependencies via the <code>metadata.xml</code> file. When your profile is run, the <code>dependencies</code>
that are listed will be run first. You can define as many dependencies
as you like. If you wanted your profile to depend on the fictitious <code>my.package</code> profile named <code>default</code> then you would have the following in your <code>metadata.xml</code>.</p>

<pre><code>&lt;dependencies&gt;

  &lt;dependency&gt;profile-my.package:default&lt;/dependency&gt;

&lt;/dependencies&gt;

</code></pre>

<p>The format for the profile entries are <code>profile-&lt;package_name&gt;:&lt;profile_name&gt;</code>. Here is an example of what an egg in the <code>Products</code> namespace would look like.</p>

<pre><code>&lt;dependencies&gt;

  &lt;dependency&gt;profile-Products.MyPloneProduct:default&lt;/dependency&gt;

&lt;/dependencies&gt;

</code></pre>

<p>See the <a title="GenericSetup Profiles" class="internal-link" href="http://plone.org/documentation/manual/developer-manual/generic-setup/genericsetup-profiles">profile reference</a> page for more details about GenericSetup profiles.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.8.
                Portlets
            </h1>

            <p class="documentDescription">Information about the import and export of portlets</p>
    
            <div>
                
                    <div><p>The <em>portlets.xml</em> file lets you register portlets and portlet managers. For more info about the portlets infrastructure, check the <a class="external-link" href="http://plone.org/documentation/manual/developer-manual/developer-manual/portlets">Portlets chapter of the Developer Manual</a>.</p>

<p>Let's see an excerpt of the Plone portlets.xml file:</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;portlets
    xmlns:i18n="http://xml.zope.org/namespaces/i18n"
    i18n:domain="plone"&gt;
 ...
 &lt;portletmanager 
   name="plone.leftcolumn" 
   type="plone.app.portlets.interfaces.ILeftColumn"
   /&gt;
 ...
 &lt;portlet 
   addview="portlets.News"
   title="News"
   description="A portlet which can render a listing of recent news"
   i18n:attributes="title;
                    description"
   &gt;
   &lt;for interface="plone.app.portlets.interfaces.IColumn" /&gt; 
   &lt;for interface="plone.app.portlets.interfaces.IDashboard" /&gt;  
 &lt;/portlet&gt;
&lt;/portlets&gt;
</pre>

<p>The <em>&lt;portletmanager /&gt;</em> node registers a portlet manager. The available attributes are:</p>

<dl><dt>name</dt><dd>The name of the utility providing the IPortletManager interface which will be instantiated.<br></dd><dt>type </dt><dd>A marker interface that can be used to install



particular portlets only for particular types of portlet managers later.<br></dd></dl><p>The <em>&lt;portlet&gt;</em> node registers a portlet. The available attributes are:</p>

<dl><dt>addview </dt><dd>Somewhat confusing, should match the portlet name as registered in ZCML.<br></dd><dt>title and description </dt><dd>Human friendly text to be shown in the Plone user interface. </dd></dl><p>The <em>&lt;for /&gt;</em> nodes inside the <em>&lt;portlet&gt;</em> one specify the interfaces of



the type of portlet managers that this portlet is suitable for.</p>

<p>The</p>

<pre>&lt;portlet addview="portlets.BBB" 

&nbsp;&nbsp;&nbsp;      title="Foo" 

         description="Foo" 

         for="plone.app.portlets.interfaces.IColumn" /&gt;
</pre>

<p>syntax to specify the allowed portlet manager interfaces was deprecated in Plone 3.1 and won't work in Plone 4.</p>

<h3>Assigning portlets</h3>

<p>You can assign portlets to certain parts of the site upon product installation using Generic Setup too. For example:</p>

<pre> &lt;assignment
     manager="plone.rightcolumn"
     category="context"
     key="/"
     type="portlets.News"
     name="news"
     visible="1"
     /&gt;

</pre>

<p>The <em>visible</em> attribute was introduced in Plone 4. If not
present or equal to "1", the portlet will be shown. If it's equal to
"0", it will be hidden.</p>

<p>You can use the insert-after and insert-before attributes matching an existing assignment or all them with "*". For example:</p>

<pre> &lt;assignment
     insert-before="events"
     manager="plone.rightcolumn"
     category="context"
     key="/"
     type="portlets.News"
     name="news"
     /&gt;
</pre>

<p>will insert the <em>news</em> portlet just before the <em>events</em> one.</p>

<p>You can also remove a certain assignment:</p>

<pre> &lt;assignment
     remove="True"
     manager="plone.rightcolumn"
     category="context"
     key="/"
     type="portlets.News"
     name="news"
     /&gt;
</pre>

<p>Or remove (purge)all the assignments from a certain manager:</p>

<pre> &lt;assignment
     purge="True"
     manager="plone.rightcolumn"
     category="context"
     key="/"
     /&gt;
</pre>

<p>The <em>key</em> attribute matches "/" for site-wide portlets and an
absolute Zope path for context-wide ones. For example, if you want to
remove all assignments from <em>Plone/news</em>, use:</p>

<pre> &lt;assignment
     purge="True"
     manager="plone.rightcolumn"
     category="context"
     key="/Plone/news"
     /&gt;</pre>

<p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.9.
                Properties
            </h1>

            <p class="documentDescription">Information about the import and export of property sheets.</p>
    
            <div>
                
                    <div><p>GenericSetup exports two kinds of property files by default. The <kbd>properties.xml</kbd> contains the properties set at the root of your Plone site. The <kbd>propertiestool.xml</kbd> contains all of the property sheets that are in the <kbd>properties_tool</kbd>. Both of these use the same syntax that will be described here. See the <a class="external-link" href="http://plone.org/documentation/manual/developer-manual/developer-manual/plone-properties/">Properties Reference</a> for more detailed information about what these properties do.</p>

<p>The <kbd>propertiestool.xml</kbd> is split into a section for each property sheet.</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;object name="portal_properties" meta_type="Plone Properties Tool"&gt;
 &lt;object name="navtree_properties" meta_type="Plone Property Sheet"&gt;
   &lt;!-- nav properties here --&gt;
 &lt;/object&gt;

 &lt;object name="site_properties" meta_type="Plone Property Sheet"&gt;
   &lt;!-- site properties here --&gt;
 &lt;/object&gt;

 &lt;object name="custom_property_sheet" meta_type="Plone Property Sheet"&gt;
   &lt;property name="title" type="string"&gt;Custom Properties&lt;/property&gt;
   
   &lt;!-- custom_property_sheet props here --&gt;
 &lt;/object&gt;
&lt;/object&gt;</pre>

<p>The property export handles all of the property sheet types. Single value properties are in the following format.</p>

<pre>&lt;property name="property_id" type="property_type"&gt;property_value&lt;/property&gt;</pre>

<p>Where the <kbd>property_id</kbd> is the id that the property will have in the property sheet and the <kbd>property_value</kbd> is the value that the property gets set to. Here are a couple of examples.</p>

<pre>&lt;property name="special_name" type="string"&gt;This is special&lt;/property&gt;
&lt;property name="magic_number" type="int"&gt;3&lt;/property&gt;</pre>

<p>However, there are a couple of exceptions to this behavior.</p>

<h2>Boolean</h2>

<p>Boolean properties can be set as follows:</p>

<pre>&lt;property name="has_truth" type="boolean"&gt;true&lt;/property&gt;
&lt;property name="has_truth" type="boolean"&gt;True&lt;/property&gt;
&lt;property name="has_truth" type="boolean"&gt;TRUE&lt;/property&gt;
&lt;property name="has_truth" type="boolean"&gt;Yes&lt;/property&gt;
&lt;property name="has_truth" type="boolean"&gt;1&lt;/property&gt;</pre>

<p>The values True, Yes and 1 will end up being true, these are case insensitive. Any other value will be taken as False.</p>

<pre>&lt;property name="has_truth" type="boolean"&gt;anything besides true yes or 1 here&lt;/property&gt;</pre>

<h2>Lines</h2>

<p>Multi valued properties are known as <kbd>lines</kbd> properties. Here is an example of a <kbd>grocery_list</kbd> property with three values.</p>

<pre>&lt;property name="grocery_list" type="lines"&gt;
  &lt;element value="beer"/&gt;
  &lt;element value="chips"/&gt;
  &lt;element value="salsa"/&gt;
&lt;/property&gt;</pre>

<p>Each <kbd>&lt;element&gt;</kbd> will become an item in the lines property.</p>

<p>If you want to update existing lines properties then you need to understand the <kbd>purge</kbd> option. If you want to add to the list then you will put <kbd>purge="false"</kbd> as follows:</p>

<pre>&lt;property name="grocery_list" type="lines" purge="false"&gt;
  &lt;element value="wine"/&gt;
  &lt;element value="steak"/&gt;
&lt;/property&gt;</pre>

<p>Now the property will contain the following:</p>

<pre>beer
chips
salsa
wine
steak</pre>

<p>If the <kbd>purge</kbd> option is not explicitly set (it defaults to <kbd>true</kbd>) or if it is set to <kbd>true</kbd>, then you would get this:</p>

<pre>wine
steak</pre>

<h2>Date</h2>

<p>A date property is similar to the string property but interprets the value as a <kbd>DateTime</kbd>.</p>

<pre>&lt;property name="day_of_infamy" type="date"&gt;December 7, 1941&lt;/property&gt;</pre></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.10.
                Resource Registries
            </h1>

            <p class="documentDescription">Information about the import and export of resource registry settings.</p>
    
            <div>
                
                    <div><p>This step let's you register CSS, KSS and JavaScript resources into the the corresponding registries, defining them in <em>cssregistry.xml</em>, <em>kssregistry.xml</em> and <em>jsregistry.xml</em>, respectively.</p>

<p>Let's see an example with the CSS registry. This step lets you register stylesheets in the <em>portal_css</em>
tool. This tool is a site-wide registry providing interesting features
like conditional inclusion, caching, merging or compression. Check the <a class="external-link" href="http://plone.org/documentation/manual/developer-manual/theme-reference/page/css/resource-registries">Resource Registries section in the Theming Manual</a> for more info about them.<br>An example registration in the cssregistry.xml file would be:</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;object name="portal_css" meta_type="Stylesheets Registry"&gt;
&nbsp;&lt;stylesheet title="" cacheable="True" compression="safe" cookable="True"
&nbsp;&nbsp;&nbsp;&nbsp; enabled="1" id="pro_members.css" media="screen"
&nbsp;&nbsp;&nbsp;&nbsp; expression="not: portal/portal_membership/isAnonymousUser"
&nbsp;&nbsp;&nbsp;&nbsp; rel="stylesheet" rendering="import" 
&nbsp;&nbsp;&nbsp;&nbsp; insert-before="ploneCustom.css"
&nbsp;&nbsp;&nbsp;&nbsp; /&gt;
&lt;/object&gt;
</pre>

<p>This code will slide in the <em>pro_members.css</em> stylesheet just before the <em>ploneCustom.css</em> one (so overriding its values if there are any collisions) when the user is not anonymous.<br>Check the <a class="external-link" href="http://plone.org/documentation/manual/developer-manual/theme-reference/page/css/resource-registries">Resource Registries section of the Theming Manual</a> for more info about the different options (XML attributes) available.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.11.
                Roles and Permissions
            </h1>

            <p class="documentDescription">Information about the import and export of roles and permissions.</p>
    
            <div>
                
                    <div><p>You can create roles and modify permissions using the <code>rolemap.xml</code> GenericSetup

import step. For more information on roles and permissions see the <a title="Understanding permissions and security" class="internal-link" href="http://plone.org/documentation/manual/tutorial/understanding-permissions">Permissions and roles</a> tutorial.</p>

<p>Here is an example of what you will see when you export the rolemap step.</p>

<pre><code>&lt;?xml version="1.0"?&gt;

&lt;rolemap&gt;



  &lt;roles&gt;

    &lt;role name="Anonymous"/&gt;

    &lt;role name="Authenticated"/&gt;

    &lt;role name="Contributor"/&gt;

    &lt;role name="Editor"/&gt;

    &lt;role name="Manager"/&gt;

    &lt;role name="Member"/&gt;

    &lt;role name="Owner"/&gt;

    &lt;role name="Reader"/&gt;

    &lt;role name="Reviewer"/&gt;

  &lt;/roles&gt;



  &lt;permissions&gt;



    &lt;permission name="View" acquire="True"&gt;

      &lt;role name="Contributor"/&gt;

      &lt;role name="Editor"/&gt;

      &lt;role name="Reader"/&gt;

    &lt;/permission&gt;



    &lt;!-- more permissions here --&gt;



  &lt;/permissions&gt;



&lt;/rolemap&gt;

</code></pre>

<p>The <code>rolemap.xml</code> is split into two sections, <code>roles</code> and <code>permissions</code>. Imagine you want to create a new <code>ProUser</code> role in your site. Here is what the <code>rolemap.xml</code> would look like.</p>

<p class="callout">NOTE: The <code>rolemap.xml</code> <strong>must</strong> include both the <code>&lt;roles&gt;</code> and <code>&lt;permissions&gt;</code> tags, even if they have empty contents - otherwise the step will error out.</p>

<pre><code>&lt;?xml version="1.0"?&gt;

&lt;rolemap&gt;

  &lt;roles&gt;

    &lt;role name="ProUser"/&gt;

  &lt;/roles&gt;

  &lt;permissions/&gt;

&lt;/rolemap&gt;

</code></pre>

<p>You can assign the newly created role to existing permissions in the system. Here we add the <code>ProUser</code> role to the <code>View</code> permission.</p>

<pre><code>&lt;permission name="View" acquire="True"&gt;

  &lt;role name="Reader"/&gt;

  &lt;role name="Editor"/&gt;

  &lt;role name="Contributor"/&gt;

  &lt;role name="ProUser"/&gt;

&lt;/permission&gt;

</code></pre>

<p>Note that if you assign roles to a permission using the <code>&lt;permission&gt;</code>

directive, it will overwrite existing assignments, so remember to include

all the already assigned roles when doing so. The following would change the <code>View</code> permission to only be applied to the <code>ProUser</code> role.</p>

<pre><code>&lt;permission name="View" acquire="True"&gt;

  &lt;role name="ProUser"/&gt;

&lt;/permission&gt;

</code></pre>

<p>The <code>acquire</code> attribute tells Zope wether or not to inherit the permissions from above. The default is <code>False</code>.</p>

<h2>Removing roles and permissions</h2>

<p>The rolemap handler does not handle the removal of roles or
permissions. You would need to write Python code in order to remove a
role from the system via your GenericSetup profile.</p>

<p>Permissions are typically created at startup via the package's __init__.py or being defined in zcml.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.12.
                Sharing
            </h1>

            <p class="documentDescription">Info about the sharing tab GenericSetup handler</p>
    
            <div>
                
                    <div><p>The
GenericSetup handler for the sharing tab, new in Plone 4, allows you to
define new local role labels. When you add a new role to your site you
may want to assign that role from the sharing tab. The <code>sharing.xml</code> allows us to do this.</p>

<p class="callout">The sharing export handler does not export the
globally registered utilities. This means that by default there will be
no entries in the <code>sharing.xml</code> when it is exported.</p>

<p>As an example, let's say you've added a new role named <code>CopyEditor</code> (see the <a title="Roles and Permissions" class="internal-link" href="http://plone.org/documentation/manual/developer-manual/generic-setup/reference/roles-and-permissions">rolemap</a> reference for more details on adding roles) to your site. This would not be present on the <code>sharing</code> page. To make it show up you would add the following to your <code>sharing.xml</code>.</p>

<pre><code>&lt;?xml version="1.0"?&gt;

&lt;sharing xmlns:i18n="http://xml.zope.org/namespaces/i18n"

         i18n:domain="my.package"&gt;

  &lt;role

      id="CopyEditor"

      title="Can edit copy"

      permission="Manage portal"

      i18n:attributes="title"

      /&gt;

&lt;/sharing&gt;

</code></pre>

<p>The <code>sharing.xml</code> file has a container named <code>sharing</code>. Inside of the <code>sharing</code> tag there are <code>role</code> tags. Here is an explanation of what the attributes of the <code>role</code> tag will do.</p>

<dl><dt>id</dt>

<dd>The <code>id</code> is the name of the role that you have defined</dd>

<dt>title</dt>

<dd>The <code>title</code> is what will show on the sharing tab to represent this local role</dd>

<dt>permission</dt>

<dd>The <code>permission</code> is the Zope permission needed to assign the local role</dd></dl><h2>Modify existing sharing tab entries<br></h2>

<p>You can change existing sharing tab entries by redefining them. All you need to define is the <code>id</code>, then you can change the <code>title</code> and the <code>permission</code> to your liking. In this example we change the <code>title</code> to something funny and probably confusing to the end user. The <code>permission</code> can also be changed, here we changed it to <code>View</code>. If you had access to the sharing page and had the <code>View</code> permission on the item then you could assign the local role.</p>

<p class="callout">NOTE: When changing the stock local role entries you
are creating a local utility that overrides the globally registered
utility.</p>

<pre><code>&lt;?xml version="1.0"?&gt;

&lt;sharing&gt;

  &lt;role

      id="Reviewer"

      title="Content Overlord"

      permission="View"

      /&gt;

&lt;/sharing&gt;

</code></pre>

<h2>Removing entries</h2>

<p>To remove an entry, just use the <em>remove</em> attribute on a <em>&lt;role /&gt;</em> node:</p>

<pre><code>&lt;role

  remove="True"

  id="Reviewer"

  /&gt;</code></pre>

<p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.13.
                Skins
            </h1>

            <p class="documentDescription">Information about the import and export of skin paths</p>
    
            <div>
                
                    <div><p>For some background about skin layers, read the <a class="external-link" href="http://plone.org/documentation/manual/theme-reference/buildingblocks/skin/layers">Skin Layers section of the Theming Manual</a>.</p>

<p>Let's take the <em>skins.xml</em> file of <em>plonetheme.sunburst</em> skins.xml as example:</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;object name="portal_skins" default_skin="Sunburst Theme"&gt;

 &lt;object name="sunburst_images"
    meta_type="Filesystem Directory View"
    directory="plonetheme.sunburst:skins/sunburst_images"/&gt;
 &lt;object name="sunburst_templates"
    meta_type="Filesystem Directory View"
    directory="plonetheme.sunburst:skins/sunburst_templates"/&gt;
 &lt;object name="sunburst_styles"
    meta_type="Filesystem Directory View"
    directory="plonetheme.sunburst:skins/sunburst_styles"/&gt;
 &lt;object name="sunburst_js"
    meta_type="Filesystem Directory View"
    directory="plonetheme.sunburst:skins/sunburst_js"/&gt;    

 &lt;skin-path name="Sunburst Theme" based-on="Plone Default"&gt;
  &lt;layer name="sunburst_images"
     insert-after="custom"/&gt;
  &lt;layer name="sunburst_templates"
     insert-after="sunburst_images"/&gt;
  &lt;layer name="sunburst_styles"
     insert-after="sunburst_templates"/&gt;
  &lt;layer name="sunburst_js"
     insert-after="sunburst_styles"/&gt;     
 &lt;/skin-path&gt;

&lt;/object&gt;
</pre>

<p>Here, the line</p>

<pre>&lt;object name="portal_skins" default_skin="Sunburst Theme"&gt;</pre>

<p>indicates we're dealing with the <em>portal_skins</em> object and sets Sunburst Theme as the default active theme. The later has the same effect of selecting <em>Sunburst Theme</em> in the <em>Themes</em> control panel dialog or in the <em>portal_skins</em> properties in the ZMI.</p>

<p>The <code>&lt;object /&gt;</code> nodes define a new Filesystem Directory View (FSDV):</p>

<dl><dt>name </dt><dd>The name of the skin layer as shown in the
contents of portal_skins in the ZMI. It usually matches the name of the
directory in the filesystem, but doesn't neccessarily have to. </dd><dt>meta_type </dt><dd>Will always be Filesystem Directory View in this context.<br></dd><dt>directory </dt><dd>&nbsp;The path to the directory in the filesystem in the format

<pre>[yournamespace].[your theme name]:skins/[Your Skin Directory Name]</pre>

</dd></dl><p>&nbsp;</p>

<p>Then, we insert the the previously defined skin layers in a theme. First, we specify we're dealing with the skin named <em>Sunburst Theme</em>, which will inherit the list and order of skins layers from <em>Plone Default</em>:</p>

<pre> &lt;skin-path name="Sunburst Theme" based-on="Plone Default"&gt;</pre>

<p>Next, we insert each skin layer in the appropiate place.</p>

<pre>  &lt;layer name="sunburst_images" insert-after="custom"/&gt;</pre>

<p>You can use the <em>insert-after</em> and <em>insert-before</em>
attributes with the name of an already present skin layer to control
the placement. If you want to insert a layer at the top of the stack,
use</p>

<pre>  &lt;layer name="layer_name" insert-before="*"/&gt;</pre>

<p>If you don't specify any <em>insert-after</em> nor <em>insert-before</em> attributes, the specified layer will be inserted at the bottom of the stack.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.14.
                Structure
            </h1>

            <p class="documentDescription">Information about the import of site structure</p>
    
            <div>
                
                    <div><p>Despite
this import step have been available since long time ago, the syntax is
complex and underdocumented, so it's not recommended for use anymore.
Use a custom import step with a Python handler and invokeFactory,
getters and setters, etc. instead.</p>

<p>If you're still interested on this, you can check the article<span id="parent-fieldname-title" class="kssattr-atfieldname-title kssattr-templateId-widgets/string kssattr-macro-string-field-view"> <a class="external-link" href="http://plone.org/documentation/kb/add-a-folder-structure-to-your-product">Make a product install a folder structure in the site</a>.</span></p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.15.
                Tools
            </h1>

            <p class="documentDescription">Information about tools import</p>
    
            <div>
                
                    <div><p>This
import step registers a set of tools in the site, instantiating them at
the root if they're missing or their class doesn't match the existing
one.</p>

<p>The syntax of the toolset.xml file is very simple:</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;tool-setup&gt;
 ...
 &lt;required tool_id="portal_catalog"
           class="Products.CMFPlone.CatalogTool.CatalogTool"/&gt;
 ...
&lt;/tool-setup&gt;
</pre>

<p>This snippet would instantiate the famous <code>portal_catalog</code> object of the <code>Products.CMFPlone.CatalogTool.CatalogTool</code> class.</p>

<p>The most noticeable difference between a tool and an utility (in the
Zope sense) is that tools are persistent objects that exist as content
in the ZODB, while utilities are registered either site-wide or
locally, but they are not listed as normal content and you won't be
able to find them as such using the ZMI.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.16.
                Types
            </h1>

            <p class="documentDescription">Information about the import and export of content-types information.</p>
    
            <div>
                
                    <p>Check the <a class="external-link" href="http://plone.org/documentation/manual/developer-manual/developer-manual/archetypes/a-simple-at-product/installing-and-using">Content-types chapter of the Developer Manual</a>.</p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.17.
                Viewlets
            </h1>

            <p class="documentDescription">Information about the import and export of viewlet settings</p>
    
            <div>
                
                    <div><p>You can insert, sort and hide viewlets inside viewlet managers using a <code>viewlets.xml</code> file.</p>

<p>You will find detailed information about this in the tutorial <a class="external-link" href="http://plone.org/documentation/kb/customizing-main-template-viewlets">Customizing the viewlets in main_template</a>.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                8.4.18.
                Workflow
            </h1>

            <p class="documentDescription">Information about the workflow importer and exporter</p>
    
            <div>
                
                    <div><p>You
can export and import workflows and their settings this import step.
The syntax is rather complex and verbose, so we recommend you to create
and adjust the workflow settings manually, export them from the
portal_setup tool as described in <a href="http://plone.org/documentation/manual/developer-manual/using-genericsetup-efficiently"><span class="state-published">Using GenericSetup Efficiently</span></a> and editing the resulting XML later.</p>

<p>You can declare and bind/unbind content-types to a certain workflow chain in the <em>workflow.xml</em> file. For example, the following snippet would register a workflow named <em>my_workflow</em>, set it as the default one, and unbind the <em>My Type</em> content-type from any workflow (including the default one):</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;object name="portal_workflow" meta_type="Plone Workflow Tool"&gt;
 &lt;object name="my_workflow" meta_type="Workflow"/&gt;
 &lt;bindings&gt;
  &lt;default&gt;
   &lt;bound-workflow workflow_id="my_workflow" /&gt;
  &lt;/default&gt;
  &lt;type type_id="My Type" /&gt;
 &lt;/bindings&gt;
&lt;/object&gt;

</pre>

<p>If you want to bind a particular content-type to a particular workflow, use the syntax:</p>

<pre>&lt;bindings&gt;
...
  &lt;type type_id="My Type"&gt;
    &lt;bound-workflow workflow_id="my_workflow"/&gt;
  &lt;/type&gt;
...
&lt;/bindings&gt;
</pre>

<p>Once you've declared a workflow, you need to define it. Inside a folder named <em>workflows</em> in your profile, add a folder matching the name of your declared workflow and then a <em>definition.xml</em> file inside it. In our example above, <em>profiles/default/workflows/my_workflow/definition.xml</em>.</p>

<p>An short and simple definition.xml file looks like:</p>

<pre>&lt;?xml version="1.0"?&gt;
&lt;dc-workflow workflow_id="myt_workflow"
             title="My Content"
             state_variable="review_state"
             initial_state="draft"&gt;


 &lt;!-- Permissions being managed --&gt;
 &lt;permission&gt;View&lt;/permission&gt;


 &lt;!-- Workflow states, available transitions and permissions mapping --&gt;
 &lt;state state_id="draft" title="Draft"&gt;
  &lt;exit-transition transition_id="publish"/&gt;
  &lt;permission-map name="View" acquired="False"&gt;
   &lt;permission-role&gt;Editor&lt;/permission-role&gt;
   &lt;permission-role&gt;Contributor&lt;/permission-role&gt;
  &lt;/permission-map&gt;
 &lt;/state&gt;

 &lt;state state_id="published" title="Published"&gt;
  &lt;exit-transition transition_id="retract"/&gt;
  &lt;permission-map name="View" acquired="False"&gt;
   &lt;permission-role&gt;Anonymous&lt;/permission-role&gt;
   &lt;permission-role&gt;Member&lt;/permission-role&gt;
  &lt;/permission-map&gt;
 &lt;/state&gt;


 &lt;!-- Transitions between states, including guard conditions --&gt;
 &lt;transition transition_id="publish"
             title="Contributor publishes"
             new_state="published" trigger="USER"
             before_script="" after_script=""&gt;
  &lt;action url="%(content_url)s/content_status_
                    modify?workflow_action=publish"
          category="workflow"&gt;Publish&lt;/action&gt;

  &lt;guard&gt;
   &lt;guard-permission&gt;Publish content&lt;/guard-permission&gt;
  &lt;/guard&gt;
 &lt;/transition&gt;

 &lt;transition transition_id="retract"
             title="Contributor retracts"
             new_state="draft" trigger="USER"
             before_script="" after_script=""&gt;
  &lt;action url="%(content_url)s/content_status_
                    modify?workflow_action=retract"
          category="workflow"&gt;Retract&lt;/action&gt;

  &lt;guard&gt;
   &lt;guard-permission&gt;Retract content&lt;/guard-permission&gt;
  &lt;/guard&gt;
 &lt;/transition&gt;

&lt;/dc-workflow&gt;

</pre>

<p>First, we define the permissions we're going to manage (<em>View</em> in this case).</p>

<p>Later, we define the different available states, together with their role mapping and available transitions.</p>

<p>Last, we define what each transition should perform. An user must
have the indicated guard permission in the context to trigger the
associated transition.</p></div>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-1">

            <h1>
                9.
                Properties Reference
            </h1>

            <p class="documentDescription">Code snippets and info for using the Plone API</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-2">

            <h1>
                9.1.
                Site Root Properties
            </h1>

            <p class="documentDescription">Properties managed by the site root object.</p>
    
            <div>
                
                    <div><p>Although
Plone uses other property managers for configuration, the Plone
portal&nbsp;object&nbsp;(site root) is a property manager itself,
including a set of important properties for site setup.</p>

<p>They can be set using <a class="external-link" href="http://plone.org/tutorial/genericsetup">GenericSetup</a> throught the <code>properties.xml</code> file. Check the <code>CMFPlone/profiles/default/properties.xml</code> file for an example.</p>

<p> To learn how to access properties programatically, see <a class="external-link" href="http://plope.com/Books/2_7Edition/AppendixB.stx#0-13">The Zope Book, Appendix B: API Reference</a>.</p>

















































































<table class="listing"><thead><tr><th>Name</th><th>Default Value<br></th><th>Type<br></th><th>description<br></th></tr></thead><tbody><tr><td>title <br></td><td>&nbsp;</td><td>string<br></td><td>The title of the Plone site. This title will be used in the&nbsp;<code>&lt;title&gt;</code> HTML tag.<br></td></tr><tr><td>description</td><td>&nbsp;</td><td>text <br></td><td>

<p>The description of the site. It will be used to include the description in the HTML header using the tag&nbsp;<code>&lt;meta&gt;</code>, if the site is configured to expose DC meta tags. See <code>exposeDCMetaTags</code>.</p>

</td></tr><tr><td>default_page<br></td><td>front-page</td><td>string<br></td><td>Sets the default page of the Plone site.</td></tr><tr><td>selectable_views</td><td>folder_listing,<br>news_listing<br></td><td>lines<br></td><td>The views available to be used as default pages for the Plone site.<br></td></tr><tr><td>email_from_address</td><td>&nbsp;</td><td>string<br></td><td>The email used as the sender for messages sent by Plone, including account activation and password resetting emails.</td></tr><tr><td>email_from_name</td><td>Site Administrator<br></td><td>string<br></td><td>The name included in email messages sent by Plone.</td></tr><tr><td>validate_email</td><td>True</td><td>boolean<br></td><td>Activates
email validation for user registration. If enabled, users receive an
email upon registration, with a URL to a temporary form, requesting
them to enter the new password.</td></tr><tr><td>email_charset</td><td>utf-8</td><td>string<br></td><td>The charset used when sending email messages.<br></td></tr><tr><td>enable_permalink</td><td>False</td><td>boolean<br></td><td>A CMF property&nbsp; not used in Plone.</td></tr></tbody></table><p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                9.2.
                Site-wide Properties
            </h1>

            <p class="documentDescription">Site-wide properties available at the properties tool.</p>
    
            <div>
                
                    <div><p>Plone uses the properties tool's sheet <code>site_properties</code> to store some site-wide settings.</p>

<p>They can be set using <a class="external-link" href="http://plone.org/documentation/tutorial/genericsetup">GenericSetup</a> throught the <code>propertiestool.xml</code> file. Check the <code>CMFPlone/profiles/default/propertiestool.xml</code> file for an example.</p>

























































































































































































































































































































<table class="listing"><thead><tr><th>Title</th><th>Default Value</th><th>Type</th><th>Desccription</th></tr></thead><tbody><tr><td>allowAnonymousViewAbout<br></td><td>False</td><td>boolean</td><td>If False, only logged-in users will be able to view information about who created an item and when it was modified.</td></tr><tr><td>localTimeFormat</td><td>%b %d, %Y</td><td>string</td><td>Format
to be used when displaying dates in short notation (e.g. without hours
and minutes). It should follow the syntax as specified by Python's
time.strftime. To know more, read the Python <a class="external-link" href="http://docs.python.org/library/time.html#time.strftime">documentation for time.strftime</a>.</td></tr><tr><td>localLongTimeFormat</td><td>%b %d, %Y %I:%M %p<br></td><td>string</td><td>Similar to <code>localTimeFormat</code> but including more information (e.g. with hours and minutes).</td></tr><tr><td>default_language</td><td> en<br></td><td> string</td><td>The default language for the site's content.</td></tr><tr><td>default_charset</td><td> utf-8</td><td>string</td><td>The default charset in which the site's content is encoded.</td></tr><tr><td>use_folder_tabs</td><td> <br></td><td> lines</td><td>List of content types that should include the 'contents' view. Not used in Plone 3.</td></tr><tr><td>ext_editor</td><td> False</td><td> boolean</td><td>If
True, an icon will be made visible on each page, to allow the user to
edit content using an external editor. This requires an additional
application called <a href="http://plope.com/software/ExternalEditor/">ExternalEditor</a> to be installed on the client workstation.</td></tr><tr><td>available_editors</td><td> TinyMCE<br>None</td><td> lines</td><td>List of available editors that the users are able to select.</td></tr><tr><td>allowRolesToAddKeywords</td><td> Manager<br>Reviewer</td><td> lines</td><td>Roles allowed to add new keywords/categories when editing content.</td></tr><tr><td>auth_cookie_length</td><td>	0</td><td> int</td><td>Length of the authorization cookie.</td></tr><tr><td>calendar_starting_year</td><td> 2001</td><td> int</td><td>The starting year to show in the calendar widget.</td></tr><tr><td>calendar_future_years_available</td><td> <br></td><td> int</td><td>The number of future years, after the current year, to show in the calendar widget.</td></tr><tr><td>invalid_ids</td><td> actions</td><td> lines</td><td>Invalid ids for content created in Plone.</td></tr><tr><td>default_page</td><td> index_html<br>index.html<br>index.htm<br>FrontPage</td><td> lines</td><td>Attributes or object ids  that, if available, should be used as default page.</td></tr><tr><td>search_results_description_length</td><td><br></td><td>int</td><td>Length of the description to be included in search results listings. For items with a longer description, text will be cropped.</td></tr><tr><td>ellipsis</td><td> ...</td><td> string</td><td>The ellipsis that will be added at the end of the cropped description in search results listings.</td></tr><tr><td>typesLinkToFolderContentsInFC</td><td> Large Plone<br>Folder Folder</td><td> lines</td><td>Content types that should link to its 'contents' view, when listed in a 'contents' view.</td></tr><tr><td>visible_ids</td><td> False</td><td> boolean</td><td>If
True, users will be able to set the ids for content items. If False,
the ids will be generated automatically based on the normalized version
of the title.</td></tr><tr><td>exposeDCMetaTags</td><td> False</td><td> boolean</td><td>If enabled, Plone will include Dublin Core metadata information at the HTML header.</td></tr><tr><td>types_not_searched</td><td> ATBooleanCriterion<br>ATDateCriteria<br>...<br></td><td> lines</td><td>List of content types whose instances won't be retrieved by search results.</td></tr><tr><td>disable_folder_sections</td><td>False</td><td>boolean</td><td>

<p>If True, the automatic site sections (portal tabs) generation will be disabled, so only actions in category <code>portal_tabs</code> will be included.</p>

</td></tr><tr><td>disable_nonfolderish_sections</td><td> False</td><td> boolean</td><td>If True, only folderish content items will be listed as site sections.</td></tr><tr><td>typesUseViewActionInListings</td><td> Image<br>File</td><td> lines</td><td>List of content types that should link to its 'view' action in content listings.</td></tr><tr><td>verify_login_name</td><td> True</td><td> boolean</td><td>If
True, when login fails, users will get a specific answer, telling their
login name field wasn't found or the password was incorrect. If False,
users will only be told that the login failed.</td></tr><tr><td>many_users</td><td> False</td><td> boolean</td><td>If
True, the Plone user management screen will be optimized for a large
amount of users, allowing only to search instead of listing them all.</td></tr><tr><td>many_groups</td><td> False</td><td> boolean</td><td>If
True, the Plone group management screen will be optimized for a large
amount of groups, allowing only to search instead of listing them all.</td></tr><tr><td>enable_livesearch</td><td> True</td><td> boolean</td><td>When set to True, the global search box will show live results. Only for browsers supporting javascript.</td></tr><tr><td>default_page_types</td><td> Topic</td><td> lines</td><td>The list of content types that can be used as default pages, so the user is able to selected them using the 'display' menu.</td></tr><tr><td>use_folder_contents</td><td> ...<br></td><td> lines</td><td>Complementary to <code>use_folder_tabs</code>. Not used in Plone 3.</td></tr><tr><td>forbidden_contenttypes</td><td>text/structured<br>text/restructured<br>...<br></td><td> lines</td><td>
List of forbidden mimetypes that are not available in text areas.
Mimetypes removed from this list will be available in text areas (e.g.
page body). Only if the user isn't using Kupu, since it only supports
HTML.<br></td></tr><tr><td>default_contenttype</td><td> text/html<br></td><td>string</td><td> Default mimetype for text areas.<br></td></tr><tr><td>enable_sitemap</td><td>False<br></td><td>boolean</td><td>Expose sitemap.xml.gz in the portal root according to the <a class="external-link" href="http://www.sitemaps.org/">sitemaps.org</a> standard.<br></td></tr><tr><td>number_of_days_to_keep</td><td> 7</td><td> int</td><td>Indicates how many days of undo history should be kept.<br></td></tr><tr><td>enable_inline_editing</td><td> True</td><td> boolean</td><td>If
True, enables the inline editing feature, allowing users to click
directly in the field value and change it without accessing the edit
form. Only for browsers supporting Javascript.</td></tr><tr><td>enable_link_integrity_checks</td><td> True</td><td> boolean</td><td>If True, users will get warnings when they delete or move content that is linked from other content available in the site.</td></tr><tr><td>webstats_js</td><td> <br></td><td> string</td><td>Intended
for code snippets from external providers. It will be included in the
rendered HTML, as entered, near the end of the page. It can be used to
enable web statistics support from external providers (e.g. Google
Analytics).</td></tr><tr><td>external_links_open_new_window</td><td>False</td><td>string</td><td>If True, all external links in the content region will open in a new window. Only for browsers supporting Javascript.</td></tr><tr><td>icon_visibility</td><td> enabled</td><td> string</td><td>Possible
values are 'disabled', 'authenticated' or 'enabled'. If 'disabled',
content icons won't be shown in listings; if 'authenticated', content
icons will be visible only for authenticated users; if 'enabled'
content icons will be visible for all users.</td></tr></tbody></table><p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                9.3.
                Navigation Properties
            </h1>

            <p class="documentDescription">Navigation properties available at the properties tool.</p>
    
            <div>
                
                    <div><p>Plone site-wide navigation properties are stored at property tool's sheet <code>navtree_properties</code>.</p>

<p>They can be set using <a class="external-link" href="http://plone.org/tutorial/genericsetup">GenericSetup</a> throught the <code>propertiestool.xml</code> file. Check the <code>CMFPlone/profiles/default/propertiestool.xml</code> file for an example.</p>

































































































































<table class="listing"><thead><tr><th><br></th><th><br></th><th><br></th><th><br></th></tr></thead><tbody><tr><td>sortAttribute</td><td>getObjPositionInParent</td><td>string</td><td>Catalog index that will be used to sort navigation results.</td></tr><tr><td>sortOrder</td><td>asc</td><td>string</td><td>Sort order for navigation results.</td></tr><tr><td>sitemapDepth</td><td>3</td><td>int</td><td>Depth of the generated sitemap.</td></tr><tr><td>name</td><td><br></td><td>string</td><td>Name
for the navigation portlet. Not used in Plone 3, since navigation
portlets have their own configuration for each assignment.</td></tr><tr><td>root</td><td> /</td><td> string</td><td>Root of the navigation.</td></tr><tr><td>currentFolderOnlyInNavtree</td><td>False</td><td>boolean</td><td>If True, the navigation tree will only show the current folder and its children at all times. Not used in Plone 3.</td></tr><tr><td>includeTop</td><td>True</td><td>boolean</td><td>If True, the top (root) node will be included in the navigation tree. This is affected by the <code>topLevel</code> setting. Not used in Plone 3.</td></tr><tr><td>topLevel</td><td>0</td><td>int</td><td>An
integer value that specifies the number of folder levels below the site
root that must be exceeded before the navigation tree will display. Not
used in Plone 3.</td></tr><tr><td>bottomLevel</td><td>0</td><td>int</td><td>Specifies
how many folders should be included before the navigation tree stops. 0
means no limit. 1 only includes the root folder. Not used in Plone 3.</td></tr><tr><td>showAllParents</td><td>True</td><td>boolean</td><td>If True, the navigation tree will display all the parents of the current item. Not used in Plone 3.</td></tr><tr><td>idsNotToList</td><td><br></td><td>lines</td><td>Content ids that should be ignored by the navigation.</td></tr><tr><td>parentMetaTypesNotToQuery</td><td>Temp Folder<br>Large Plone Folder</td><td>lines</td><td>Meta types of parents that should be ignored by the navigation.</td></tr><tr><td>metaTypesNotToList</td><td><br></td><td>lines</td><td>Meta types that should be ignored by the navigation.</td></tr><tr><td>enable_wf_state_filtering</td><td>False</td><td>boolean</td><td>If set to True, the navigation results will be filtered by workflow state.</td></tr><tr><td>wf_states_to_show</td><td><br></td><td>lines</td><td>The list of workflow states to be shown in navigation. Works in conjunction with <code>enable_wf_state_filtering</code>.</td></tr></tbody></table><p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                9.4.
                portal_actions reference
            </h1>

            <p class="documentDescription">How to use the portal_actions tool programmatically</p>
    
            <div>
                
                    <div><h3 class="Subheading">Overview</h3><p>The <b>portal_actions</b> tool

is an object in the root directory of all Plone sites that provides

access to the various actions in the site.Â&nbsp; An action usually

manifests itself as link or a menu-item somewhere in the site.Â&nbsp;

For example, the tabs along the top of the Plone site ('Home',

'Products', etc..) are actions that are defined in the portal_actions

tool.<br></p><p></p><h3 class="Subheading">Class</h3><p>ActionsTool<br></p><h3 class="Subheading">API Docs</h3><p></p><dl></dl><p></p><p><a href="http://api.plone.org/Plone/2.1.1/public/CMFCore.ActionsTool.ActionsTool-class.html" target="_self">http://api.plone.org/Plone/2.1.1/public/CMFCore.ActionsTool.ActionsTool-class.html</a> for the API docs of this class.</p>

<h2 class="Heading">Usage examples:</h2>

<h3 class="Subheading">Obtain actions available to current user:</h3>

<pre>from Products.CMFCore.utils import getToolByName<br>actions = getToolByName(context, 'portal_actions').listFilteredActions()<br></pre>

<p>In the above example actions would contain a dictionary of lists of 

dictionaries representing the actions available to the current

user.Â&nbsp; E.g.:<br></p>

<pre>{'site_actions': <br>    [<br>        {'category': 'site_actions', <br>         'available': True, <br>         'title': 'Small Text', <br>         'url': &lt;bound method ActionInfo._getURL of {...}&gt;, <br>         'name': 'Small Text', <br>         'visible': True, <br>         'allowed': True, <br>         'id': 'small_text', <br>         'permissions': ('View',)<br>        }, <br>        {'category': 'site_actions', <br>         'available': True, <br>         'title': 'Normal Text', <br>         'url': &lt;bound method ActionInfo._getURL of {...}&gt;, <br>         'name': 'Normal Text', <br>         'visible': True, <br>         'allowed': True, <br>         'id': 'normal_text', <br>         'permissions': ('View',)<br>        },<br>        ...<br>    ],<br> ...<br> 'portal_tabs':<br>     [<br>        {<br>         'category': 'portal_tabs', <br>         'available': True, <br>         'title': 'Home', <br>         'url': &lt;bound method ActionInfo._getURL of {...}&gt;, <br>         'name': 'Home', <br>         'visible': True, <br>         'allowed': True, <br>         'id': 'index_html', <br>         'permissions': ('View',)<br>        },<br>        ...<br>      ],<br> ... <br>}<br></pre>

<p>And given this example, it is trivial to obtain a list of actions in a particular category.<br></p>

<h3 class="Subheading">Obtain a list of the actions in a particular category:</h3>

<pre>from Products.CMFCore.utils import getToolByName<br>portal_tabs = getToolByName(context, 'portal_actions').listFilteredActions()['portal_tabs']<br></pre>

<p>In the above snippet, portal_tabs would contain a list of

dictionaries representing all of the actions with category

'portal_tabs'.Â&nbsp; E.g.:<br></p>

<pre>[<br>        {<br>         'category': 'portal_tabs', <br>         'available': True, <br>         'title': 'Home', <br>         'url': &lt;bound method ActionInfo._getURL of {...}&gt;, <br>         'name': 'Home', <br>         'visible': True, <br>         'allowed': True, <br>         'id': 'index_html', <br>         'permissions': ('View',)<br>        },<br><br>        {<br>         'category': 'portal_tabs', <br>         'available': True, <br>         'title': 'Products', <br>         'url': &lt;bound method ActionInfo._getURL of {...}&gt;, <br>         'name': 'Home', <br>         'visible': True, <br>         'allowed': True, <br>         'id': 'products', <br>         'permissions': ('View',)<br>        },       <br>        ...<br>],<br></pre><h3 class="Subheading">Iterating through actions in a TAL template:</h3><pre>&lt;ul&gt;<br>  &lt;tal:actions repeat="action python:context.portal_actions.listFilteredActionsFor(context)['portal_tabs']"&gt;<br>    &lt;li&gt;<br>      &lt;a tal:attributes="href action/url; title action/title;" tal:content="action/title"&gt;<br>        Action title<br>      &lt;/a&gt;<br>    &lt;/li&gt;<br>  &lt;/tal:actions&gt;<br>&lt;/ul&gt;<br></pre><p>The
above snippet creates an unordered list of links for the actions with
category portal_tabs.Â&nbsp; Its output would be something like:<br></p><ul><li>Home</li><li>Products</li><li>About</li><li>...</li></ul><p>Where each item is linked to its associated URL.<br></p><br></div>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-1">

            <h1>
                10.
                Internationalization (i18n) and localization (l10n)
            </h1>

            <p class="documentDescription">How to make your Plone product behave with different languages and cultures</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-2">

            <h1>
                10.1.
                Introduction
            </h1>

            <p class="documentDescription">Introduction to various i18n subsystems in Plone</p>
    
            <div>
                
                    <div><p>Plone has three different internationalization subsystems</p>
<ul class="simple"><li>Translating user interface text strings: <a class="reference external" href="http://pypi.python.org/pypi/zope.i18nmessageid">zope.i18nmessageid</a> package. This is translation work the developers do. Internally GNU <a class="reference external" href="http://docs.python.org/library/gettext.html">gettext</a> machinery is used.</li>
<li>Adapting locale specific settings for the site, like time format - <a class="reference external" href="http://pypi.python.org/pypi/plone.i18n/1.1a2">plone.i18n</a> package. This is translation work site integrators usually do.</li>
<li>Managing multilingual content - <a class="reference external" href="http://pypi.python.org/pypi/Products.LinguaPlone/">Products.Linguaplone</a> add-on product. This is translation work site editors usually do.</li>
</ul></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                10.2.
                Language negotiation
            </h1>

            <p class="documentDescription">How the current language of the viewed page is defined</p>
    
            <div>
                
                    <div><p>Each page view has a language associated with which is negotiated based on various factors. Negotiation is handled by <a class="reference external" href="https://svn.plone.org/svn/collective/PlacelessTranslationService/trunk/Products/PlacelessTranslationService/">PlacelessTranslationService</a> and <a class="reference external" href="http://pypi.python.org/pypi/plone.i18n">plone.i18n</a>
modules.</p>
<p>Several factors determine what is the current language:</p>
<ul class="simple"><li>Cookies (user chosen setting from the language selector)</li>
<li>Domain name: Top level domain name (TLD) like plone.fi for Finnish,
plone.se for Swedish or subdomain name like fi.plone.org for Finnish.</li>
<li>The language of the context: what function context.Language() returns. The user can set this on content metadata edit page.</li>
<li>Language headers send by the web browser</li>
</ul><p>Language is negotiated at the beginning of the page view.</p>
<div class="section" id="getting-the-current-language">
<h3>Getting the current language</h3>
<p>How to get the active language for the current context and HTTP request</p>
<pre class="literal-block">from Acquisition import aq_inner
from zope.component import getMultiAdapter

context = aq_inner(self.context)
portal_state = getMultiAdapter((context, self.request), name=u'plone_portal_state')

current_language = portal_state.language()
</pre>
</div></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                10.3.
                Translating text in code
            </h1>

            <p class="documentDescription">How to use message ids, gettext and context.translate() method</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                10.3.1.
                Introduction
            </h1>

            <p class="documentDescription"></p>
    
            <div>
                
                    <div><p>Internationalization
is a process to make your code locale and language aware. Usually this
means supplying translation files for text strings used in the code.</p>
<p>Plone internally uses UNIX standard <a class="reference external" href="http://www.gnu.org/software/gettext/">gettext</a>
tool to perform i18n.</p>
<p>Plone has two separate gettext subsystems for historical reasons</p>
<ul class="simple"><li>zope.i18n based using gettext standard locales/ folder structure</li>
<li>PlaceslessTranslationService and i18n/ folder based. Please do not use this for new products.</li>
</ul><p>Both use <a class="reference external" href="http://www.gnu.org/software/hello/manual/gettext/PO-Files.html">.po</a>
file format to describe translations.</p>
<p>Note that this chapter concerns only code-level translations. Content translations are
managed by Products.LinguaPlone add-on product.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                10.3.2.
                zope.i18n package
            </h1>

            <p class="documentDescription">The basics of zope.i18n  and locales/ folders</p>
    
            <div>
                
                    <div><p>zope.i18n package is Zope 3 way of doing gettext</p>
<ul class="simple"><li>Follows gettext best practices</li>
<li>Translations are stored in <em>locales</em> folder of your application. Example: <em>i18n/LC_MESSAGES/fi/your.app.po</em></li>
<li>Has zope.i18nmessageid package which is string-like class allowing storing translation domain
with translatable text strings easily</li>
<li><cite>.po</cite> files must be manually converted to <cite>.mo</cite> binary files every time the translations are updated. See more about this on i18ndude page.</li>
</ul><p>Plone uses only file path and name to search the translation
files. Information about translation domain and language in the .po
file headers is ignored.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                10.3.3.
                Marking translatable strings in code
            </h1>

            <p class="documentDescription"></p>
    
            <div>
                
                    <div><p>Each module declares its own MessageFactory which is a callable and marks strings with translation domain.
MessageFactory is declared at main __init__.py file of your package.</p>
<pre class="literal-block">from zope.i18nmessageid import MessageFactory

# your.app.package must match domain declaration in .po files
 yourAppMessageFactory = MessageFactory('your.app.package')
</pre>
<p>You also need to have the following ZCML entry:</p>
<pre class="literal-block">&lt;configure
    xmlns:i18n="http://namespaces.zope.org/i18n"&gt;

    &lt;i18n:registerTranslations directory="locales" /&gt;

&lt;/configure&gt;
</pre>
<p>After the set-up above you can use message factory to mark strings with translation domains.</p>
<p>i18ndude translation utilities seek underscore _ function to mark
translatable strings (gettext message ids). So i18ndude will harvest
all text from Python files which is inside _() function, no matter from
where the function is actually imported. Message ids must be unicode
strings.</p>
<pre class="literal-block">from your.app.package import yourAppMessageFactory as _

my_translatable_text = _(u"My text") # my_text is zope.
</pre>
<p>The object will still look like a string:</p>
<pre class="literal-block">&gt;&gt;&gt; my_translatable_text
u'Test'
</pre>
<p>But in reality it is zope.i18nmessageid.message.Message object:</p>
<pre class="literal-block">&gt;&gt;&gt; my_translatable_text.__class__
&lt;type 'zope.i18nmessageid.message.Message'&gt;

&gt;&gt;&gt; my_translatable_text.domain
'your.app.package'
</pre></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                10.3.4.
                Automatically translated message ids
            </h1>

            <p class="documentDescription">When messages are translated automatically and you don't need to call context.translate()</p>
    
            <div>
                
                    <div><p>Plone will automatically perform translation for message id objects which are outputted in page templates.</p>
<p>The following code would translate my_translateable_text to the native language
activated for the current page.</p>
<pre class="literal-block">&lt;span tal:content="view/my_translateable_text"&gt;
</pre>
<p>Note that since my_translateable_text is zope.i18nmessageid.message.Message containing
its own gettext domain information, the i18n:domain attribute in page templates does not
affect message ids declared through message factories.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                10.3.5.
                Manually translating message ids
            </h1>

            <p class="documentDescription">If you are outputting text outside page templates you need to make sure it runs through translate() function yourself</p>
    
            <div>
                
                    <div><p>If you need to manipulate translated text outside page templates, you need
to perform the final translation manually.</p>
<p>Translation always needs context (i.e. under which site translation
happens), as the active language and other preferences are read from
the HTTP request object
and site settings.</p>
<p>Translation can be performed using context.translate() method which all content objects inherit:</p>
<pre class="literal-block"># Create a message id which will be translated
msgid = _(u"My text")

# Use translate() function to get the final text string
translated = self.context.translate(msgid)

# translated value is now u"KÃ¤Ã¤nnetty teksti" (in Finnish)
</pre></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                10.3.6.
                Message ids in other files than Python source code
            </h1>

            <p class="documentDescription">Some other file formats support i18ndude directly</p>
    
            <div>
                
                    <div><p>There are also other message id markers in code outside Python domain</p>
<ul class="simple"><li>ZCML entries have their own mechanism (*.zcml files)</li>
<li>GenericSetup XML have their own mechanism (profiles/default/*.xml files)</li>
<li>TAL page templates have their own mechanism (*.pt files)</li>
</ul></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                10.3.7.
                String substitution in message ids
            </h1>

            <p class="documentDescription">How to translate text which contains parameters</p>
    
            <div>
                
                    <div><p>Translation string substitutions must be used when the final translated
message contains variable strings in it.</p>
<p>Plone content classes inherit translate() function which can be
used to get the final translated string.
It will use the currently activate language.
Translation domain will be taken from the msgid object
itself, which is string-like zope.i18nmessageid instance.</p>
<p>Message ids are immutable (read-only)
objects so you need to always create a new message id
if you use different variable substituion mappings.</p>
<p>Python code:</p>
<pre class="literal-block">from yourcompany.app import appMessageFactory as _

class SomeView(BrowserView):


    def do_stuff(self):

        msgid = _(u"search_results_found_msg", default=u"Found ${results} results", mapping={ u"results" : len(self.contents)})

        # Use inherited translate() function to get the final text string
        translated = self.context.translate(msgid)

        # Show the final result count to the user as a portal status message
        messages = IStatusMessage(self.request)
        messages.addStatusMessage(translated, type="info")
</pre>
<p>Corresponding .po file entry:</p>
<pre class="literal-block">#. Default: "Found ${results} results"
#: ./browser/accommondationsummaryview.py:429
msgid "search_results_found_msg"
msgstr "LÃ¶ytyi ${results} majoituskohdetta"
</pre>
<p>For more information, see</p>
<ul class="simple"><li><a class="reference external" href="http://wiki.zope.org/zope3/TurningMessageIDsIntoRocks">http://wiki.zope.org/zope3/TurningMessageIDsIntoRocks</a></li>
</ul></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                10.3.8.
                PlacessTranslationService
            </h1>

            <p class="documentDescription">PlacelessTranslationService is another of two Plone translation subsystems</p>
    
            <div>
                
                    <div><p>PlacelessTranslationService is</p>
<ul class="simple"><li>Historic, being phased out</li>
<li>Stores .po files in <em>i18n</em> folder of your add-on product</li>
<li>Used for main "plone" translation gettext domain</li>
<li>Translation files are processed when Plone is restarted. Example: <em>i18n/yourapp-fi.po</em>.</li>
</ul></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                10.3.9.
                i18ndude
            </h1>

            <p class="documentDescription">i18ndude is a set of scripts to manage gettext translations with Zope</p>
    
            <div>
                
                    <div><p>i18ndude is developer command-line utility to manage .po and .mo files.</p>
<p>Usually you build our own shell script wrapper around i18ndude to automatize
generation of .mo files of your product .po files.</p>
<p>Examples</p>
<ul class="simple"><li><a class="reference external" href="http://pypi.python.org/pypi/i18ndude">i18ndude Python package</a></li>
<li><a class="reference external" href="http://maurits.vanrees.org/weblog/archive/2007/09/i18n-locales-and-plone-3.0">i18ndude example for Plone 3.0 and later</a></li>
<li><a class="reference external" href="http://blogs.ingeniweb.com/blogs/user/7/tag/i18ndude/">i18ndude example for Plone 2.5</a></li>
</ul><div class="section" id="setting-up-folder-structure-for-finnish-and-english">
<h3>Setting up folder structure for Finnish and English</h3>
<p>Example:</p>
<pre class="literal-block">mkdir locales
mkdir locales/fi
mkdir locales/en
mkdir locales/fi/LC_MESSAGES
mkdir locales/en/LC_MESSAGES
</pre>
</div>
<div class="section" id="creating-pot-base-file">
<h3>Creating .pot base file</h3>
<p>Example:</p>
<pre class="literal-block">i18ndude rebuild-pot --pot locales/mydomain.pot --create your.app.package .
</pre>
</div>
<div class="section" id="managing-po-files">
<h3>Managing .po files</h3>
<p>Example shell script to manage i18n files. Change CATALOGNAME to reflect the
actual package of your product:</p>
<pre class="literal-block">#!/bin/sh
#
# Shell script to manage .po files.
#
# Run this file in the folder main __init__.py of product
#
# E.g. if your product is yourproduct.name
# you run this file in yourproduct.name/yourproduct/name
#
#
# Copyright 2009 Twinapex Research http://www.twinapex.com
#

# Assume the product name is the current folder name
CURRENT_PATH=`pwd`
CATALOGNAME="yourproduct.app"

# List of languages
LANGUAGES="en fi"

# Create locales folder structure for languages
install -d locales
for lang in $LANGUAGES; do
    install -d locales/$lang/LC_MESSAGES
done

# Rebuild .pot
i18ndude rebuild-pot --pot locales/$CATALOGNAME.pot --create $CATALOGNAME .

# Compile po files
for lang in $(find locales -mindepth 1 -maxdepth 1 -type d); do

    if test -d $lang/LC_MESSAGES; then

        PO=$lang/LC_MESSAGES/${CATALOGNAME}.po

        # Create po file if not exists
        touch $PO

        # Sync po file
        echo "Syncing $PO"
        i18ndude sync --pot locales/$CATALOGNAME.pot $PO

        # Compile .po to .mo
        MO=$lang/LC_MESSAGES/${CATALOGNAME}.mo
        echo "Compiling $MO"
        msgfmt -o $MO $lang/LC_MESSAGES/${CATALOGNAME}.po
    fi
done
</pre>
</div></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                10.3.10.
                Other resources
            </h1>

            <p class="documentDescription">Links to other material related to translating text in Plone code</p>
    
            <div>
                
                    <ul class="simple"><li><a class="reference external" href="http://reinout.vanrees.org/weblog/2007/12/14/translating-schemata-names.html">http://reinout.vanrees.org/weblog/2007/12/14/translating-schemata-names.html</a></li>
<li><a class="reference external" href="http://plone.org/products/archgenxml/documentation/how-to/handling-i18n-translation-files-with-archgenxml-and-i18ndude/view?searchterm=">http://plone.org/products/archgenxml/documentation/how-to/handling-i18n-translation-files-with-archgenxml-and-i18ndude/view?searchterm=</a></li>
<li><a class="reference external" href="http://dev.plone.org/plone/ticket/9089">http://dev.plone.org/plone/ticket/9089</a></li>
</ul></div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                10.4.
                Translating and creating multilingual content
            </h1>

            <p class="documentDescription">How to translate and handle multilingual content programmatically</p>
    
            <div>
                
                    <div><p>Content translations are handled by well-established <a class="reference external" href="http://plone.org/products/linguaplone">LinguaPlone add-on product</a>.</p>
<p>Each translation is its own Archetypes content object. Translations
are linked together through LinguaPlone catalogs. The base text is
called
<em>canonical</em> and all other translations are linked into this.</p>
<p>The base class for multilingual content is LinguaItem: <a class="reference external" href="http://svn.plone.org/svn/plone/LinguaPlone/tags/2.1.1/Products/LinguaPlone/examples/LinguaItem.py">http://svn.plone.org/svn/plone/LinguaPlone/tags/2.1.1/Products/LinguaPlone/examples/LinguaItem.py</a></p>
<div class="section" id="translating-content">
<h3>Translating content</h3>
<p>LinguaPlone contains some unit test code which shows how to create
translations. You can use context.addTranslation(language_code) and
context.getTranslation(language_code) methods.</p>
<p>Example:</p>
<pre class="literal-block">from Products.LinguaPlone.I18NBaseObject import AlreadyTranslated

try:
    object.addTranslation(lang)
except AlreadyTranslated:
    # Note: AlreadyTranslated is always risen if Products.Linguaplone is not installed
    pass

translated = object.getTranslation(lang)
</pre>
<p>For more information see</p>
<ul class="simple"><li><a class="reference external" href="http://svn.plone.org/svn/plone/LinguaPlone/tags/2.1.1/Products/LinguaPlone/tests/translate_edit.txt">http://svn.plone.org/svn/plone/LinguaPlone/tags/2.1.1/Products/LinguaPlone/tests/translate_edit.txt</a></li>
</ul></div>
<div class="section" id="querying-multi-lingual-content">
<h3>Querying multi-lingual content</h3>
<p>By default, LinguaPlone monkey-patches portal_catalog to return only
content queried in the current language of the page view. If you need
to refer to other language content in portal_catalog queries, you need
to pass a special parameter Language="all" to portal_catalog queries.</p>
<p>Example:</p>
<pre class="literal-block">for translation_search in self.portal_catalog.searchResults(Language='all')::
    pass
</pre>
</div></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                10.5.
                Site language settings
            </h1>

            <p class="documentDescription">How to change site language settings programmatically</p>
    
            <div>
                
                    <div><p>You can set site language in code:</p>
<pre class="literal-block"># Setup site langauge settings
portal = context.getSite()
ltool = portal.portal_languages
defaultLanguage = 'en'
supportedLanguages = ['en','es']
ltool.manage_setLanguageSettings(defaultLanguage, supportedLanguages, setUseCombinedLanguageCodes=False)
</pre>
<p>For unit testing, you need to run this in afterSetUp() after setting up the languages:</p>
<pre class="literal-block"># THIS IS FOR UNIT TESTING ONLY
# Normally called by pretraverse hook,
# but must be called manually for the unit tests
# Goes only for the current request
ltool.setLanguageBindings()
</pre>
<p>On vanilla Plone site (no LinguaPlone installed) using <em>profiles/default/propertiestool.xml</em>:</p>
<pre class="literal-block">&lt;object name="portal_properties" meta_type="Plone Properties Tool"&gt;
   &lt;object name="site_properties" meta_type="Plone Property Sheet"&gt;
      &lt;property name="default_language" type="string"&gt;en&lt;/property&gt;
   &lt;/object&gt;
&lt;/object&gt;
</pre>
<p>On Linguaplone enabled sites, your add-on product can use GenericSetup XML <em>profiles/default/portal_languages.xml</em></p>
<pre class="literal-block">&lt;?xml version="1.0"?&gt;
&lt;object&gt;
 &lt;default_language value="fi"/&gt;
 &lt;use_path_negotiation value="False"/&gt;
 &lt;use_cookie_negotiation value="True"/&gt;
 &lt;use_request_negotiation value="False"/&gt;
 &lt;use_cctld_negotiation value="False"/&gt;
 &lt;use_combined_language_codes value="False"/&gt;
 &lt;display_flags value="True"/&gt;
 &lt;start_neutral value="False"/&gt;
 &lt;supported_langs&gt;
  &lt;element value="en"/&gt;
  &lt;element value="fi"/&gt;
 &lt;/supported_langs&gt;
&lt;/object&gt;
</pre></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                10.6.
                Language selector
            </h1>

            <p class="documentDescription">Plone
comes with a language selector viewlet which you often want to
customize for your theme or your special language configuration</p>
    
            <div>
                
                    <div><p>There exist two different language selector viewlet bases for Plone</p>
<ul class="simple"><li>Viewlet from vanilla Plone</li>
<li>Viewlet from LinguaPlone - LinguaPlone has its own language
selector which replaces the default Plone selector if LinguaPlone is
installed</li>
</ul><div class="section" id="source-code-references">
<h3>Source code references</h3>
<ul class="simple"><li><a class="reference external" href="https://svn.plone.org/svn/plone/plone.app.i18n/trunk/plone/app/i18n/locales/browser/selector.py">https://svn.plone.org/svn/plone/plone.app.i18n/trunk/plone/app/i18n/locales/browser/selector.py</a></li>
<li><a class="reference external" href="https://svn.plone.org/svn/plone/plone.app.i18n/trunk/plone/app/i18n/locales/browser/languageselector.pt">https://svn.plone.org/svn/plone/plone.app.i18n/trunk/plone/app/i18n/locales/browser/languageselector.pt</a></li>
<li><a class="reference external" href="http://svn.plone.org/svn/plone/Products.LinguaPlone/tags/2.4/Products/LinguaPlone/browser/selector.py">http://svn.plone.org/svn/plone/Products.LinguaPlone/tags/2.4/Products/LinguaPlone/browser/selector.py</a></li>
</ul></div>
<div class="section" id="making-language-flags-point-to-different-domains">
<h3>Making language flags point to different domains</h3>
<p>It is often desirable to make the language selector
point to a different domains for different languages. For example,
search engines get confused by dynamic language switcher and will index
switching links, messing up your site search results.</p>
<p>Below is an example where different top level domain links are hard coded to the language selector template:</p>
<pre class="literal-block">&lt;tal:language
    tal:define="available view/available;
                languages view/languages;
                showFlags view/showFlags;"&gt;


    &lt;ul id="portal-languageselector"
        tal:condition="python:available and len(languages)&gt;=2"&gt;
        &lt;tal:language repeat="lang languages"&gt;
        &lt;li tal:define="code lang/code;
                        selected lang/selected"
            tal:attributes="class python: selected and 'currentLanguage' or '';"&gt;

                &lt;a href=""
                   tal:condition="python:code =='fi'"
                   tal:define="flag lang/flag|nothing;
                               name lang/name"
                   tal:attributes="href string:http://www.twinapex.fi;
                                   title name"&gt;
                    &lt;tal:flag condition="python:showFlags and flag"&gt;
                        &lt;img
                             width="14"
                             height="11"
                             alt=""
                             tal:attributes="src string:${view/portal_url}${flag};
                                             title python: name;
                                             class python: selected and 'currentItem' or '';" /&gt;
                    &lt;/tal:flag&gt;
                    &lt;tal:nonflag condition="python:not showFlags or not flag"
                                 replace="name"&gt;language name&lt;/tal:nonflag&gt;
                &lt;/a&gt;

                &lt;a href=""
                   tal:condition="python:code =='en'"
                   tal:define="flag lang/flag|nothing;
                               name lang/name"
                   tal:attributes="href string:http://www.twinapex.com;
                                   title name"&gt;
                    &lt;tal:flag condition="python:showFlags and flag"&gt;
                        &lt;img
                             width="14"
                             height="11"
                             alt=""
                             tal:attributes="src string:${view/portal_url}${flag};
                                             title python: name;
                                             class python: selected and 'currentItem' or '';" /&gt;
                    &lt;/tal:flag&gt;
                    &lt;tal:nonflag condition="python:not showFlags or not flag"
                                 replace="name"&gt;language name&lt;/tal:nonflag&gt;
                &lt;/a&gt;&amp;nbsp;

        &lt;/li&gt;
        &lt;/tal:language&gt;
    &lt;/ul&gt;
&lt;/tal:language&gt;
</pre>
</div></div>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-1">

            <h1>
                11.
                Users and Security
            </h1>

            <p class="documentDescription">How to manage who and how can access to different parts of your site.</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-2">

            <h1>
                11.1.
                Pluggable Authentication Service
            </h1>

            <p class="documentDescription">The
Pluggable Authentication Service (PAS), which is used by Plone 2.5 and
later for user management. This document is aimed towards
administrators who need to configure user management in a Plone site
and towards developers who are interested in PAS plugins.</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.1.
                Introduction
            </h1>

            <p class="documentDescription">The
Pluggable Authentication Service (PAS) is an alternative to the
standard Zope User Folder or the popular Group User Folder (GRUF). PAS
has a highly modular design, which is very powerful, but also a lot
harder to understand.</p>
    
            <div>
                
                    <p>PAS
is built around the concepts of interfaces and plugins: all possible
tasks related to user and group management and authentication are
described in separate interfaces. These interfaces are implemented by
plugins, which can be selectively enabled per interface.<br><br>Plone
uses PlonePAS, which extends PAS with a couple of extra plugin types
and which adds GRUF compatibility. Since PlonePAS extensions are rarely
needed and are subject to change in the next Plone releases this
tutorial will only focus on pure PAS features.<br></p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.2.
                Features and interfaces
            </h1>

            <p class="documentDescription">A
user folder such as PAS provides a number of different services: it
takes care of user authentication, it asks users to login if needed, it
allows you to search for users and groups.</p>
    
            <div>
                
                    <div><p>In
order to make both configuration and implementation simpler and more
powerful all these different tasks have been divided into different <i>interfaces</i>. Each interface describes how a specific feature, such as authenticating a user, has to be implemented.<br><br>Within PAS <i>plugins</i>
are used to provide those features. Plugins are small pieces of logic
which implement one or more functions as defined by these interfaces.</p><p>This separation is useful for different reasons:<br></p><ul><li>it
makes it possible to configure different aspects of the system
separately. For example how users authenticate (cookies, login forms,
etc.) can be configured separately from where user information is
stored (ZODB, LDAP, RADIUS, SQL, etc.). This flexibility makes it very
easy to tune the system to specific needs.</li><li>it makes it possible
for developers to write small pieces of code that only perform a single
task. This leads to code that is easier to understand, more testable
and better maintainable.<br></li></ul></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.3.
                The important interfaces
            </h1>

            <p class="documentDescription">PAS has a number of interfaces that are important  for everyone.</p>
    
            <div>
                
                    <div><p>

The most important interfaces that you may want to configure are:

</p><p>



</p><dl><dt>Authentication</dt><dd>

  Authentication plugins are responsible for authenticating a set of

  credentials. Usually that will mean verifying if a login name and password

  are correct by comparing them with a user record in a database such as the

  ZODB or an SQL database.

  </dd>



<dt>Extraction</dt>

<dd>

  Extraction plugins determine the credentials for a request. Credentials

  can take different forms such as a HTTP cookie, HTTP form data or the

  users IP address.



</dd><dt>Groups</dt>

<dd>

  These plugins determine of which group(s) a user (or group) is a member.

</dd>



<dt>Properties</dt>

<dd>

  Property plugins manage all properties for users. This includes the standard

  information such as the user's name and email address but can also be any

  other piece of data that you want to store for a user. Multiple properties

  plugins can be used in parallel, making it possible for example to use some

  information from a central system such as active directory while storing

  data specific for your Plone site in the ZODB

</dd>



<dt> User Enumeration</dt>

<dd>

  User enumeration plugins implement the searching logic for users.

</dd>

</dl></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.4.
                Configuring PAS
            </h1>

            <p class="documentDescription">There
is no Plone interface to configure PAS: you will need to use the Zope
Management Interface (ZMI). In the ZMI you will see a *acl_users*
folder in the site root. This is your PAS.</p>
    
            <div>
                
                    <div><p>If you open the<i> acl_users</i> folder you will see a number of different items. Each item is a PAS plugin, which implements some PAS functionality.<br><br><img title="The contents of a PAS user folder in the ZMI" src="developer-manual_archivos/image-preview_002.html"><br><br>There is one special item: the <i>plugins</i>
objects manages all administrative bookkeeping within PAS. It remembers
which interfaces are active for each plugin and in what order the
plugins should be called.<br><br>Let's take a look to see how this works. If you open the <i>plugins</i> object you will see a list of all the PAS interfaces, along with a short description of what they do.<br><br>We
will take a look at the extraction plugins. These plugins take care of
extracting the credentials such as your username and password from a
request. These credentials can then be used to authenticate the user.
If you click on the Extraction Plugins header you will see a screen
which shows the plugins which implement this interface and allows you
to configure which plugins will be used and in what order.<br><br><img title="Configuration for the extraction plugins." src="developer-manual_archivos/image-preview.html"><br><br>In the default Plone configuration there are two plugins enabled for this interface:<br></p><ul><li>the <i>credentials_cookie_auth</i> plugin can extract the login name and password from an HTTP cookie and HTTP form values from the login form or portlet</li><li>the <i>credentials_basic_auth</i> plugin can extract the login name and password from standard HTTP authentication headers.<br></li></ul><p>In
the default configuration the cookie plugin takes preference over the
basic authentication plugin. This means that credentials from a HTTP
cookie will be preferred over credentials form HTTP authentication
headers if both are present You can try this by first logging in using
standard HTTP authentication in the Zope root and then visiting your
Plone site and logging in with a different user there: you will see
that the new user is now the active user.<br><br>You can change the
order of the plugins by clicking on a plugin and moving it up or down
with the arrows. Using the left and right arrows you can enable and
disable a plugin for this interface.<br></p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.5.
                Configuring an individual PAS plugin
            </h1>

            <p class="documentDescription">In
addition to enabling and disabling plugins via the plugins object each
plugin can also have its own configuration. You can access this by
opening a plugin in the ZMI.</p>
    
            <div>
                
                    <p>Taking the <em>credentials_cookie_auth</em> as example again you will see the screen for the <em>Activate</em>
tab. This tab is mandatory and allows you to enable and disable PAS
interfaces for a plugin. This corresponds to the plugin configuration
we saw earlier, but does not allow you to change the ordering of
different plugins for an interface. If you enable a new interface for a
particular plugin, it will be activated and placed last in the list of
plugins for a particular interface.<br><br><img class="image-inline" src="developer-manual_archivos/image_preview_002.jpeg" alt="cookie-plugin.jpg"><br><br>You can also go to the properties tab to edit settings specific for this plugin:<br><br><img class="image-inline" src="developer-manual_archivos/image_preview.jpeg" alt="cookie-plugin-properties.jpg"><br><br>What you can configure will differ per plugin. Some plugins do not have any configurations options, others can be very complex.</p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.6.
                Concepts
            </h1>

            <p class="documentDescription">PAS has a few basic concepts that you must understand in order to develop PAS related code.</p>
    
            <div>
                
                    <div><p>There are a few basic concepts used in PAS:</p>

<dl class="docutils"><dt>credentials</dt>

<dd>Credentials are a set of information which can be used to authenticate a

user. This can be a login name and password, an IP address, a session cookie

or something else.</dd>

<dt>user name</dt>

<dd>The user name is the name used by the user to log into the system. To avoid

confusion between user id and user name this tutorial will use the term login

name instead.</dd>

<dt>user id</dt>

<dd>All users must be uniquely identified by their user id. A users id can be

different than the login name.</dd>

<dt>principal</dt>

<dd>A principal is an identifier for any entity within the authentication system.

This can be either a user or a group. This implies that it is not legal

to have a user and a group with the same id!</dd>

</dl></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.7.
                The user object
            </h1>

            <p class="documentDescription">Contrary
to other user folders, a user does not have a single source in a PAS
environment. Various aspects of a user (properties, groups, roles,
etc.) are managed by different plugins. To accommodate this, PAS
features a user object which provides a single interface to all
different aspects.</p>
    
            <div>
                
                    <div><p>There are two basic user types: a normal user (as defined by the IBasicUser

interface) and a user with member properties (defined by the IPropertiedUser

interface). Since basic users are not used within Plone we will only consider

IPropertiedUser users.</p>

<dl class="docutils"><dt>getId()</dt>

<dd>returns the user id. This is a unique identifier for a user.</dd>

<dt>getUserName()</dt>

<dd>Return the login name used by the user to log into the system.</dd>

<dt>getRoles()</dt>

<dd>Return the roles assigned to a user "globally".</dd>

<dt>getRolesInContext(context)</dt>

<dd>Return the roles assigned to the user within a specific context. This

includes the global roles as returned by getRoles().</dd>

</dl></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.8.
                User creation
            </h1>

            <p class="documentDescription">PAS uses a multi-phase algorithm to create a user object</p>
    
            <div>
                
                    <ol><li>An IUserFactoryPlugin plugin is used to create a new user object.</li><li>All IPropertiesPlugin plugins are queried to get the property sheets.</li><li>All IGroupsPlugin plugins are queried to get the groups.</li><li>All IRolesPlugin plugins are queried to get the global roles<br></li></ol></div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.9.
                User factory plugin
            </h1>

            <p class="documentDescription"> </p>
    
            <div>
                
                    <div><p>

PAS supports multiple user types. PAS contains two default user types:

IBasicUser and IPropertiesUser. IBasicUser is a simple user type which

supports a user id, login name, roles and domain restrictions.

IPropertiedUser extends this type and adds user properties.

</p>



<p>

A user factory plugin creates a new user instance. PAS will add properties,

groups and roles to this instance as part of its user creation process.

</p><p>

If no user factory plugin is able to create a user PAS will fall back to

creating a standard PropertiedUser instance.

</p><p>

The IUserFactoryPlugin interface is a simple one containing a single

method:

</p>

<pre>def createUser( user_id, name ):<br><br>    """ Return a user, if possible.<br><br>    o Return None to allow another plugin, or the default, to fire.<br>    """<br></pre>

<p>

The default PAS behaviour is demonstrated by this code::

</p>

<pre>def createUser(self, user_id, name):<br>    return ProperiedUser(user_id, name)<br></pre></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.10.
                Properties plugins
            </h1>

            <p class="documentDescription"> </p>
    
            <div>
                
                    <div><p>Properties are stored in property sheets: mapping-like objecst, such as a

standard python dictionary, which contain the properties for a principal.

The property sheets are ordered: if a property is present in multiple

property sheets only the property in the sheet with the highest priority

is visible.</p>

<p>Property sheets are created by plugins implementing the IPropertiesPlugin

interface. This interface contains only a single method:</p>

<pre class="literal-block">def getPropertiesForUser( user, request=None ):<br><br>    """ user -&gt; {}<br><br>    o User will implement IPropertiedUser.<br><br>    o Plugin may scribble on the user, if needed (but must still<br>      return a mapping, even if empty).<br><br>    o May assign properties based on values in the REQUEST object, if<br>      present<br>    """<br></pre>

<p>Here is a simple example:</p>

<pre class="literal-block">def getPropertiesForUser(self, user, request=None):<br>    return { "email" : user.getId() + "@ourcompany.com" }<br></pre>

<p>this adds an email property to a user which is hardcoded to the user id

followed by a companies domain name.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.11.
                Group plugins
            </h1>

            <p class="documentDescription"> </p>
    
            <div>
                
                    <div><p>Group plugins return the identifiers for the groups a principal is a member

of. Since a principal can be either a user or a group this implies that PAS

can support nested group members. The default PAS configuration does not

support this though.</p>

<p>Like other PAS interfaces the IGroupsPlugin interface is simple and only

specifies a single method:</p>

<pre class="literal-block">def getGroupsForPrincipal( principal, request=None ):<br><br>    """ principal -&gt; ( group_1, ... group_N )<br><br>    o Return a sequence of group names to which the principal<br>      (either a user or another group) belongs.<br><br>    o May assign groups based on values in the REQUEST object, if present<br>    """<br></pre>

<p>Here is a simple example:</p>

<pre class="literal-block">def getGroupsForPrincipal(self, principal, request=None):<br>    # Manager can not be itself<br>    if principal=="Manager":<br>        return ()<br><br>    # Only act on the current user<br>    if getSecurityManager().getUser().getId()!=principal:<br>        return ()<br><br>    # Only act if the request originates from the local host<br>    if request is not None:<br>        ip=request.get("HTTP_X_FORWARDED_FOR", request.get("REMOTE_ADDR", ""))<br>        if ip!="127.0.0.1":<br>            return ()<br><br>    return ("Manager",)<br></pre>

<p>This puts the current user in the Manager group if the site is being

accessed from the Zope server itself.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.12.
                Roles plugin
            </h1>

            <p class="documentDescription"> </p>
    
            <div>
                
                    <div><p>The IRolesPlugin plugins determine the global roles for a principal. Like

the other interfaces the IRolesPlugin interface contains only a single

method:</p>

<pre class="literal-block">def getRolesForPrincipal( principal, request=None ):<br><br>    """ principal -&gt; ( role_1, ... role_N )<br><br>    o Return a sequence of role names which the principal has.<br><br>    o May assign roles based on values in the REQUEST object, if present.<br>    """<br></pre>

<p>Here is a simple example:</p>

<pre class="literal-block">def getRolesForPrincipal(self, principal, request=None):<br>    # Only act on the current user<br>    if getSecurityManager().getUser().getId()!=principal:<br>        return ()<br><br>    # Only act if the request originates from the local host<br>    if request is not None:<br>        ip=request.get("HTTP_X_FORWARDED_FOR", request.get("REMOTE_ADDR", ""))<br>        if ip!="127.0.0.1":<br>            return ()<br><br>    return ("Manager",)<br></pre>

<p>This gives the current user in Manager role if the site is being accessed

from the Zope server itself.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.13.
                Authorisation algorithm
            </h1>

            <p class="documentDescription"> </p>
    
            <div>
                
                    <div><p>These are the steps the PAS user folder follows in its validate method:</p>

<ol class="arabic simple"><li>extract all credentials. This looks for any possible form of authentication

information in a request: HTTP cookies, HTTP form parameters, HTTP

authentication headers, originating IP address, etc. A request can have

multiple (or no) sets of credentials.</li>

<li>for each set of credentials found<ol class="arabic"><li>try to authorise the credentials. This checks if the credentials

correspond to a known user and are valid.</li>

<li>create a user instance</li>

<li>try to authorise the request. If succesful use this user and stop further

processing.</li>

</ol></li>

<li>create an anonymous user</li>

<li>try to authorise the request using the anonymous user. If succesful use this,

if not:</li>

<li>issue a challenge</li>

</ol></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.14.
                Credential extraction
            </h1>

            <p class="documentDescription">Within
PAS credentials are a set of information which can identify and
authenticate a user. A users login name and password are for example
very common credentials. You may also use an HTTP cookie to track
users; if you do so the cookie will be your credential.</p>
    
            <div>
                
                    <div><p>PAS user credential extraction plugins to find all credentials in a request.

Authentication of these credentials is done at a later stage by seperate

authentication plugin.</p>

<h2><a id="writing-a-plugin" name="writing-a-plugin">Writing a plugin</a></h2>

<p>If you want to write your own credential extraction plugin it has to

implement the IExtractionPlugin interface. This interface only has a

single method:</p>

<pre class="literal-block">def extractCredentials( request ):<br><br>    """ request -&gt; {...}<br><br>    o Return a mapping of any derived credentials.<br><br>    o Return an empty mapping to indicate that the plugin found no<br>      appropriate credentials.<br>    """<br></pre>

<p>Here is a simple example:</p>

<pre class="literal-block">def extractCredentials(self, request):<br>    login=request.get("login", None)<br><br>    if login is None:<br>        return {}<br><br>    password="request.get("password", None)<br><br>    return { "login" : login, "password" : password }<br></pre>

<p>This plugin extracts the login name and password from fields with the

same name in the request object.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.15.
                Credential authentication
            </h1>

            <p class="documentDescription">The
credentials as returned by the credential extraction plugins only
reflect the authentication information provided by the user. These
credentials need to be authenticated by an authentication plugin to
check if they are correct for a real user.</p>
    
            <div>
                
                    <div><p>The IAuthenticationPlugin interface is a simple one:</p>

<pre class="literal-block">def authenticateCredentials( credentials ):<br><br>    """ credentials -&gt; (userid, login)<br><br>    o 'credentials' will be a mapping, as returned by IExtractionPlugin.<br><br>    o Return a  tuple consisting of user ID (which may be different<br>      from the login name) and login<br><br>    o If the credentials cannot be authenticated, return None.<br>    """<br></pre>

<p>Here is a simple example:</p>

<pre class="literal-block">def authenticateCredentials(self, credentials):<br>    users={ "hanno" : "hannosch", "martin" : "optilude",<br>            "philipp" : "philiKON" }<br><br>    if "login" not in credentials or "password" not in credentials:<br>        return None<br><br>    login=credentials["login"]<br>    password=credentials["password"]<br>    if users.get(login, None)==password:<br>        return (login, login)<br><br>    return None<br></pre>

<p>This plugin allows the users <em>hanno</em>, <em>martin</em> and <em>philipp</em> to login with

their nickname as password.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.16.
                Challenges
            </h1>

            <p class="documentDescription">If
the current (possibly anonymous) user is not authorised to access a
resource Zope asks PAS to challenge the user. Generally this will
result in a login form being shown, asking the user with a
appropriately priviliged account.</p>
    
            <div>
                
                    <div><p>The IChallengeProtocolChooser and IChallengePlugins plugins work together

to do this. Since Zope can be accessed via various protocols (browsers, WebDAV, XML-RPC,

etc.) PAS first needs to figure out what kind of protocol it is dealing

with. This is done by quering all IChallengeProtocolChooser plugins. The

default implementation is ChallengeProtocolChooser, which asks all

IRequestTypeSniffer plugins to test for specific protocols.</p>

<p>Once the protocol list has been build PAS will look at all active

IChallengePlugins plugins.</p>

<h2><a id="id2" name="id2">Writing a plugin</a></h2><div class="section">

<p>The IChallengePlugin interface is very simple: it only contains one method:</p>

<pre class="literal-block">def challenge( request, response ):<br><br>    """ Assert via the response that credentials will be gathered.<br><br>    Takes a REQUEST object and a RESPONSE object.<br><br>    Returns True if it fired, False otherwise.<br><br>    Two common ways to initiate a challenge:<br><br>      - Add a 'WWW-Authenticate' header to the response object.<br><br>        NOTE: add, since the HTTP spec specifically allows for<br>        more than one challenge in a given response.<br><br>      - Cause the response object to redirect to another URL (a<br>        login form page, for instance)<br>    """<br></pre>

<p>The plugin can look at the request object to determine what, or if, it

needs to do. It can then modify the response object to issue its challenge

to the user. For example:</p>

<pre class="literal-block">def challenge(self, request, response):<br>    response.redirect("http://www.disney.com/")<br>    return True<br></pre>

<p>this will redirect a user to the Disney homepage every time he tries to access

something he is not authorised for.</p></div></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.17.
                PAS eats exceptions
            </h1>

            <p class="documentDescription"> </p>
    
            <div>
                
                    <div><p>A broken user folder is one of the worst things that can happen in Zope:

it can make it impossible to access any objects underneath the user folders

level.</p>

<p>In order to secure itself against errors in plugins PAS ignores all

exceptions of the common exception types: NameError, AttributeError,

KeyError, TypeError and ValueError.</p>

<p>This can make debugging plugins hard: an error in a plugin can be silently

ignored if its exception is swallowed by PAS.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                11.1.18.
                Plugins
            </h1>

            <p class="documentDescription">Detail about the stock plugins provided by PAS and how to create new ones</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-4">

            <h1>
                11.1.18.1.
                Plugin Interfaces
            </h1>

            <p class="documentDescription">PAS Plugins are broken down by the different functionalities they provide.</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-5">

            <h1>
                11.1.18.1.1.
                List of Plugin Interfaces
            </h1>

            <p class="documentDescription">PAS
Plugins are broken down by the different functionalities they provide.
A particular plugin may provide one or many of the following interfaces</p>
    
            <div>
                
                    <ul><li><a title="Extraction Plugins" href="http://plone.org/documentation/manual/developer-manual/users-and-security/pluggable-authentication-service/plugins/plugin-types/extraction-plugins" target="_self">Extraction Plugins</a><p>      Extraction plugins are responsible for extracting credentials from the request.</p>

</li><li><a title="Authentication Plugins" href="http://plone.org/documentation/manual/developer-manual/users-and-security/pluggable-authentication-service/plugins/plugin-types/authentication-plugins" target="_self">Authentication Plugins</a><p>      Authentication plugins are responsible for validating credentials generated by the Extraction Plugin.</p>

</li><li><a title="Challenge Plugins" href="http://plone.org/documentation/manual/developer-manual/users-and-security/pluggable-authentication-service/plugins/plugin-types/challenge-plugins" target="_self">Challenge Plugins</a><p>      Challenge plugins initiate a challenge to the user to provide credentials.</p>

</li><li><a title="Update Credentials Plugins" href="http://plone.org/documentation/manual/developer-manual/users-and-security/pluggable-authentication-service/plugins/plugin-types/update-credentials-plugins" target="_self">Update Credentials Plugins</a><p>      Credential update plugins respond to the user changing credentials.</p>

</li><li><a title="Reset Credentials Plugins" href="http://plone.org/documentation/manual/developer-manual/users-and-security/pluggable-authentication-service/plugins/plugin-types/reset-credentials-plugins" target="_self">Reset Credentials Plugins</a><p>      Credential clear plugins respond to a user logging out.</p>

</li><li>Userfactory Plugins<p>      Create users.</p>

</li><li>Anonymoususerfactory Plugins<p>      Create anonymous users.</p>

</li><li><a title="Properties Plugins" href="http://plone.org/documentation/manual/developer-manual/users-and-security/pluggable-authentication-service/plugins/plugin-types/properties-plugins" target="_self">Properties Plugins</a><p>      Properties plugins generate property sheets for users.</p>

</li><li><a title="Groups Plugins" href="http://plone.org/documentation/manual/developer-manual/users-and-security/pluggable-authentication-service/plugins/plugin-types/groups-plugins" target="_self">Groups Plugins</a><p>      Groups plugins determine the groups to which a user belongs.</p>

</li><li><a title="Roles Plugins" href="http://plone.org/documentation/manual/developer-manual/users-and-security/pluggable-authentication-service/plugins/plugin-types/roles-plugins" target="_self">Roles Plugins</a><p>      Roles plugins determine the global roles which a user has.</p>

</li><li>Update Plugins<p>      Update plugins allow the user or the application to update the user's properties.</p>

</li><li>Validation Plugins<p>      Validation plugins specify allowable values for user properties (e.g., minimum password length, allowed characters, etc.)</p>

</li><li><a title="User_Enumeration Plugins" href="http://plone.org/documentation/manual/developer-manual/users-and-security/pluggable-authentication-service/plugins/plugin-types/user_enumeration-plugins" target="_self">User_Enumeration Plugins</a><p>      Enumeration plugins allow querying users by ID, and searching for users who match particular criteria.</p>

</li><li><a title="User_Adder Plugins" href="http://plone.org/documentation/manual/developer-manual/users-and-security/pluggable-authentication-service/plugins/plugin-types/user_adder-plugins" target="_self">User_Adder Plugins</a><p>      User Adder plugins allow the Pluggable Auth Service to create users.</p>

</li><li><a title="Group_Enumeration Plugins" href="http://plone.org/documentation/manual/developer-manual/users-and-security/pluggable-authentication-service/plugins/plugin-types/group_enumeration-plugins" target="_self">Group_Enumeration Plugins</a><p>      Enumeration plugins allow querying groups by ID.</p>

</li><li><a title="Role_Enumeration Plugins" href="http://plone.org/documentation/manual/developer-manual/users-and-security/pluggable-authentication-service/plugins/plugin-types/role_enumeration-plugins" target="_self">Role_Enumeration Plugins</a><p>      Enumeration plugins allow querying roles by ID.</p>

</li><li><a title="Role_Assigner Plugins" href="http://plone.org/documentation/manual/developer-manual/users-and-security/pluggable-authentication-service/plugins/plugin-types/role_assigner-plugins" target="_self">Role_Assigner Plugins</a><p>      Role Assigner plugins allow the Pluggable Auth Service to assign </p>

</li></ul></div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-4">

            <h1>
                11.1.18.2.
                Plugin Types
            </h1>

            <p class="documentDescription">A list of the different types of plugins</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-5">

            <h1>
                11.1.18.2.1.
                Extraction Plugins
            </h1>

            <p class="documentDescription">Extraction plugins are responsible for extracting credentials from the request.</p>
    
            <div>
                
                    <div><h2 class="Heading">Stock Plugins<br></h2><p>The following stock plugins provide the IExtractionPlugin Interface.</p><h3 class="Subheading">Cookie Auth Helper</h3><p>This plugin helps manage the details of Cookie Authentication. Allows

you to extract credentials from a cookie, update them, reset them, etc.</p><h3 class="Subheading">HTTP Basic Auth Helper</h3><p>Multi-plugin for managing details of HTTP Basic Authentication.

Extracts credentials from request and implements the HTTP Auth

challenge.</p><h3 class="Subheading">Inline Auth Helper</h3><p>Manages credentials for inline authentication.</p><h3 class="Subheading">Session Auth Helper</h3><p>Extracts and manages credentials for session authentication.</p><h2 class="Heading">Methods</h2><div class="stx"><p>  Each plugin implements the following methods:</p>



<ul><li>extractCredentials() -- gets credential info from the relevant request, cookie, session, etc.</li><li>updateCredentials() -- responds to a change of credentials</li><li>resetCredentials() -- empties out currently stored values</li></ul><p>  if appropriate, the plugin will also implement a challenge() method which will challenge the user for authentication.</p></div></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-5">

            <h1>
                11.1.18.2.2.
                Authentication Plugins
            </h1>

            <p class="documentDescription">Authentication plugins are responsible for validating credentials generated by the Extraction Plugin.</p>
    
            <div>
                
                    <div><h2 class="Heading">Stock Plugins<br></h2><h3 class="Subheading">Delegating Multi Plugin</h3><p>This plugin delegates a PAS interface to some other acl_user folder,

typically a "legacy" folder that implements some specific

authentication functionality. For example, you can delegate the

IAuthenticationPlugin interface to a legacy user folder via a Delegating Multi Plugin.</p><div class="stx"><h3 class="Subheading">Domain Auth Helper</h3>Authenticates users based on their IP address.  Has nothing to do with Windows "Domain" Authentication.<br><br><h3 class="Subheading">ZODB User Manager</h3>ZODB-based user storage. Does authentication, enumeration and properties for users and stores its data in the ZODB.<br><br></div></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-5">

            <h1>
                11.1.18.2.3.
                Challenge Plugins
            </h1>

            <p class="documentDescription">Challenge plugins initiate a challenge to the user to provide credentials.</p>
    
            <div>
                
                    <div><h2 class="Heading">Stock Plugins</h2><h3 class="Subheading">Cookie Auth Helper</h3><p>This plugin helps manage the details of Cookie Authentication. Allows

you to extract credentials from a cookie, update them, reset them, etc.</p><h3 class="Subheading">HTTP Basic Auth Helper</h3><p>Multi-plugin for managing details of HTTP Basic Authentication.

Extracts credentials from request and implements the HTTP Auth

challenge.</p><h3 class="Subheading">Inline Auth Helper</h3><p>Manages credentials for inline authentication.</p><p><br></p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-5">

            <h1>
                11.1.18.2.4.
                Update Credentials Plugins
            </h1>

            <p class="documentDescription">Credential update plugins respond to the user changing credentials.</p>
    
            <div>
                
                    <div><h2 class="Heading">Stock Plugins</h2><h3 class="Subheading">Cookie Auth Helper</h3><p>This plugin helps manage the details of Cookie Authentication. Allows

you to extract credentials from a cookie, update them, reset them, etc.</p><h3 class="Subheading">Delegating Multi Plugin</h3><p>This plugin delegates a PAS interface to some other acl_user folder,

typically a "legacy" folder that implements some specific

authentication functionality. For example, you can delegate the

IAuthenticationPlugin interface to a legacy user folder via a Delegating Multi Plugin.</p><h3 class="Subheading">Inline Auth Helper</h3><p>Manages credentials for inline authentication.</p><h3 class="Subheading">Session Auth Helper</h3><p>Extracts and manages credentials for session authentication.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-5">

            <h1>
                11.1.18.2.5.
                Reset Credentials Plugins
            </h1>

            <p class="documentDescription">Credential clear plugins respond to a user logging out.</p>
    
            <div>
                
                    <div><h2 class="Heading">Stock Plugins</h2><h3 class="Subheading">Cookie Auth Helper</h3><p>This plugin helps manage the details of Cookie Authentication. Allows

you to extract credentials from a cookie, update them, reset them, etc.</p><h3 class="Subheading">Delegating Multi Plugin</h3><p>This plugin delegates a PAS interface to some other acl_user folder,

typically a "legacy" folder that implements some specific

authentication functionality. For example, you can delegate the

IAuthenticationPlugin interface to a legacy user folder via a Delegating Multi Plugin.</p><h3 class="Subheading">HTTP Basic Auth Helper</h3><p>Multi-plugin for managing details of HTTP Basic Authentication.

Extracts credentials from request and implements the HTTP Auth

challenge.</p><h3 class="Subheading">Inline Auth Helper</h3><p>Manages credentials for inline authentication.</p><h3 class="Subheading">Session Auth Helper</h3><p>Extracts and manages credentials for session authentication.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-5">

            <h1>
                11.1.18.2.6.
                Properties Plugins
            </h1>

            <p class="documentDescription">Properties plugins generate property sheets for users.</p>
    
            <div>
                
                    <div><h2 class="Heading">Stock Plugins</h2><h3 class="Subheading">Delegating Multi Plugin</h3><p>This plugin delegates a PAS interface to some other acl_user folder,

typically a "legacy" folder that implements some specific

authentication functionality. For example, you can delegate the

IAuthenticationPlugin interface to a legacy user folder via a Delegating Multi Plugin.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-5">

            <h1>
                11.1.18.2.7.
                Groups Plugins
            </h1>

            <p class="documentDescription">Groups plugins determine the groups to which a user belongs.</p>
    
            <div>
                
                    <div><h2 class="Heading">Stock Plugins<br></h2><h3 class="Subheading">Dynamic Groups Plugin</h3><p>This plugin allows you to create dynamic groups via business rules.</p><h3 class="Subheading">Recursive Groups Plugin</h3><p>This plugin will recursively flatten a collection of groups.</p><h3 class="Subheading">ZODB Group Manager</h3><p>This plugin lets you manage groups and groups of groups in the ZODB.</p><br></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-5">

            <h1>
                11.1.18.2.8.
                Roles Plugins
            </h1>

            <p class="documentDescription">Roles plugins determine the global roles which a user has.</p>
    
            <div>
                
                    <div><h2 class="Heading">Stock Plugins<br></h2><h3 class="Subheading">Delegating Multi Plugin</h3><p>This plugin delegates a PAS interface to some other acl_user folder,

typically a "legacy" folder that implements some specific

authentication functionality. For example, you can delegate the

IAuthenticationPlugin interface to a legacy user folder via a Delegating Multi Plugin.</p><h3 class="Subheading">Domain Auth Helper</h3><p>Authenticates users based on their IP address.  Has nothing to do with Windows "Domain" Authentication.</p><h3 class="Subheading">ZODB Role Manager</h3><p>Stores role information for users in the ZODB.  Handles roles storage, role enumeration, and role assignment.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-5">

            <h1>
                11.1.18.2.9.
                User_Enumeration Plugins
            </h1>

            <p class="documentDescription">Enumeration plugins allow querying users by ID, and searching for users who match particular criteria.</p>
    
            <div>
                
                    <div><h2 class="Heading">Stock Plugins<br></h2>

<h3 class="Subheading">Delegating Multi Plugin</h3>

<p>This plugin delegates a PAS interface to some other acl_user folder,

typically a "legacy" folder that implements some specific

authentication functionality. For example, you can delegate the

IAuthenticationPlugin interface to a legacy user folder via a Delegating Multi Plugin.</p>

<h3 class="Subheading">Search Principals Plugin<br></h3>

<p> Plugin to delegate enumerateUsers and enumerateGroups requests to another PluggableAuthService</p>

<h3 class="Subheading">ZODB User Manager</h3>

<p>ZODB-based user storage. Does authentication, enumeration and properties for users and stores its data in the ZODB.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-5">

            <h1>
                11.1.18.2.10.
                User_Adder Plugins
            </h1>

            <p class="documentDescription">User Adder plugins allow the Pluggable Auth Service to create users.</p>
    
            <div>
                
                    <div><h2 class="Heading">Stock Plugins<br></h2>

<h3 class="Subheading">ZODB User Manager</h3>

<p>ZODB-based user storage. Does authentication, enumeration and properties for users and stores its data in the ZODB.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-5">

            <h1>
                11.1.18.2.11.
                Group_Enumeration Plugins
            </h1>

            <p class="documentDescription">Enumeration plugins allow querying groups by ID.</p>
    
            <div>
                
                    <div><h2 class="Heading">Stock Plugins<br></h2><h3 class="Subheading">Dynamic Groups Plugin</h3><p>This plugin allows you to create dynamic groups via business rules.</p><h3 class="Subheading">Search Principals Plugin<br></h3><p> Plugin to delegate enumerateUsers and enumerateGroups requests to another PluggableAuthService</p><h3 class="Subheading">ZODB Group Manager</h3><p>This plugin lets you manage groups and groups of groups in the ZODB.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-5">

            <h1>
                11.1.18.2.12.
                Role_Enumeration Plugins
            </h1>

            <p class="documentDescription">Enumeration plugins allow querying roles by ID.</p>
    
            <div>
                
                    <div><h2 class="Heading">Stock Plugins<br></h2><h3 class="Subheading">ZODB Role Manager</h3><p>Stores role information for users in the ZODB.  Handles roles storage, role enumeration, and role assignment.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-5">

            <h1>
                11.1.18.2.13.
                Role_Assigner Plugins
            </h1>

            <p class="documentDescription">Role Assigner plugins allow the Pluggable Auth Service to assign</p>
    
            <div>
                
                    <div><h2 class="Heading">Stock Plugins<br></h2><h3 class="Subheading">ZODB Role Manager</h3><p>Stores role information for users in the ZODB.  Handles roles storage, role enumeration, and role assignment.</p></div>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    

            

        </div>        
    

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-1">

            <h1>
                12.
                Client-Side Functionality &amp; JavaScript
            </h1>

            <p class="documentDescription"></p>
    
            

            
                
    
        <div class="referenceManualCollation depth-2">

            <h1>
                12.1.
                Including JavaScript
            </h1>

            <p class="documentDescription">When in doubt, use portal_javascripts</p>
    
            <div>
                
                    <p>There
are currently an unfortunately large number of ways to inject
JavaScript link tags and direct code into the rendering pipeline for
Plone pages. Many or most of these are likely candidates for
deprecation during the 4.x series. The most "future-proof" method is to
use portal_javascripts. While it may change, there will be a
straightforward, probably automatic, migration path.<br><br><br></p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                12.2.
                Included JavaScript Libraries
            </h1>

            <p class="documentDescription">Several third-party libraries are included with the Plone core</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                12.2.1.
                jQuery
            </h1>

            <p class="documentDescription"></p>
    
            <div>
                
                    <div><p>jQuery
has been part of Plone since 3.1, and should be used for DOM selection,
traversal and manipulation; event binding and handling; and AJAX.</p>

<h2>Using jQuery</h2>

<p>Plone components should not depend on the "$" alias for jQuery. Also, the "jq" alias is deprecated.<br>If
you wish to use the "$" alias in your code, there are a couple of
common conventions that will allow you to do so without making global
changes:</p>

<pre>(function($) {
&nbsp;&nbsp;&nbsp; /* some code that uses $ */
}(jQuery));</pre>

<p>or, make use of the fact that jQuery passes itself to the document ready handler:</p>

<pre>jQuery( function($) {
&nbsp;&nbsp;&nbsp; /* some code that uses $ */
});</pre>

<p>&nbsp;</p>

<p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                12.2.2.
                jQuery Tools
            </h1>

            <p class="documentDescription"></p>
    
            <div>
                
                    <div><p><a class="external-link" href="http://flowplayer.org/tools">jQuery Tools</a> became part of Plone with 4.0 (and maybe added to Plone 3.x via plone.app.jquerytools).</p>

<p>Use jQuery Tools for tabs, tooltips, overlays, masking and scrollables.</p>

<p>Masking, in which most of the page is shaded in order to highlight
the part of the page that most needs attention, should be minimized â
though we do use masking for popup forms in order to emphasize their
modal character.<br><br></p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                12.2.3.
                jQuery Form Plugin
            </h1>

            <p class="documentDescription"></p>
    
            <div>
                
                    <div><p><a class="external-link" href="http://jquery.malsup.com/form/">The jQuery Form Plugin</a>&nbsp; became part of Plone in Plone 4.0, and is provided via plone.app.jquerytools.</p>

<p>Use it for AJAX form input marshaling and submission. Note that
jQueryâs built-in form input marshaling is inadequate for many forms
as it does not handle submit-button or file-input data.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                12.2.4.
                Other Libraries
            </h1>

            <p class="documentDescription"></p>
    
            <div>
                
                    <p>If
you need to include a new third-party library with Ploneâs core, that
inclusion must be PLIPâd and approved by the framework team.
Licensing must be GPL 2 compatible.</p>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                12.3.
                Popup Overlays &amp; Forms
            </h1>

            <p class="documentDescription"></p>
    
            <div>
                
                    <div><p>plone.app.jquerytools
provides a âprepOverlayâ plugin that makes it easy to create popup
overlays to display images or AJAX-loaded content from other pages. It
also handles AJAX submission of forms in popups.</p>

<p>The prepOverlay plugin is well-documented at <a class="external-link" href="http://pypi.python.org/pypi/plone.app.jquerytools">http://pypi.python.org/pypi/plone.app.jquerytools</a>.
Many usage examples are available in
Products/CMFPlone/skins/plone_ecmascripts/popupforms.js, which provides
the setup for Plone 4âs standard popup forms.<br><br></p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                12.4.
                JavaScript Standards
            </h1>

            <p class="documentDescription">Community standards for use in JavaScript components.</p>
    
            

            
                
    
        <div class="referenceManualCollation depth-3">

            <h1>
                12.4.1.
                Recommendations for JavaScript Components
            </h1>

            <p class="documentDescription">JavaScript components should follow the principles of progressive enhancement and unobtrusive JavaScript.</p>
    
            <div>
                
                    <div><h2>Progressive Enhancement</h2>

<p>Pages presented in Plone, including forms and form widgets, must be
fully usable in situations where JavaScript is not available. The
availability of JavaScript on the browser side should enhance the
presentation of the page and its content. Additionally, the structured
document delivered via HTML/XHTML should be semantically correct and
complete in meaning.<br>The best way to accomplish these goals is to:
first. compose complete and useful content in HTML; second, style its
presentation with CSS; and third, make use of JavaScript behaviors to
enhance presentation and interaction.</p>

<h2>Unobtrusive JavaScript</h2>

<p>JavaScript should nearly never be present in the content area of a
page. Typically, it will only appear via link and script elements in
the head of the document (or at its very end when that improved
rendering).<br>In particular, HTML tags should nearly never have
event-handler (e.g., onclick or onsubmit) tag attributes or JavaScript
in URLs. Coding JavaScript into HTML tags generally makes for code that
is hard to maintain and nearly impossible to test.<br>Instead of coding
event handlers in HTML attributes, use jQueryâs âbindâ and its
various convenience aliases like âclickâ methods to attach event
handlers to elements. Use âliveâ if installing behaviors that need
to operate in AJAX-loaded HTML.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                12.4.2.
                Coding Standards
            </h1>

            <p class="documentDescription"></p>
    
            <div>
                
                    <div><h2>JSLint</h2>

<p>All JavaScript components that are incorporated into the Plone core
must pass JSLint code quality tests. At some point in the 4.x series,
this will become part of Ploneâs continuous integration testing.<br>JSLint
has many options, and it is our goal that our code pass âThe Good
Partsâ tests. A couple of acceptable deviations from the good parts
settings are to:</p>

<ul><li>Assume a browser /*jslint browser: true */;</li><li>Relax white-space requirements (removing âwhite: trueâ) to allow for idiomatic composition of jQuery cascades.</li></ul><ul><li>Assume availability of the globals jQuery, browser, window and location.</li></ul><p>You may set these options by including at the top of your JavaScript file:</p>

<pre>/*jslint white:false, onevar:true, undef:true, nomen:true, eqeqeq:true, plusplus:true, bitwise:true, regexp:true, newcap:true, immed:true, strict:false, browser:true */

/*global jQuery:false, document:false, window:false, location:false */</pre>

<p>These settings are available as a file in
Products/CMFPlone/skins/plone_ecmascript/js-standards.js. If you use
those settings, you only need set the options for any deviations needed
by the current file. Deviations like turning off the regular-expression
"." prohibition, are perfectly reasonable when porting old code, but
should be avoided in new code.</p>

<p>A common way to execute a command-line jslint test using these options would be to execute:</p>

<pre>cat js-standards.js accessibility.js | jslint</pre>

<p>if you were testing the âaccessibility.jsâ file. JSLint is also
available as a plugin for most popular web code editors and can be set
to test on save. An example of setting up TextMate to run jslint on
save:</p>

<h3><img class="image-inline" src="developer-manual_archivos/image_preview.png" alt="JSLint on Save"></h3>

<h3>Strict Mode</h3>

<p>Do not include the âuse strictâ directive unless you are testing
in an environment that will enforce the strict standard. Otherwise,
your code may fail when execu</p>

<p>ted on future browsers.</p>

<h3>Globals</h3>

<p>JavaScript components should create as few as possible global
variables. If a component must create globals, it should only create
one: a namespace object with a very distinctive name. Please document
your new global at the top of the component file.</p>

<p>&nbsp;</p>

<p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-3">

            <h1>
                12.4.3.
                Rendering Tests
            </h1>

            <p class="documentDescription"></p>
    
            <div>
                
                    <p>If
you add a behavior that is intended to be generally useful, you should
add an example/test usage to the rendering test document, available at:
Products/CMFPlone/skins/plone_templates/test_rendering.pt. This
document provides usage examples as well as rendering tests.<br><br></p>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                12.5.
                AJAX &amp; Errors
            </h1>

            <p class="documentDescription"></p>
    
            <div>
                
                    <div><p>AJAX
work inevitably introduces error-handling problems. The recommended
solution for this class of problems is to reverse the
progressive-enhancement process. Since AJAX functionality should be an
enhancing supplement, it should nearly always be possible to solve AJAX
error problems by falling back on un-enhanced behavior. Note that the
un-enhanced behavior may well be an error page.<br>This is more an error-handling philosophy than a recipe, and may in particular not be applicable in a multi-step process.</p>

<p>An example: it's common to use AJAX in forms to validate on a
field-by-field basis. However, all such forms should also be handling
form errors without JavaScript by returning error messages after
feedback. Rather than introducing complex error-handling for AJAX
failures during live form validation, it's simpler and more robust to
fall back to server validation of the entire form.</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                12.6.
                Animations
            </h1>

            <p class="documentDescription"></p>
    
            <div>
                
                    <p>The
general purpose of JavaScript animations in Plone is to provide a
visual cue to the user when a part of the page is changed. (Instantly
changing the page may leave the user confused as to what has changed.)
Developers should resist the temptation to deploy new animations. Stick
with the animations provided by jQuery and jQuery Tools. Animations
should last no longer than necessary to signal changes.<br><br><br></p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                12.7.
                Platform Testing
            </h1>

            <p class="documentDescription"></p>
    
            <div>
                
                    <div><p>JavaScript for Plone core must be tested on:</p>

<ul><li>IE 7, 8, 9</li><li>Firefox, current release and most-recent beta or rc for the next release, if available</li><li>Webkit browsers: Current</li></ul><p>In
general, degrade gracefully to no-js behavior when a platform cannot be
supported. You need not support IE 6, but if you know that a feature
works poorly on IE 6, simply turn it off:</p>

<pre>if (jQuery.browser.msie &amp;&amp; parseInt(jQuery.browser.version, 10) &lt; 7) {
&nbsp;&nbsp;&nbsp; return;
}
</pre>

<p>&nbsp;</p></div>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                12.8.
                Messages &amp; Translation
            </h1>

            <p class="documentDescription"></p>
    
            <div>
                
                    <p>JavaScript
components should include as few messages as possible. Whenever
possible, the messages you display via JavaScript should be drawn from
the page.<br>If thatâs not possible, it is your responsibility to assure that the messages you need are translatable.<br>Our
current mechanism for doing that is to include the messages via
Products/CMFPlone/browser/jsvariables.py. This will nearly certainly be
changed.<br><br></p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                12.9.
                Testing
            </h1>

            <p class="documentDescription"></p>
    
            <div>
                
                    <p>As
of this writing, the Plone community has not settled on standards for
JavaScript unit and integration testing. QUnit is (as of this writing),
the most common unit-testing mechanism. Selenium and Windmill are both
in use for unit testing.<br>Plone 4.2 is expected to include strong
recommendations for both unit and integration testing, and these will
be supported by our continuous integration testing.<br><br></p>
                
                
            </div>

            

        </div>        
    
    
        <div class="referenceManualCollation depth-2">

            <h1>
                12.10.
                KSS
            </h1>

            <p class="documentDescription"></p>
    
            <div>
                
                    <p>KSS
was Plones standard mechanism for binding behaviors to document nodes,
but it is being gradually replaced with jQuery. As of Plone 4.1, KSS is
deprecated. Please do not create new KSS-dependent functionality. Make
plans to replace existing functionality.</p>
                
                
            </div>

            

        </div>        
    

            

        </div>        
    


            </div>
        </div><div id="viewlet-below-content">
</div></div><!-- End cell --><div class="grid-cell position-two-thirds width-third"><div id="sidebar"><div id="portletwrapper-706c6f6e652e6c656674636f6c756d6e0a636f6e74656e745f747970650a48656c7043656e7465725265666572656e63654d616e75616c0a706f72746c65745f7068635f61626f7574" class="portletWrapper kssattr-portlethash-706c6f6e652e6c656674636f6c756d6e0a636f6e74656e745f747970650a48656c7043656e7465725265666572656e63654d616e75616c0a706f72746c65745f7068635f61626f7574">


  
    <div>

<dl class="portlet"><dt class="portletHeader">
		About
	</dt>

	<dd class="portletItem">

    

    <div id="phcMetadata">
      	<p><strong>Use with</strong>:
      	Plone 4, Plone 3<br><strong>Relevant for</strong>:
      	  Developers
        
      	</p>

        

            <img src="developer-manual_archivos/defaultUser.gif" alt="" class="portraitPhoto" style="margin: 0pt 1em 0.5em 0pt; float: left;" height="100" width="75"><p>This document was contributed by
               <a href="http://plone.org/author/plone-docs">Plone Documentation Team</a>,
               and last modified
               210
               days ago.
            </p>
            <p>
                Also contributing: <span>Mikko Ohtamma, Martin Aspeli, Kamon Ayeva, Israel Saeta Pérez</span>.
            </p>
        
    </div>	

    <p></p>
	
    <p>
    <img src="developer-manual_archivos/speakplone_sm.png" alt="" style="float: left;" height="28" width="80">
      Visit our 
      <a href="http://plone.org/support/chat">chat rooms</a> or 
      <a href="http://plone.org/support/forums">support forums</a> 
      if you have more specific questions.
    </p>

    <p>You can also learn how to design, build, and deploy a website in Plone 
    through one of the numerous 
    <a href="http://plone.org/events/training">Plone training sessions</a> around the world.
    </p>

    <p>Report errors, omissions, etc., to the documentation by emailing <a href="mailto:plone-docs@lists.sourceforge.net">plone-docs@lists.sourceforge.net</a></p>

  </dd>

</dl></div>
  

  

</div></div></div></div><!-- End row --><div class="grid-row"><div class="grid-cell position-leftmost width-full"><div id="footer-portlets"></div></div></div><!-- End footer portlets row --></div><div style="clear: both;">&nbsp;</div></div><!-- end inner-wrapper --><div id="push"></div></div><!-- end outer-wrapper --><div id="footer-wrapper"><div id="footer-gradient"></div><div id="footer"><a id="footer-logo" href="http://plone.org/" title="Plone CMS, the open source content management system"></a><p>The Plone<sup>®</sup> CMS/WCM is © 2000–2010 the Plone Foundation and friends. Site hosted by <a href="http://www.sixfeetup.com/" style="color: white;">Six Feet Up</a>.</p><p>Plone<sup>®</sup> and the Plone logo are registered trademarks of the Plone Foundation. You’re looking good today.</p><div id="sitemap"><!-- <dl>
				<dt><a href="">Plone for…</a></dt>
				<dd><a href="">Small/Medium Business </a></dd>
				<dd><a href="">Enterprise            </a></dd>
				<dd><a href="">Non-profits           </a></dd>
				<dd><a href="">Government            </a></dd>
				<dd><a href="">Education             </a></dd>
				<dd><a href="">Science               </a></dd>
				<dd><a href="">Media &amp; Publishing</a></dd>
			</dl> --><dl><dt><a href="http://plone.org/products">Downloads</a></dt><dd><a href="http://plone.org/download">Get Plone</a></dd><dd><a href="http://plone.org/products?getCategories=themes">Themes</a></dd><dd><a href="http://plone.org/products?getCategories=dev">Development tools</a></dd><dd><a href="http://plone.org/products?getCategories=auth">Authentication</a></dd><dd><a href="http://plone.org/products">…and more.</a></dd></dl><dl><dt><a href="http://plone.org/documentation">Documentation</a></dt><dd><a href="http://plone.org/documentation/faq/">FAQs</a></dd><dd><a href="http://plone.org/documentation/movies/">Tutorial videos</a></dd><dd><a href="http://plone.org/documentation/manual">Manuals</a></dd><dd><a href="http://plone.org/documentation/books">Books</a></dd><!-- <dd><a href="">Knowledge Base</a></dd> --><dd><a href="http://plone.org/documentation/error">Error Reference</a></dd><!-- <dd><a href="">Module documentation</a></dd> --><dd><a href="http://plone.net/sites">Sites using Plone</a></dd></dl><dl><dt><a href="http://dev.plone.org/plone">Developers</a></dt><dd><a href="http://dev.plone.org/plone/roadmap">Roadmap</a></dd><dd><a href="http://dev.plone.org/plone">Report bugs in Plone</a></dd><dd><a href="http://dev.plone.org/plone.org">Report website issues</a></dd><dd><a href="http://dev.plone.org/plone/timeline">Latest changes</a></dd><dd><a href="http://dev.plone.org/plone/browser">Browse source</a></dd><dd><a href="http://dev.plone.org/plone">Contribute to Plone</a></dd><dd><a href="http://planet.plone.org/">Community blogs</a></dd></dl><dl><dt><a href="http://plone.org/foundation">Plone Foundation</a></dt><dd><a href="http://plone.org/foundation/foundation-donations">Donate</a></dd><dd><a href="http://plone.org/foundation/donors">Sponsors</a></dd><dd><a href="http://plone.org/foundation/meetings/minutes">Meeting minutes</a></dd><dd><a href="http://plone.org/team/FoundationBoard">Current board</a></dd><dd><a href="http://plone.org/foundation/members">Foundation members</a></dd><dd><a href="http://plone.org/foundation/membership">Apply for membership</a></dd><dd><a href="http://plone.org/foundation#contact">Contact</a></dd></dl><dl><dt><a href="http://plone.org/support">Support</a></dt><dd><a href="http://plone.net/providers">Commercial services</a></dd><dd><a href="http://plone.org/support/chat">Chat room</a></dd><dd><a href="http://plone.org/support/forums">Forums</a></dd><dd><a href="http://plone.org/support/for">Sector-specific forums</a></dd><dd><a href="http://plone.org/support/region">Region-specific forums</a></dd><dd><a href="http://plone.org/support/local-user-groups">Local user groups</a></dd><dd><a href="http://plone.org/events/training">Training</a></dd></dl></div></div></div><script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-1907133-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script></body></html>